{"ast":null,"code":"const e = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : global,\n      t = Object.keys,\n      n = Array.isArray;\n\nfunction r(e, n) {\n  return \"object\" != typeof n || t(n).forEach(function (t) {\n    e[t] = n[t];\n  }), e;\n}\n\n\"undefined\" == typeof Promise || e.Promise || (e.Promise = Promise);\nconst s = Object.getPrototypeOf,\n      i = {}.hasOwnProperty;\n\nfunction o(e, t) {\n  return i.call(e, t);\n}\n\nfunction a(e, n) {\n  \"function\" == typeof n && (n = n(s(e))), (\"undefined\" == typeof Reflect ? t : Reflect.ownKeys)(n).forEach(t => {\n    l(e, t, n[t]);\n  });\n}\n\nconst u = Object.defineProperty;\n\nfunction l(e, t, n, s) {\n  u(e, t, r(n && o(n, \"get\") && \"function\" == typeof n.get ? {\n    get: n.get,\n    set: n.set,\n    configurable: !0\n  } : {\n    value: n,\n    configurable: !0,\n    writable: !0\n  }, s));\n}\n\nfunction c(e) {\n  return {\n    from: function (t) {\n      return e.prototype = Object.create(t.prototype), l(e.prototype, \"constructor\", e), {\n        extend: a.bind(null, e.prototype)\n      };\n    }\n  };\n}\n\nconst h = Object.getOwnPropertyDescriptor;\n\nfunction d(e, t) {\n  let n;\n  return h(e, t) || (n = s(e)) && d(n, t);\n}\n\nconst f = [].slice;\n\nfunction p(e, t, n) {\n  return f.call(e, t, n);\n}\n\nfunction y(e, t) {\n  return t(e);\n}\n\nfunction m(e) {\n  if (!e) throw new Error(\"Assertion Failed\");\n}\n\nfunction v(t) {\n  e.setImmediate ? setImmediate(t) : setTimeout(t, 0);\n}\n\nfunction g(e, t) {\n  return e.reduce((e, n, r) => {\n    var s = t(n, r);\n    return s && (e[s[0]] = s[1]), e;\n  }, {});\n}\n\nfunction b(e, t) {\n  if (o(e, t)) return e[t];\n  if (!t) return e;\n\n  if (\"string\" != typeof t) {\n    for (var n = [], r = 0, s = t.length; r < s; ++r) {\n      var i = b(e, t[r]);\n      n.push(i);\n    }\n\n    return n;\n  }\n\n  var a = t.indexOf(\".\");\n\n  if (-1 !== a) {\n    var u = e[t.substr(0, a)];\n    return void 0 === u ? void 0 : b(u, t.substr(a + 1));\n  }\n}\n\nfunction _(e, t, r) {\n  if (e && void 0 !== t && (!(\"isFrozen\" in Object) || !Object.isFrozen(e))) if (\"string\" != typeof t && \"length\" in t) {\n    m(\"string\" != typeof r && \"length\" in r);\n\n    for (var s = 0, i = t.length; s < i; ++s) _(e, t[s], r[s]);\n  } else {\n    var a = t.indexOf(\".\");\n\n    if (-1 !== a) {\n      var u = t.substr(0, a),\n          l = t.substr(a + 1);\n      if (\"\" === l) void 0 === r ? n(e) && !isNaN(parseInt(u)) ? e.splice(u, 1) : delete e[u] : e[u] = r;else {\n        var c = e[u];\n        c && o(e, u) || (c = e[u] = {}), _(c, l, r);\n      }\n    } else void 0 === r ? n(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = r;\n  }\n}\n\nfunction w(e) {\n  var t = {};\n\n  for (var n in e) o(e, n) && (t[n] = e[n]);\n\n  return t;\n}\n\nconst x = [].concat;\n\nfunction k(e) {\n  return x.apply([], e);\n}\n\nconst E = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\".split(\",\").concat(k([8, 16, 32, 64].map(e => [\"Int\", \"Uint\", \"Float\"].map(t => t + e + \"Array\")))).filter(t => e[t]),\n      P = E.map(t => e[t]);\ng(E, e => [e, !0]);\nlet K = null;\n\nfunction O(e) {\n  K = \"undefined\" != typeof WeakMap && new WeakMap();\n  const t = S(e);\n  return K = null, t;\n}\n\nfunction S(e) {\n  if (!e || \"object\" != typeof e) return e;\n  let t = K && K.get(e);\n  if (t) return t;\n\n  if (n(e)) {\n    t = [], K && K.set(e, t);\n\n    for (var r = 0, i = e.length; r < i; ++r) t.push(S(e[r]));\n  } else if (P.indexOf(e.constructor) >= 0) t = e;else {\n    const n = s(e);\n\n    for (var a in t = n === Object.prototype ? {} : Object.create(n), K && K.set(e, t), e) o(e, a) && (t[a] = S(e[a]));\n  }\n\n  return t;\n}\n\nconst {\n  toString: A\n} = {};\n\nfunction C(e) {\n  return A.call(e).slice(8, -1);\n}\n\nconst j = \"undefined\" != typeof Symbol ? Symbol.iterator : \"@@iterator\",\n      D = \"symbol\" == typeof j ? function (e) {\n  var t;\n  return null != e && (t = e[j]) && t.apply(e);\n} : function () {\n  return null;\n},\n      I = {};\n\nfunction B(e) {\n  var t, r, s, i;\n\n  if (1 === arguments.length) {\n    if (n(e)) return e.slice();\n    if (this === I && \"string\" == typeof e) return [e];\n\n    if (i = D(e)) {\n      for (r = []; !(s = i.next()).done;) r.push(s.value);\n\n      return r;\n    }\n\n    if (null == e) return [e];\n\n    if (\"number\" == typeof (t = e.length)) {\n      for (r = new Array(t); t--;) r[t] = e[t];\n\n      return r;\n    }\n\n    return [e];\n  }\n\n  for (t = arguments.length, r = new Array(t); t--;) r[t] = arguments[t];\n\n  return r;\n}\n\nconst T = \"undefined\" != typeof Symbol ? e => \"AsyncFunction\" === e[Symbol.toStringTag] : () => !1;\nvar R = \"undefined\" != typeof location && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n\nfunction F(e, t) {\n  R = e, M = t;\n}\n\nvar M = () => !0;\n\nconst N = !new Error(\"\").stack;\n\nfunction q() {\n  if (N) try {\n    throw q.arguments, new Error();\n  } catch (e) {\n    return e;\n  }\n  return new Error();\n}\n\nfunction $(e, t) {\n  var n = e.stack;\n  return n ? (t = t || 0, 0 === n.indexOf(e.name) && (t += (e.name + e.message).split(\"\\n\").length), n.split(\"\\n\").slice(t).filter(M).map(e => \"\\n\" + e).join(\"\")) : \"\";\n}\n\nvar U = [\"Unknown\", \"Constraint\", \"Data\", \"TransactionInactive\", \"ReadOnly\", \"Version\", \"NotFound\", \"InvalidState\", \"InvalidAccess\", \"Abort\", \"Timeout\", \"QuotaExceeded\", \"Syntax\", \"DataClone\"],\n    L = [\"Modify\", \"Bulk\", \"OpenFailed\", \"VersionChange\", \"Schema\", \"Upgrade\", \"InvalidTable\", \"MissingAPI\", \"NoSuchDatabase\", \"InvalidArgument\", \"SubTransaction\", \"Unsupported\", \"Internal\", \"DatabaseClosed\", \"PrematureCommit\", \"ForeignAwait\"].concat(U),\n    V = {\n  VersionChanged: \"Database version changed by other database connection\",\n  DatabaseClosed: \"Database has been closed\",\n  Abort: \"Transaction aborted\",\n  TransactionInactive: \"Transaction has already completed or failed\",\n  MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\n\nfunction W(e, t) {\n  this._e = q(), this.name = e, this.message = t;\n}\n\nfunction Y(e, t) {\n  return e + \". Errors: \" + Object.keys(t).map(e => t[e].toString()).filter((e, t, n) => n.indexOf(e) === t).join(\"\\n\");\n}\n\nfunction z(e, t, n, r) {\n  this._e = q(), this.failures = t, this.failedKeys = r, this.successCount = n, this.message = Y(e, t);\n}\n\nfunction G(e, t) {\n  this._e = q(), this.name = \"BulkError\", this.failures = Object.keys(t).map(e => t[e]), this.failuresByPos = t, this.message = Y(e, t);\n}\n\nc(W).from(Error).extend({\n  stack: {\n    get: function () {\n      return this._stack || (this._stack = this.name + \": \" + this.message + $(this._e, 2));\n    }\n  },\n  toString: function () {\n    return this.name + \": \" + this.message;\n  }\n}), c(z).from(W), c(G).from(W);\nvar H = L.reduce((e, t) => (e[t] = t + \"Error\", e), {});\nconst Q = W;\nvar X = L.reduce((e, t) => {\n  var n = t + \"Error\";\n\n  function r(e, r) {\n    this._e = q(), this.name = n, e ? \"string\" == typeof e ? (this.message = `${e}${r ? \"\\n \" + r : \"\"}`, this.inner = r || null) : \"object\" == typeof e && (this.message = `${e.name} ${e.message}`, this.inner = e) : (this.message = V[t] || n, this.inner = null);\n  }\n\n  return c(r).from(Q), e[t] = r, e;\n}, {});\nX.Syntax = SyntaxError, X.Type = TypeError, X.Range = RangeError;\nvar J = U.reduce((e, t) => (e[t + \"Error\"] = X[t], e), {});\nvar Z = L.reduce((e, t) => (-1 === [\"Syntax\", \"Type\", \"Range\"].indexOf(t) && (e[t + \"Error\"] = X[t]), e), {});\n\nfunction ee() {}\n\nfunction te(e) {\n  return e;\n}\n\nfunction ne(e, t) {\n  return null == e || e === te ? t : function (n) {\n    return t(e(n));\n  };\n}\n\nfunction re(e, t) {\n  return function () {\n    e.apply(this, arguments), t.apply(this, arguments);\n  };\n}\n\nfunction se(e, t) {\n  return e === ee ? t : function () {\n    var n = e.apply(this, arguments);\n    void 0 !== n && (arguments[0] = n);\n    var r = this.onsuccess,\n        s = this.onerror;\n    this.onsuccess = null, this.onerror = null;\n    var i = t.apply(this, arguments);\n    return r && (this.onsuccess = this.onsuccess ? re(r, this.onsuccess) : r), s && (this.onerror = this.onerror ? re(s, this.onerror) : s), void 0 !== i ? i : n;\n  };\n}\n\nfunction ie(e, t) {\n  return e === ee ? t : function () {\n    e.apply(this, arguments);\n    var n = this.onsuccess,\n        r = this.onerror;\n    this.onsuccess = this.onerror = null, t.apply(this, arguments), n && (this.onsuccess = this.onsuccess ? re(n, this.onsuccess) : n), r && (this.onerror = this.onerror ? re(r, this.onerror) : r);\n  };\n}\n\nfunction oe(e, t) {\n  return e === ee ? t : function (n) {\n    var s = e.apply(this, arguments);\n    r(n, s);\n    var i = this.onsuccess,\n        o = this.onerror;\n    this.onsuccess = null, this.onerror = null;\n    var a = t.apply(this, arguments);\n    return i && (this.onsuccess = this.onsuccess ? re(i, this.onsuccess) : i), o && (this.onerror = this.onerror ? re(o, this.onerror) : o), void 0 === s ? void 0 === a ? void 0 : a : r(s, a);\n  };\n}\n\nfunction ae(e, t) {\n  return e === ee ? t : function () {\n    return !1 !== t.apply(this, arguments) && e.apply(this, arguments);\n  };\n}\n\nfunction ue(e, t) {\n  return e === ee ? t : function () {\n    var n = e.apply(this, arguments);\n\n    if (n && \"function\" == typeof n.then) {\n      for (var r = this, s = arguments.length, i = new Array(s); s--;) i[s] = arguments[s];\n\n      return n.then(function () {\n        return t.apply(r, i);\n      });\n    }\n\n    return t.apply(this, arguments);\n  };\n}\n\nZ.ModifyError = z, Z.DexieError = W, Z.BulkError = G;\nvar le = {};\nconst [ce, he, de] = \"undefined\" == typeof Promise ? [] : (() => {\n  let e = Promise.resolve();\n  if (\"undefined\" == typeof crypto || !crypto.subtle) return [e, s(e), e];\n  const t = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n  return [t, s(t), e];\n})(),\n      fe = he && he.then,\n      pe = ce && ce.constructor,\n      ye = !!de;\n\nvar me = !1,\n    ve = de ? () => {\n  de.then(qe);\n} : e.setImmediate ? setImmediate.bind(null, qe) : e.MutationObserver ? () => {\n  var e = document.createElement(\"div\");\n  new MutationObserver(() => {\n    qe(), e = null;\n  }).observe(e, {\n    attributes: !0\n  }), e.setAttribute(\"i\", \"1\");\n} : () => {\n  setTimeout(qe, 0);\n},\n    ge = function (e, t) {\n  Oe.push([e, t]), _e && (ve(), _e = !1);\n},\n    be = !0,\n    _e = !0,\n    we = [],\n    xe = [],\n    ke = null,\n    Ee = te,\n    Pe = {\n  id: \"global\",\n  global: !0,\n  ref: 0,\n  unhandleds: [],\n  onunhandled: ct,\n  pgp: !1,\n  env: {},\n  finalize: function () {\n    this.unhandleds.forEach(e => {\n      try {\n        ct(e[0], e[1]);\n      } catch (e) {}\n    });\n  }\n},\n    Ke = Pe,\n    Oe = [],\n    Se = 0,\n    Ae = [];\n\nfunction Ce(e) {\n  if (\"object\" != typeof this) throw new TypeError(\"Promises must be constructed via new\");\n  this._listeners = [], this.onuncatched = ee, this._lib = !1;\n  var t = this._PSD = Ke;\n\n  if (R && (this._stackHolder = q(), this._prev = null, this._numPrev = 0), \"function\" != typeof e) {\n    if (e !== le) throw new TypeError(\"Not a function\");\n    return this._state = arguments[1], this._value = arguments[2], void (!1 === this._state && Be(this, this._value));\n  }\n\n  this._state = null, this._value = null, ++t.ref, Ie(this, e);\n}\n\nconst je = {\n  get: function () {\n    var e = Ke,\n        t = Qe;\n\n    function n(n, r) {\n      var s = !e.global && (e !== Ke || t !== Qe);\n      const i = s && !et();\n      var o = new Ce((t, o) => {\n        Re(this, new De(ut(n, e, s, i), ut(r, e, s, i), t, o, e));\n      });\n      return R && Ne(o, this), o;\n    }\n\n    return n.prototype = le, n;\n  },\n  set: function (e) {\n    l(this, \"then\", e && e.prototype === le ? je : {\n      get: function () {\n        return e;\n      },\n      set: je.set\n    });\n  }\n};\n\nfunction De(e, t, n, r, s) {\n  this.onFulfilled = \"function\" == typeof e ? e : null, this.onRejected = \"function\" == typeof t ? t : null, this.resolve = n, this.reject = r, this.psd = s;\n}\n\nfunction Ie(e, t) {\n  try {\n    t(t => {\n      if (null === e._state) {\n        if (t === e) throw new TypeError(\"A promise cannot be resolved with itself.\");\n        var n = e._lib && $e();\n        t && \"function\" == typeof t.then ? Ie(e, (e, n) => {\n          t instanceof Ce ? t._then(e, n) : t.then(e, n);\n        }) : (e._state = !0, e._value = t, Te(e)), n && Ue();\n      }\n    }, Be.bind(null, e));\n  } catch (t) {\n    Be(e, t);\n  }\n}\n\nfunction Be(e, t) {\n  if (xe.push(t), null === e._state) {\n    var n = e._lib && $e();\n    t = Ee(t), e._state = !1, e._value = t, R && null !== t && \"object\" == typeof t && !t._promise && function (e, t, n) {\n      try {\n        e.apply(null, n);\n      } catch (e) {\n        t && t(e);\n      }\n    }(() => {\n      var n = d(t, \"stack\");\n      t._promise = e, l(t, \"stack\", {\n        get: () => me ? n && (n.get ? n.get.apply(t) : n.value) : e.stack\n      });\n    }), function (e) {\n      we.some(t => t._value === e._value) || we.push(e);\n    }(e), Te(e), n && Ue();\n  }\n}\n\nfunction Te(e) {\n  var t = e._listeners;\n  e._listeners = [];\n\n  for (var n = 0, r = t.length; n < r; ++n) Re(e, t[n]);\n\n  var s = e._PSD;\n  --s.ref || s.finalize(), 0 === Se && (++Se, ge(() => {\n    0 == --Se && Le();\n  }, []));\n}\n\nfunction Re(e, t) {\n  if (null !== e._state) {\n    var n = e._state ? t.onFulfilled : t.onRejected;\n    if (null === n) return (e._state ? t.resolve : t.reject)(e._value);\n    ++t.psd.ref, ++Se, ge(Fe, [n, e, t]);\n  } else e._listeners.push(t);\n}\n\nfunction Fe(e, t, n) {\n  try {\n    ke = t;\n    var r,\n        s = t._value;\n    t._state ? r = e(s) : (xe.length && (xe = []), r = e(s), -1 === xe.indexOf(s) && function (e) {\n      var t = we.length;\n\n      for (; t;) if (we[--t]._value === e._value) return void we.splice(t, 1);\n    }(t)), n.resolve(r);\n  } catch (e) {\n    n.reject(e);\n  } finally {\n    ke = null, 0 == --Se && Le(), --n.psd.ref || n.psd.finalize();\n  }\n}\n\nfunction Me(e, t, n) {\n  if (t.length === n) return t;\n  var r = \"\";\n\n  if (!1 === e._state) {\n    var s,\n        i,\n        o = e._value;\n    null != o ? (s = o.name || \"Error\", i = o.message || o, r = $(o, 0)) : (s = o, i = \"\"), t.push(s + (i ? \": \" + i : \"\") + r);\n  }\n\n  return R && ((r = $(e._stackHolder, 2)) && -1 === t.indexOf(r) && t.push(r), e._prev && Me(e._prev, t, n)), t;\n}\n\nfunction Ne(e, t) {\n  var n = t ? t._numPrev + 1 : 0;\n  n < 100 && (e._prev = t, e._numPrev = n);\n}\n\nfunction qe() {\n  $e() && Ue();\n}\n\nfunction $e() {\n  var e = be;\n  return be = !1, _e = !1, e;\n}\n\nfunction Ue() {\n  var e, t, n;\n\n  do {\n    for (; Oe.length > 0;) for (e = Oe, Oe = [], n = e.length, t = 0; t < n; ++t) {\n      var r = e[t];\n      r[0].apply(null, r[1]);\n    }\n  } while (Oe.length > 0);\n\n  be = !0, _e = !0;\n}\n\nfunction Le() {\n  var e = we;\n  we = [], e.forEach(e => {\n    e._PSD.onunhandled.call(null, e._value, e);\n  });\n\n  for (var t = Ae.slice(0), n = t.length; n;) t[--n]();\n}\n\nfunction Ve(e) {\n  return new Ce(le, !1, e);\n}\n\nfunction We(e, t) {\n  var n = Ke;\n  return function () {\n    var r = $e(),\n        s = Ke;\n\n    try {\n      return st(n, !0), e.apply(this, arguments);\n    } catch (e) {\n      t && t(e);\n    } finally {\n      st(s, !1), r && Ue();\n    }\n  };\n}\n\na(Ce.prototype, {\n  then: je,\n  _then: function (e, t) {\n    Re(this, new De(null, null, e, t, Ke));\n  },\n  catch: function (e) {\n    if (1 === arguments.length) return this.then(null, e);\n    var t = arguments[0],\n        n = arguments[1];\n    return \"function\" == typeof t ? this.then(null, e => e instanceof t ? n(e) : Ve(e)) : this.then(null, e => e && e.name === t ? n(e) : Ve(e));\n  },\n  finally: function (e) {\n    return this.then(t => (e(), t), t => (e(), Ve(t)));\n  },\n  stack: {\n    get: function () {\n      if (this._stack) return this._stack;\n\n      try {\n        me = !0;\n        var e = Me(this, [], 20).join(\"\\nFrom previous: \");\n        return null !== this._state && (this._stack = e), e;\n      } finally {\n        me = !1;\n      }\n    }\n  },\n  timeout: function (e, t) {\n    return e < 1 / 0 ? new Ce((n, r) => {\n      var s = setTimeout(() => r(new X.Timeout(t)), e);\n      this.then(n, r).finally(clearTimeout.bind(null, s));\n    }) : this;\n  }\n}), \"undefined\" != typeof Symbol && Symbol.toStringTag && l(Ce.prototype, Symbol.toStringTag, \"Dexie.Promise\"), Pe.env = it(), a(Ce, {\n  all: function () {\n    var e = B.apply(null, arguments).map(tt);\n    return new Ce(function (t, n) {\n      0 === e.length && t([]);\n      var r = e.length;\n      e.forEach((s, i) => Ce.resolve(s).then(n => {\n        e[i] = n, --r || t(e);\n      }, n));\n    });\n  },\n  resolve: e => {\n    if (e instanceof Ce) return e;\n    if (e && \"function\" == typeof e.then) return new Ce((t, n) => {\n      e.then(t, n);\n    });\n    var t = new Ce(le, !0, e);\n    return Ne(t, ke), t;\n  },\n  reject: Ve,\n  race: function () {\n    var e = B.apply(null, arguments).map(tt);\n    return new Ce((t, n) => {\n      e.map(e => Ce.resolve(e).then(t, n));\n    });\n  },\n  PSD: {\n    get: () => Ke,\n    set: e => Ke = e\n  },\n  totalEchoes: {\n    get: () => Qe\n  },\n  newPSD: Je,\n  usePSD: ot,\n  scheduler: {\n    get: () => ge,\n    set: e => {\n      ge = e;\n    }\n  },\n  rejectionMapper: {\n    get: () => Ee,\n    set: e => {\n      Ee = e;\n    }\n  },\n  follow: (e, t) => new Ce((n, r) => Je((t, n) => {\n    var r = Ke;\n    r.unhandleds = [], r.onunhandled = n, r.finalize = re(function () {\n      !function (e) {\n        function t() {\n          e(), Ae.splice(Ae.indexOf(t), 1);\n        }\n\n        Ae.push(t), ++Se, ge(() => {\n          0 == --Se && Le();\n        }, []);\n      }(() => {\n        0 === this.unhandleds.length ? t() : n(this.unhandleds[0]);\n      });\n    }, r.finalize), e();\n  }, t, n, r))\n}), pe && (pe.allSettled && l(Ce, \"allSettled\", function () {\n  const e = B.apply(null, arguments).map(tt);\n  return new Ce(t => {\n    0 === e.length && t([]);\n    let n = e.length;\n    const r = new Array(n);\n    e.forEach((e, s) => Ce.resolve(e).then(e => r[s] = {\n      status: \"fulfilled\",\n      value: e\n    }, e => r[s] = {\n      status: \"rejected\",\n      reason: e\n    }).then(() => --n || t(r)));\n  });\n}), pe.any && \"undefined\" != typeof AggregateError && l(Ce, \"any\", function () {\n  const e = B.apply(null, arguments).map(tt);\n  return new Ce((t, n) => {\n    0 === e.length && n(new AggregateError([]));\n    let r = e.length;\n    const s = new Array(r);\n    e.forEach((e, i) => Ce.resolve(e).then(e => t(e), e => {\n      s[i] = e, --r || n(new AggregateError(s));\n    }));\n  });\n}));\nconst Ye = {\n  awaits: 0,\n  echoes: 0,\n  id: 0\n};\nvar ze = 0,\n    Ge = [],\n    He = 0,\n    Qe = 0,\n    Xe = 0;\n\nfunction Je(e, t, n, s) {\n  var i = Ke,\n      o = Object.create(i);\n  o.parent = i, o.ref = 0, o.global = !1, o.id = ++Xe;\n  var a = Pe.env;\n  o.env = ye ? {\n    Promise: Ce,\n    PromiseProp: {\n      value: Ce,\n      configurable: !0,\n      writable: !0\n    },\n    all: Ce.all,\n    race: Ce.race,\n    allSettled: Ce.allSettled,\n    any: Ce.any,\n    resolve: Ce.resolve,\n    reject: Ce.reject,\n    nthen: lt(a.nthen, o),\n    gthen: lt(a.gthen, o)\n  } : {}, t && r(o, t), ++i.ref, o.finalize = function () {\n    --this.parent.ref || this.parent.finalize();\n  };\n  var u = ot(o, e, n, s);\n  return 0 === o.ref && o.finalize(), u;\n}\n\nfunction Ze() {\n  return Ye.id || (Ye.id = ++ze), ++Ye.awaits, Ye.echoes += 100, Ye.id;\n}\n\nfunction et() {\n  return !!Ye.awaits && (0 == --Ye.awaits && (Ye.id = 0), Ye.echoes = 100 * Ye.awaits, !0);\n}\n\nfunction tt(e) {\n  return Ye.echoes && e && e.constructor === pe ? (Ze(), e.then(e => (et(), e), e => (et(), ht(e)))) : e;\n}\n\nfunction nt(e) {\n  ++Qe, Ye.echoes && 0 != --Ye.echoes || (Ye.echoes = Ye.id = 0), Ge.push(Ke), st(e, !0);\n}\n\nfunction rt() {\n  var e = Ge[Ge.length - 1];\n  Ge.pop(), st(e, !1);\n}\n\nfunction st(t, n) {\n  var r = Ke;\n\n  if ((n ? !Ye.echoes || He++ && t === Ke : !He || --He && t === Ke) || at(n ? nt.bind(null, t) : rt), t !== Ke && (Ke = t, r === Pe && (Pe.env = it()), ye)) {\n    var s = Pe.env.Promise,\n        i = t.env;\n    he.then = i.nthen, s.prototype.then = i.gthen, (r.global || t.global) && (Object.defineProperty(e, \"Promise\", i.PromiseProp), s.all = i.all, s.race = i.race, s.resolve = i.resolve, s.reject = i.reject, i.allSettled && (s.allSettled = i.allSettled), i.any && (s.any = i.any));\n  }\n}\n\nfunction it() {\n  var t = e.Promise;\n  return ye ? {\n    Promise: t,\n    PromiseProp: Object.getOwnPropertyDescriptor(e, \"Promise\"),\n    all: t.all,\n    race: t.race,\n    allSettled: t.allSettled,\n    any: t.any,\n    resolve: t.resolve,\n    reject: t.reject,\n    nthen: he.then,\n    gthen: t.prototype.then\n  } : {};\n}\n\nfunction ot(e, t, n, r, s) {\n  var i = Ke;\n\n  try {\n    return st(e, !0), t(n, r, s);\n  } finally {\n    st(i, !1);\n  }\n}\n\nfunction at(e) {\n  fe.call(ce, e);\n}\n\nfunction ut(e, t, n, r) {\n  return \"function\" != typeof e ? e : function () {\n    var s = Ke;\n    n && Ze(), st(t, !0);\n\n    try {\n      return e.apply(this, arguments);\n    } finally {\n      st(s, !1), r && at(et);\n    }\n  };\n}\n\nfunction lt(e, t) {\n  return function (n, r) {\n    return e.call(this, ut(n, t), ut(r, t));\n  };\n}\n\n-1 === (\"\" + fe).indexOf(\"[native code]\") && (Ze = et = ee);\n\nfunction ct(t, n) {\n  var s;\n\n  try {\n    s = n.onuncatched(t);\n  } catch (e) {}\n\n  if (!1 !== s) try {\n    var i,\n        o = {\n      promise: n,\n      reason: t\n    };\n    if (e.document && document.createEvent ? ((i = document.createEvent(\"Event\")).initEvent(\"unhandledrejection\", !0, !0), r(i, o)) : e.CustomEvent && r(i = new CustomEvent(\"unhandledrejection\", {\n      detail: o\n    }), o), i && e.dispatchEvent && (dispatchEvent(i), !e.PromiseRejectionEvent && e.onunhandledrejection)) try {\n      e.onunhandledrejection(i);\n    } catch (e) {}\n    R && i && !i.defaultPrevented && console.warn(`Unhandled rejection: ${t.stack || t}`);\n  } catch (e) {}\n}\n\nvar ht = Ce.reject;\n\nfunction dt(e, t, n, r) {\n  if (e.idbdb && (e._state.openComplete || Ke.letThrough || e._vip)) {\n    var s = e._createTransaction(t, n, e._dbSchema);\n\n    try {\n      s.create(), e._state.PR1398_maxLoop = 3;\n    } catch (s) {\n      return s.name === H.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn(\"Dexie: Need to reopen db\"), e._close(), e.open().then(() => dt(e, t, n, r))) : ht(s);\n    }\n\n    return s._promise(t, (e, t) => Je(() => (Ke.trans = s, r(e, t, s)))).then(e => s._completion.then(() => e));\n  }\n\n  if (e._state.openComplete) return ht(new X.DatabaseClosed(e._state.dbOpenError));\n\n  if (!e._state.isBeingOpened) {\n    if (!e._options.autoOpen) return ht(new X.DatabaseClosed());\n    e.open().catch(ee);\n  }\n\n  return e._state.dbReadyPromise.then(() => dt(e, t, n, r));\n}\n\nconst ft = String.fromCharCode(65535),\n      pt = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\",\n      yt = [],\n      mt = \"undefined\" != typeof navigator && /(MSIE|Trident|Edge)/.test(navigator.userAgent),\n      vt = mt,\n      gt = mt,\n      bt = e => !/(dexie\\.js|dexie\\.min\\.js)/.test(e);\n\nfunction _t(e, t) {\n  return e ? t ? function () {\n    return e.apply(this, arguments) && t.apply(this, arguments);\n  } : e : t;\n}\n\nconst wt = {\n  type: 3,\n  lower: -1 / 0,\n  lowerOpen: !1,\n  upper: [[]],\n  upperOpen: !1\n};\n\nfunction xt(e) {\n  return \"string\" != typeof e || /\\./.test(e) ? e => e : t => (void 0 === t[e] && e in t && delete (t = O(t))[e], t);\n}\n\nclass kt {\n  _trans(e, t, n) {\n    const r = this._tx || Ke.trans,\n          s = this.name;\n\n    function i(e, n, r) {\n      if (!r.schema[s]) throw new X.NotFound(\"Table \" + s + \" not part of transaction\");\n      return t(r.idbtrans, r);\n    }\n\n    const o = $e();\n\n    try {\n      return r && r.db === this.db ? r === Ke.trans ? r._promise(e, i, n) : Je(() => r._promise(e, i, n), {\n        trans: r,\n        transless: Ke.transless || Ke\n      }) : dt(this.db, e, [this.name], i);\n    } finally {\n      o && Ue();\n    }\n  }\n\n  get(e, t) {\n    return e && e.constructor === Object ? this.where(e).first(t) : this._trans(\"readonly\", t => this.core.get({\n      trans: t,\n      key: e\n    }).then(e => this.hook.reading.fire(e))).then(t);\n  }\n\n  where(e) {\n    if (\"string\" == typeof e) return new this.db.WhereClause(this, e);\n    if (n(e)) return new this.db.WhereClause(this, `[${e.join(\"+\")}]`);\n    const r = t(e);\n    if (1 === r.length) return this.where(r[0]).equals(e[r[0]]);\n    const s = this.schema.indexes.concat(this.schema.primKey).filter(e => e.compound && r.every(t => e.keyPath.indexOf(t) >= 0) && e.keyPath.every(e => r.indexOf(e) >= 0))[0];\n    if (s && this.db._maxKey !== ft) return this.where(s.name).equals(s.keyPath.map(t => e[t]));\n    !s && R && console.warn(`The query ${JSON.stringify(e)} on ${this.name} would benefit of a compound index [${r.join(\"+\")}]`);\n    const {\n      idxByName: i\n    } = this.schema,\n          o = this.db._deps.indexedDB;\n\n    function a(e, t) {\n      try {\n        return 0 === o.cmp(e, t);\n      } catch (e) {\n        return !1;\n      }\n    }\n\n    const [u, l] = r.reduce(([t, r], s) => {\n      const o = i[s],\n            u = e[s];\n      return [t || o, t || !o ? _t(r, o && o.multi ? e => {\n        const t = b(e, s);\n        return n(t) && t.some(e => a(u, e));\n      } : e => a(u, b(e, s))) : r];\n    }, [null, null]);\n    return u ? this.where(u.name).equals(e[u.keyPath]).filter(l) : s ? this.filter(l) : this.where(r).equals(\"\");\n  }\n\n  filter(e) {\n    return this.toCollection().and(e);\n  }\n\n  count(e) {\n    return this.toCollection().count(e);\n  }\n\n  offset(e) {\n    return this.toCollection().offset(e);\n  }\n\n  limit(e) {\n    return this.toCollection().limit(e);\n  }\n\n  each(e) {\n    return this.toCollection().each(e);\n  }\n\n  toArray(e) {\n    return this.toCollection().toArray(e);\n  }\n\n  toCollection() {\n    return new this.db.Collection(new this.db.WhereClause(this));\n  }\n\n  orderBy(e) {\n    return new this.db.Collection(new this.db.WhereClause(this, n(e) ? `[${e.join(\"+\")}]` : e));\n  }\n\n  reverse() {\n    return this.toCollection().reverse();\n  }\n\n  mapToClass(e) {\n    this.schema.mappedClass = e;\n\n    const t = t => {\n      if (!t) return t;\n      const n = Object.create(e.prototype);\n\n      for (var r in t) if (o(t, r)) try {\n        n[r] = t[r];\n      } catch (e) {}\n\n      return n;\n    };\n\n    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = t, this.hook(\"reading\", t), e;\n  }\n\n  defineClass() {\n    return this.mapToClass(function (e) {\n      r(this, e);\n    });\n  }\n\n  add(e, t) {\n    const {\n      auto: n,\n      keyPath: r\n    } = this.schema.primKey;\n    let s = e;\n    return r && n && (s = xt(r)(e)), this._trans(\"readwrite\", e => this.core.mutate({\n      trans: e,\n      type: \"add\",\n      keys: null != t ? [t] : null,\n      values: [s]\n    })).then(e => e.numFailures ? Ce.reject(e.failures[0]) : e.lastResult).then(t => {\n      if (r) try {\n        _(e, r, t);\n      } catch (e) {}\n      return t;\n    });\n  }\n\n  update(e, r) {\n    if (\"object\" != typeof e || n(e)) return this.where(\":id\").equals(e).modify(r);\n    {\n      const n = b(e, this.schema.primKey.keyPath);\n      if (void 0 === n) return ht(new X.InvalidArgument(\"Given object does not contain its primary key\"));\n\n      try {\n        \"function\" != typeof r ? t(r).forEach(t => {\n          _(e, t, r[t]);\n        }) : r(e, {\n          value: e,\n          primKey: n\n        });\n      } catch (e) {}\n\n      return this.where(\":id\").equals(n).modify(r);\n    }\n  }\n\n  put(e, t) {\n    const {\n      auto: n,\n      keyPath: r\n    } = this.schema.primKey;\n    let s = e;\n    return r && n && (s = xt(r)(e)), this._trans(\"readwrite\", e => this.core.mutate({\n      trans: e,\n      type: \"put\",\n      values: [s],\n      keys: null != t ? [t] : null\n    })).then(e => e.numFailures ? Ce.reject(e.failures[0]) : e.lastResult).then(t => {\n      if (r) try {\n        _(e, r, t);\n      } catch (e) {}\n      return t;\n    });\n  }\n\n  delete(e) {\n    return this._trans(\"readwrite\", t => this.core.mutate({\n      trans: t,\n      type: \"delete\",\n      keys: [e]\n    })).then(e => e.numFailures ? Ce.reject(e.failures[0]) : void 0);\n  }\n\n  clear() {\n    return this._trans(\"readwrite\", e => this.core.mutate({\n      trans: e,\n      type: \"deleteRange\",\n      range: wt\n    })).then(e => e.numFailures ? Ce.reject(e.failures[0]) : void 0);\n  }\n\n  bulkGet(e) {\n    return this._trans(\"readonly\", t => this.core.getMany({\n      keys: e,\n      trans: t\n    }).then(e => e.map(e => this.hook.reading.fire(e))));\n  }\n\n  bulkAdd(e, t, n) {\n    const r = Array.isArray(t) ? t : void 0,\n          s = (n = n || (r ? void 0 : t)) ? n.allKeys : void 0;\n    return this._trans(\"readwrite\", t => {\n      const {\n        auto: n,\n        keyPath: i\n      } = this.schema.primKey;\n      if (i && r) throw new X.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n      if (r && r.length !== e.length) throw new X.InvalidArgument(\"Arguments objects and keys must have the same length\");\n      const o = e.length;\n      let a = i && n ? e.map(xt(i)) : e;\n      return this.core.mutate({\n        trans: t,\n        type: \"add\",\n        keys: r,\n        values: a,\n        wantResults: s\n      }).then(({\n        numFailures: e,\n        results: t,\n        lastResult: n,\n        failures: r\n      }) => {\n        if (0 === e) return s ? t : n;\n        throw new G(`${this.name}.bulkAdd(): ${e} of ${o} operations failed`, r);\n      });\n    });\n  }\n\n  bulkPut(e, t, n) {\n    const r = Array.isArray(t) ? t : void 0,\n          s = (n = n || (r ? void 0 : t)) ? n.allKeys : void 0;\n    return this._trans(\"readwrite\", t => {\n      const {\n        auto: n,\n        keyPath: i\n      } = this.schema.primKey;\n      if (i && r) throw new X.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n      if (r && r.length !== e.length) throw new X.InvalidArgument(\"Arguments objects and keys must have the same length\");\n      const o = e.length;\n      let a = i && n ? e.map(xt(i)) : e;\n      return this.core.mutate({\n        trans: t,\n        type: \"put\",\n        keys: r,\n        values: a,\n        wantResults: s\n      }).then(({\n        numFailures: e,\n        results: t,\n        lastResult: n,\n        failures: r\n      }) => {\n        if (0 === e) return s ? t : n;\n        throw new G(`${this.name}.bulkPut(): ${e} of ${o} operations failed`, r);\n      });\n    });\n  }\n\n  bulkDelete(e) {\n    const t = e.length;\n    return this._trans(\"readwrite\", t => this.core.mutate({\n      trans: t,\n      type: \"delete\",\n      keys: e\n    })).then(({\n      numFailures: e,\n      lastResult: n,\n      failures: r\n    }) => {\n      if (0 === e) return n;\n      throw new G(`${this.name}.bulkDelete(): ${e} of ${t} operations failed`, r);\n    });\n  }\n\n}\n\nfunction Et(e) {\n  var r = {},\n      s = function (t, n) {\n    if (n) {\n      for (var s = arguments.length, i = new Array(s - 1); --s;) i[s - 1] = arguments[s];\n\n      return r[t].subscribe.apply(null, i), e;\n    }\n\n    if (\"string\" == typeof t) return r[t];\n  };\n\n  s.addEventType = a;\n\n  for (var i = 1, o = arguments.length; i < o; ++i) a(arguments[i]);\n\n  return s;\n\n  function a(e, t, n) {\n    if (\"object\" == typeof e) return u(e);\n    t || (t = ae), n || (n = ee);\n    var i = {\n      subscribers: [],\n      fire: n,\n      subscribe: function (e) {\n        -1 === i.subscribers.indexOf(e) && (i.subscribers.push(e), i.fire = t(i.fire, e));\n      },\n      unsubscribe: function (e) {\n        i.subscribers = i.subscribers.filter(function (t) {\n          return t !== e;\n        }), i.fire = i.subscribers.reduce(t, n);\n      }\n    };\n    return r[e] = s[e] = i, i;\n  }\n\n  function u(e) {\n    t(e).forEach(function (t) {\n      var r = e[t];\n      if (n(r)) a(t, e[t][0], e[t][1]);else {\n        if (\"asap\" !== r) throw new X.InvalidArgument(\"Invalid event config\");\n        var s = a(t, te, function () {\n          for (var e = arguments.length, t = new Array(e); e--;) t[e] = arguments[e];\n\n          s.subscribers.forEach(function (e) {\n            v(function () {\n              e.apply(null, t);\n            });\n          });\n        });\n      }\n    });\n  }\n}\n\nfunction Pt(e, t) {\n  return c(t).from({\n    prototype: e\n  }), t;\n}\n\nfunction Kt(e, t) {\n  return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter);\n}\n\nfunction Ot(e, t) {\n  e.filter = _t(e.filter, t);\n}\n\nfunction St(e, t, n) {\n  var r = e.replayFilter;\n  e.replayFilter = r ? () => _t(r(), t()) : t, e.justLimit = n && !r;\n}\n\nfunction At(e, t) {\n  if (e.isPrimKey) return t.primaryKey;\n  const n = t.getIndexByKeyPath(e.index);\n  if (!n) throw new X.Schema(\"KeyPath \" + e.index + \" on object store \" + t.name + \" is not indexed\");\n  return n;\n}\n\nfunction Ct(e, t, n) {\n  const r = At(e, t.schema);\n  return t.openCursor({\n    trans: n,\n    values: !e.keysOnly,\n    reverse: \"prev\" === e.dir,\n    unique: !!e.unique,\n    query: {\n      index: r,\n      range: e.range\n    }\n  });\n}\n\nfunction jt(e, t, n, r) {\n  const s = e.replayFilter ? _t(e.filter, e.replayFilter()) : e.filter;\n\n  if (e.or) {\n    const i = {},\n          a = (e, n, r) => {\n      if (!s || s(n, r, e => n.stop(e), e => n.fail(e))) {\n        var a = n.primaryKey,\n            u = \"\" + a;\n        \"[object ArrayBuffer]\" === u && (u = \"\" + new Uint8Array(a)), o(i, u) || (i[u] = !0, t(e, n, r));\n      }\n    };\n\n    return Promise.all([e.or._iterate(a, n), Dt(Ct(e, r, n), e.algorithm, a, !e.keysOnly && e.valueMapper)]);\n  }\n\n  return Dt(Ct(e, r, n), _t(e.algorithm, s), t, !e.keysOnly && e.valueMapper);\n}\n\nfunction Dt(e, t, n, r) {\n  var s = We(r ? (e, t, s) => n(r(e), t, s) : n);\n  return e.then(e => {\n    if (e) return e.start(() => {\n      var n = () => e.continue();\n\n      t && !t(e, e => n = e, t => {\n        e.stop(t), n = ee;\n      }, t => {\n        e.fail(t), n = ee;\n      }) || s(e.value, e, e => n = e), n();\n    });\n  });\n}\n\nfunction It(e, t) {\n  try {\n    const n = Bt(e),\n          r = Bt(t);\n    if (n !== r) return \"Array\" === n ? 1 : \"Array\" === r ? -1 : \"binary\" === n ? 1 : \"binary\" === r ? -1 : \"string\" === n ? 1 : \"string\" === r ? -1 : \"Date\" === n ? 1 : \"Date\" !== r ? NaN : -1;\n\n    switch (n) {\n      case \"number\":\n      case \"Date\":\n      case \"string\":\n        return e > t ? 1 : e < t ? -1 : 0;\n\n      case \"binary\":\n        return function (e, t) {\n          const n = e.length,\n                r = t.length,\n                s = n < r ? n : r;\n\n          for (let n = 0; n < s; ++n) if (e[n] !== t[n]) return e[n] < t[n] ? -1 : 1;\n\n          return n === r ? 0 : n < r ? -1 : 1;\n        }(Tt(e), Tt(t));\n\n      case \"Array\":\n        return function (e, t) {\n          const n = e.length,\n                r = t.length,\n                s = n < r ? n : r;\n\n          for (let n = 0; n < s; ++n) {\n            const r = It(e[n], t[n]);\n            if (0 !== r) return r;\n          }\n\n          return n === r ? 0 : n < r ? -1 : 1;\n        }(e, t);\n    }\n  } catch (e) {}\n\n  return NaN;\n}\n\nfunction Bt(e) {\n  const t = typeof e;\n  if (\"object\" !== t) return t;\n  if (ArrayBuffer.isView(e)) return \"binary\";\n  const n = C(e);\n  return \"ArrayBuffer\" === n ? \"binary\" : n;\n}\n\nfunction Tt(e) {\n  return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);\n}\n\nclass Rt {\n  _read(e, t) {\n    var n = this._ctx;\n    return n.error ? n.table._trans(null, ht.bind(null, n.error)) : n.table._trans(\"readonly\", e).then(t);\n  }\n\n  _write(e) {\n    var t = this._ctx;\n    return t.error ? t.table._trans(null, ht.bind(null, t.error)) : t.table._trans(\"readwrite\", e, \"locked\");\n  }\n\n  _addAlgorithm(e) {\n    var t = this._ctx;\n    t.algorithm = _t(t.algorithm, e);\n  }\n\n  _iterate(e, t) {\n    return jt(this._ctx, e, t, this._ctx.table.core);\n  }\n\n  clone(e) {\n    var t = Object.create(this.constructor.prototype),\n        n = Object.create(this._ctx);\n    return e && r(n, e), t._ctx = n, t;\n  }\n\n  raw() {\n    return this._ctx.valueMapper = null, this;\n  }\n\n  each(e) {\n    var t = this._ctx;\n    return this._read(n => jt(t, e, n, t.table.core));\n  }\n\n  count(e) {\n    return this._read(e => {\n      const t = this._ctx,\n            n = t.table.core;\n      if (Kt(t, !0)) return n.count({\n        trans: e,\n        query: {\n          index: At(t, n.schema),\n          range: t.range\n        }\n      }).then(e => Math.min(e, t.limit));\n      var r = 0;\n      return jt(t, () => (++r, !1), e, n).then(() => r);\n    }).then(e);\n  }\n\n  sortBy(e, t) {\n    const n = e.split(\".\").reverse(),\n          r = n[0],\n          s = n.length - 1;\n\n    function i(e, t) {\n      return t ? i(e[n[t]], t - 1) : e[r];\n    }\n\n    var o = \"next\" === this._ctx.dir ? 1 : -1;\n\n    function a(e, t) {\n      var n = i(e, s),\n          r = i(t, s);\n      return n < r ? -o : n > r ? o : 0;\n    }\n\n    return this.toArray(function (e) {\n      return e.sort(a);\n    }).then(t);\n  }\n\n  toArray(e) {\n    return this._read(e => {\n      var t = this._ctx;\n\n      if (\"next\" === t.dir && Kt(t, !0) && t.limit > 0) {\n        const {\n          valueMapper: n\n        } = t,\n              r = At(t, t.table.core.schema);\n        return t.table.core.query({\n          trans: e,\n          limit: t.limit,\n          values: !0,\n          query: {\n            index: r,\n            range: t.range\n          }\n        }).then(({\n          result: e\n        }) => n ? e.map(n) : e);\n      }\n\n      {\n        const n = [];\n        return jt(t, e => n.push(e), e, t.table.core).then(() => n);\n      }\n    }, e);\n  }\n\n  offset(e) {\n    var t = this._ctx;\n    return e <= 0 || (t.offset += e, Kt(t) ? St(t, () => {\n      var t = e;\n      return (e, n) => 0 === t || (1 === t ? (--t, !1) : (n(() => {\n        e.advance(t), t = 0;\n      }), !1));\n    }) : St(t, () => {\n      var t = e;\n      return () => --t < 0;\n    })), this;\n  }\n\n  limit(e) {\n    return this._ctx.limit = Math.min(this._ctx.limit, e), St(this._ctx, () => {\n      var t = e;\n      return function (e, n, r) {\n        return --t <= 0 && n(r), t >= 0;\n      };\n    }, !0), this;\n  }\n\n  until(e, t) {\n    return Ot(this._ctx, function (n, r, s) {\n      return !e(n.value) || (r(s), t);\n    }), this;\n  }\n\n  first(e) {\n    return this.limit(1).toArray(function (e) {\n      return e[0];\n    }).then(e);\n  }\n\n  last(e) {\n    return this.reverse().first(e);\n  }\n\n  filter(e) {\n    var t, n;\n    return Ot(this._ctx, function (t) {\n      return e(t.value);\n    }), t = this._ctx, n = e, t.isMatch = _t(t.isMatch, n), this;\n  }\n\n  and(e) {\n    return this.filter(e);\n  }\n\n  or(e) {\n    return new this.db.WhereClause(this._ctx.table, e, this);\n  }\n\n  reverse() {\n    return this._ctx.dir = \"prev\" === this._ctx.dir ? \"next\" : \"prev\", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;\n  }\n\n  desc() {\n    return this.reverse();\n  }\n\n  eachKey(e) {\n    var t = this._ctx;\n    return t.keysOnly = !t.isMatch, this.each(function (t, n) {\n      e(n.key, n);\n    });\n  }\n\n  eachUniqueKey(e) {\n    return this._ctx.unique = \"unique\", this.eachKey(e);\n  }\n\n  eachPrimaryKey(e) {\n    var t = this._ctx;\n    return t.keysOnly = !t.isMatch, this.each(function (t, n) {\n      e(n.primaryKey, n);\n    });\n  }\n\n  keys(e) {\n    var t = this._ctx;\n    t.keysOnly = !t.isMatch;\n    var n = [];\n    return this.each(function (e, t) {\n      n.push(t.key);\n    }).then(function () {\n      return n;\n    }).then(e);\n  }\n\n  primaryKeys(e) {\n    var t = this._ctx;\n    if (\"next\" === t.dir && Kt(t, !0) && t.limit > 0) return this._read(e => {\n      var n = At(t, t.table.core.schema);\n      return t.table.core.query({\n        trans: e,\n        values: !1,\n        limit: t.limit,\n        query: {\n          index: n,\n          range: t.range\n        }\n      });\n    }).then(({\n      result: e\n    }) => e).then(e);\n    t.keysOnly = !t.isMatch;\n    var n = [];\n    return this.each(function (e, t) {\n      n.push(t.primaryKey);\n    }).then(function () {\n      return n;\n    }).then(e);\n  }\n\n  uniqueKeys(e) {\n    return this._ctx.unique = \"unique\", this.keys(e);\n  }\n\n  firstKey(e) {\n    return this.limit(1).keys(function (e) {\n      return e[0];\n    }).then(e);\n  }\n\n  lastKey(e) {\n    return this.reverse().firstKey(e);\n  }\n\n  distinct() {\n    var e = this._ctx,\n        t = e.index && e.table.schema.idxByName[e.index];\n    if (!t || !t.multi) return this;\n    var n = {};\n    return Ot(this._ctx, function (e) {\n      var t = e.primaryKey.toString(),\n          r = o(n, t);\n      return n[t] = !0, !r;\n    }), this;\n  }\n\n  modify(e) {\n    var n = this._ctx;\n    return this._write(r => {\n      var s;\n      if (\"function\" == typeof e) s = e;else {\n        var i = t(e),\n            o = i.length;\n\n        s = function (t) {\n          for (var n = !1, r = 0; r < o; ++r) {\n            var s = i[r],\n                a = e[s];\n            b(t, s) !== a && (_(t, s, a), n = !0);\n          }\n\n          return n;\n        };\n      }\n      const a = n.table.core,\n            {\n        outbound: u,\n        extractKey: l\n      } = a.schema.primaryKey,\n            c = this.db._options.modifyChunkSize || 200,\n            h = [];\n      let d = 0;\n\n      const f = [],\n            p = (e, n) => {\n        const {\n          failures: r,\n          numFailures: s\n        } = n;\n        d += e - s;\n\n        for (let e of t(r)) h.push(r[e]);\n      };\n\n      return this.clone().primaryKeys().then(t => {\n        const i = o => {\n          const h = Math.min(c, t.length - o);\n          return a.getMany({\n            trans: r,\n            keys: t.slice(o, o + h),\n            cache: \"immutable\"\n          }).then(d => {\n            const f = [],\n                  y = [],\n                  m = u ? [] : null,\n                  v = [];\n\n            for (let e = 0; e < h; ++e) {\n              const n = d[e],\n                    r = {\n                value: O(n),\n                primKey: t[o + e]\n              };\n              !1 !== s.call(r, r.value, r) && (null == r.value ? v.push(t[o + e]) : u || 0 === It(l(n), l(r.value)) ? (y.push(r.value), u && m.push(t[o + e])) : (v.push(t[o + e]), f.push(r.value)));\n            }\n\n            const g = Kt(n) && n.limit === 1 / 0 && (\"function\" != typeof e || e === Ft) && {\n              index: n.index,\n              range: n.range\n            };\n            return Promise.resolve(f.length > 0 && a.mutate({\n              trans: r,\n              type: \"add\",\n              values: f\n            }).then(e => {\n              for (let t in e.failures) v.splice(parseInt(t), 1);\n\n              p(f.length, e);\n            })).then(() => (y.length > 0 || g && \"object\" == typeof e) && a.mutate({\n              trans: r,\n              type: \"put\",\n              keys: m,\n              values: y,\n              criteria: g,\n              changeSpec: \"function\" != typeof e && e\n            }).then(e => p(y.length, e))).then(() => (v.length > 0 || g && e === Ft) && a.mutate({\n              trans: r,\n              type: \"delete\",\n              keys: v,\n              criteria: g\n            }).then(e => p(v.length, e))).then(() => t.length > o + h && i(o + c));\n          });\n        };\n\n        return i(0).then(() => {\n          if (h.length > 0) throw new z(\"Error modifying one or more objects\", h, d, f);\n          return t.length;\n        });\n      });\n    });\n  }\n\n  delete() {\n    var e = this._ctx,\n        t = e.range;\n    return Kt(e) && (e.isPrimKey && !gt || 3 === t.type) ? this._write(n => {\n      const {\n        primaryKey: r\n      } = e.table.core.schema,\n            s = t;\n      return e.table.core.count({\n        trans: n,\n        query: {\n          index: r,\n          range: s\n        }\n      }).then(t => e.table.core.mutate({\n        trans: n,\n        type: \"deleteRange\",\n        range: s\n      }).then(({\n        failures: e,\n        lastResult: n,\n        results: r,\n        numFailures: s\n      }) => {\n        if (s) throw new z(\"Could not delete some values\", Object.keys(e).map(t => e[t]), t - s);\n        return t - s;\n      }));\n    }) : this.modify(Ft);\n  }\n\n}\n\nconst Ft = (e, t) => t.value = null;\n\nfunction Mt(e, t) {\n  return e < t ? -1 : e === t ? 0 : 1;\n}\n\nfunction Nt(e, t) {\n  return e > t ? -1 : e === t ? 0 : 1;\n}\n\nfunction qt(e, t, n) {\n  var r = e instanceof Yt ? new e.Collection(e) : e;\n  return r._ctx.error = n ? new n(t) : new TypeError(t), r;\n}\n\nfunction $t(e) {\n  return new e.Collection(e, () => Wt(\"\")).limit(0);\n}\n\nfunction Ut(e, t, n, r, s, i) {\n  for (var o = Math.min(e.length, r.length), a = -1, u = 0; u < o; ++u) {\n    var l = t[u];\n    if (l !== r[u]) return s(e[u], n[u]) < 0 ? e.substr(0, u) + n[u] + n.substr(u + 1) : s(e[u], r[u]) < 0 ? e.substr(0, u) + r[u] + n.substr(u + 1) : a >= 0 ? e.substr(0, a) + t[a] + n.substr(a + 1) : null;\n    s(e[u], l) < 0 && (a = u);\n  }\n\n  return o < r.length && \"next\" === i ? e + n.substr(e.length) : o < e.length && \"prev\" === i ? e.substr(0, n.length) : a < 0 ? null : e.substr(0, a) + r[a] + n.substr(a + 1);\n}\n\nfunction Lt(e, t, n, r) {\n  var s,\n      i,\n      o,\n      a,\n      u,\n      l,\n      c,\n      h = n.length;\n  if (!n.every(e => \"string\" == typeof e)) return qt(e, \"String expected.\");\n\n  function d(e) {\n    s = function (e) {\n      return \"next\" === e ? e => e.toUpperCase() : e => e.toLowerCase();\n    }(e), i = function (e) {\n      return \"next\" === e ? e => e.toLowerCase() : e => e.toUpperCase();\n    }(e), o = \"next\" === e ? Mt : Nt;\n    var t = n.map(function (e) {\n      return {\n        lower: i(e),\n        upper: s(e)\n      };\n    }).sort(function (e, t) {\n      return o(e.lower, t.lower);\n    });\n    a = t.map(function (e) {\n      return e.upper;\n    }), u = t.map(function (e) {\n      return e.lower;\n    }), l = e, c = \"next\" === e ? \"\" : r;\n  }\n\n  d(\"next\");\n  var f = new e.Collection(e, () => Vt(a[0], u[h - 1] + r));\n\n  f._ondirectionchange = function (e) {\n    d(e);\n  };\n\n  var p = 0;\n  return f._addAlgorithm(function (e, n, r) {\n    var s = e.key;\n    if (\"string\" != typeof s) return !1;\n    var d = i(s);\n    if (t(d, u, p)) return !0;\n\n    for (var f = null, y = p; y < h; ++y) {\n      var m = Ut(s, d, a[y], u[y], o, l);\n      null === m && null === f ? p = y + 1 : (null === f || o(f, m) > 0) && (f = m);\n    }\n\n    return n(null !== f ? function () {\n      e.continue(f + c);\n    } : r), !1;\n  }), f;\n}\n\nfunction Vt(e, t, n, r) {\n  return {\n    type: 2,\n    lower: e,\n    upper: t,\n    lowerOpen: n,\n    upperOpen: r\n  };\n}\n\nfunction Wt(e) {\n  return {\n    type: 1,\n    lower: e,\n    upper: e\n  };\n}\n\nclass Yt {\n  get Collection() {\n    return this._ctx.table.db.Collection;\n  }\n\n  between(e, t, n, r) {\n    n = !1 !== n, r = !0 === r;\n\n    try {\n      return this._cmp(e, t) > 0 || 0 === this._cmp(e, t) && (n || r) && (!n || !r) ? $t(this) : new this.Collection(this, () => Vt(e, t, !n, !r));\n    } catch (e) {\n      return qt(this, pt);\n    }\n  }\n\n  equals(e) {\n    return null == e ? qt(this, pt) : new this.Collection(this, () => Wt(e));\n  }\n\n  above(e) {\n    return null == e ? qt(this, pt) : new this.Collection(this, () => Vt(e, void 0, !0));\n  }\n\n  aboveOrEqual(e) {\n    return null == e ? qt(this, pt) : new this.Collection(this, () => Vt(e, void 0, !1));\n  }\n\n  below(e) {\n    return null == e ? qt(this, pt) : new this.Collection(this, () => Vt(void 0, e, !1, !0));\n  }\n\n  belowOrEqual(e) {\n    return null == e ? qt(this, pt) : new this.Collection(this, () => Vt(void 0, e));\n  }\n\n  startsWith(e) {\n    return \"string\" != typeof e ? qt(this, \"String expected.\") : this.between(e, e + ft, !0, !0);\n  }\n\n  startsWithIgnoreCase(e) {\n    return \"\" === e ? this.startsWith(e) : Lt(this, (e, t) => 0 === e.indexOf(t[0]), [e], ft);\n  }\n\n  equalsIgnoreCase(e) {\n    return Lt(this, (e, t) => e === t[0], [e], \"\");\n  }\n\n  anyOfIgnoreCase() {\n    var e = B.apply(I, arguments);\n    return 0 === e.length ? $t(this) : Lt(this, (e, t) => -1 !== t.indexOf(e), e, \"\");\n  }\n\n  startsWithAnyOfIgnoreCase() {\n    var e = B.apply(I, arguments);\n    return 0 === e.length ? $t(this) : Lt(this, (e, t) => t.some(t => 0 === e.indexOf(t)), e, ft);\n  }\n\n  anyOf() {\n    const e = B.apply(I, arguments);\n    let t = this._cmp;\n\n    try {\n      e.sort(t);\n    } catch (e) {\n      return qt(this, pt);\n    }\n\n    if (0 === e.length) return $t(this);\n    const n = new this.Collection(this, () => Vt(e[0], e[e.length - 1]));\n\n    n._ondirectionchange = n => {\n      t = \"next\" === n ? this._ascending : this._descending, e.sort(t);\n    };\n\n    let r = 0;\n    return n._addAlgorithm((n, s, i) => {\n      const o = n.key;\n\n      for (; t(o, e[r]) > 0;) if (++r, r === e.length) return s(i), !1;\n\n      return 0 === t(o, e[r]) || (s(() => {\n        n.continue(e[r]);\n      }), !1);\n    }), n;\n  }\n\n  notEqual(e) {\n    return this.inAnyRange([[-(1 / 0), e], [e, this.db._maxKey]], {\n      includeLowers: !1,\n      includeUppers: !1\n    });\n  }\n\n  noneOf() {\n    const e = B.apply(I, arguments);\n    if (0 === e.length) return new this.Collection(this);\n\n    try {\n      e.sort(this._ascending);\n    } catch (e) {\n      return qt(this, pt);\n    }\n\n    const t = e.reduce((e, t) => e ? e.concat([[e[e.length - 1][1], t]]) : [[-(1 / 0), t]], null);\n    return t.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(t, {\n      includeLowers: !1,\n      includeUppers: !1\n    });\n  }\n\n  inAnyRange(e, t) {\n    const n = this._cmp,\n          r = this._ascending,\n          s = this._descending,\n          i = this._min,\n          o = this._max;\n    if (0 === e.length) return $t(this);\n    if (!e.every(e => void 0 !== e[0] && void 0 !== e[1] && r(e[0], e[1]) <= 0)) return qt(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", X.InvalidArgument);\n    const a = !t || !1 !== t.includeLowers,\n          u = t && !0 === t.includeUppers;\n    let l,\n        c = r;\n\n    function h(e, t) {\n      return c(e[0], t[0]);\n    }\n\n    try {\n      l = e.reduce(function (e, t) {\n        let r = 0,\n            s = e.length;\n\n        for (; r < s; ++r) {\n          const s = e[r];\n\n          if (n(t[0], s[1]) < 0 && n(t[1], s[0]) > 0) {\n            s[0] = i(s[0], t[0]), s[1] = o(s[1], t[1]);\n            break;\n          }\n        }\n\n        return r === s && e.push(t), e;\n      }, []), l.sort(h);\n    } catch (e) {\n      return qt(this, pt);\n    }\n\n    let d = 0;\n    const f = u ? e => r(e, l[d][1]) > 0 : e => r(e, l[d][1]) >= 0,\n          p = a ? e => s(e, l[d][0]) > 0 : e => s(e, l[d][0]) >= 0;\n    let y = f;\n    const m = new this.Collection(this, () => Vt(l[0][0], l[l.length - 1][1], !a, !u));\n    return m._ondirectionchange = e => {\n      \"next\" === e ? (y = f, c = r) : (y = p, c = s), l.sort(h);\n    }, m._addAlgorithm((e, t, n) => {\n      for (var s = e.key; y(s);) if (++d, d === l.length) return t(n), !1;\n\n      return !!function (e) {\n        return !f(e) && !p(e);\n      }(s) || (0 === this._cmp(s, l[d][1]) || 0 === this._cmp(s, l[d][0]) || t(() => {\n        c === r ? e.continue(l[d][0]) : e.continue(l[d][1]);\n      }), !1);\n    }), m;\n  }\n\n  startsWithAnyOf() {\n    const e = B.apply(I, arguments);\n    return e.every(e => \"string\" == typeof e) ? 0 === e.length ? $t(this) : this.inAnyRange(e.map(e => [e, e + ft])) : qt(this, \"startsWithAnyOf() only works with strings\");\n  }\n\n}\n\nfunction zt(e) {\n  return We(function (t) {\n    return Gt(t), e(t.target.error), !1;\n  });\n}\n\nfunction Gt(e) {\n  e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();\n}\n\nconst Ht = Et(null, \"storagemutated\");\n\nclass Qt {\n  _lock() {\n    return m(!Ke.global), ++this._reculock, 1 !== this._reculock || Ke.global || (Ke.lockOwnerFor = this), this;\n  }\n\n  _unlock() {\n    if (m(!Ke.global), 0 == --this._reculock) for (Ke.global || (Ke.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) {\n      var e = this._blockedFuncs.shift();\n\n      try {\n        ot(e[1], e[0]);\n      } catch (e) {}\n    }\n    return this;\n  }\n\n  _locked() {\n    return this._reculock && Ke.lockOwnerFor !== this;\n  }\n\n  create(e) {\n    if (!this.mode) return this;\n    const t = this.db.idbdb,\n          n = this.db._state.dbOpenError;\n    if (m(!this.idbtrans), !e && !t) switch (n && n.name) {\n      case \"DatabaseClosedError\":\n        throw new X.DatabaseClosed(n);\n\n      case \"MissingAPIError\":\n        throw new X.MissingAPI(n.message, n);\n\n      default:\n        throw new X.OpenFailed(n);\n    }\n    if (!this.active) throw new X.TransactionInactive();\n    return m(null === this._completion._state), (e = this.idbtrans = e || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {\n      durability: this.chromeTransactionDurability\n    }) : t.transaction(this.storeNames, this.mode, {\n      durability: this.chromeTransactionDurability\n    }))).onerror = We(t => {\n      Gt(t), this._reject(e.error);\n    }), e.onabort = We(t => {\n      Gt(t), this.active && this._reject(new X.Abort(e.error)), this.active = !1, this.on(\"abort\").fire(t);\n    }), e.oncomplete = We(() => {\n      this.active = !1, this._resolve(), \"mutatedParts\" in e && Ht.storagemutated.fire(e.mutatedParts);\n    }), this;\n  }\n\n  _promise(e, t, n) {\n    if (\"readwrite\" === e && \"readwrite\" !== this.mode) return ht(new X.ReadOnly(\"Transaction is readonly\"));\n    if (!this.active) return ht(new X.TransactionInactive());\n    if (this._locked()) return new Ce((r, s) => {\n      this._blockedFuncs.push([() => {\n        this._promise(e, t, n).then(r, s);\n      }, Ke]);\n    });\n    if (n) return Je(() => {\n      var e = new Ce((e, n) => {\n        this._lock();\n\n        const r = t(e, n, this);\n        r && r.then && r.then(e, n);\n      });\n      return e.finally(() => this._unlock()), e._lib = !0, e;\n    });\n    var r = new Ce((e, n) => {\n      var r = t(e, n, this);\n      r && r.then && r.then(e, n);\n    });\n    return r._lib = !0, r;\n  }\n\n  _root() {\n    return this.parent ? this.parent._root() : this;\n  }\n\n  waitFor(e) {\n    var t = this._root();\n\n    const n = Ce.resolve(e);\n    if (t._waitingFor) t._waitingFor = t._waitingFor.then(() => n);else {\n      t._waitingFor = n, t._waitingQueue = [];\n      var r = t.idbtrans.objectStore(t.storeNames[0]);\n      !function e() {\n        for (++t._spinCount; t._waitingQueue.length;) t._waitingQueue.shift()();\n\n        t._waitingFor && (r.get(-1 / 0).onsuccess = e);\n      }();\n    }\n    var s = t._waitingFor;\n    return new Ce((e, r) => {\n      n.then(n => t._waitingQueue.push(We(e.bind(null, n))), e => t._waitingQueue.push(We(r.bind(null, e)))).finally(() => {\n        t._waitingFor === s && (t._waitingFor = null);\n      });\n    });\n  }\n\n  abort() {\n    this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new X.Abort()));\n  }\n\n  table(e) {\n    const t = this._memoizedTables || (this._memoizedTables = {});\n    if (o(t, e)) return t[e];\n    const n = this.schema[e];\n    if (!n) throw new X.NotFound(\"Table \" + e + \" not part of transaction\");\n    const r = new this.db.Table(e, n, this);\n    return r.core = this.db.core.table(e), t[e] = r, r;\n  }\n\n}\n\nfunction Xt(e, t, n, r, s, i, o) {\n  return {\n    name: e,\n    keyPath: t,\n    unique: n,\n    multi: r,\n    auto: s,\n    compound: i,\n    src: (n && !o ? \"&\" : \"\") + (r ? \"*\" : \"\") + (s ? \"++\" : \"\") + Jt(t)\n  };\n}\n\nfunction Jt(e) {\n  return \"string\" == typeof e ? e : e ? \"[\" + [].join.call(e, \"+\") + \"]\" : \"\";\n}\n\nfunction Zt(e, t, n) {\n  return {\n    name: e,\n    primKey: t,\n    indexes: n,\n    mappedClass: null,\n    idxByName: g(n, e => [e.name, e])\n  };\n}\n\nlet en = e => {\n  try {\n    return e.only([[]]), en = () => [[]], [[]];\n  } catch (e) {\n    return en = () => ft, ft;\n  }\n};\n\nfunction tn(e) {\n  return null == e ? () => {} : \"string\" == typeof e ? function (e) {\n    return 1 === e.split(\".\").length ? t => t[e] : t => b(t, e);\n  }(e) : t => b(t, e);\n}\n\nfunction nn(e) {\n  return [].slice.call(e);\n}\n\nlet rn = 0;\n\nfunction sn(e) {\n  return null == e ? \":id\" : \"string\" == typeof e ? e : `[${e.join(\"+\")}]`;\n}\n\nfunction on(e, t, r) {\n  function s(e) {\n    if (3 === e.type) return null;\n    if (4 === e.type) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n    const {\n      lower: n,\n      upper: r,\n      lowerOpen: s,\n      upperOpen: i\n    } = e;\n    return void 0 === n ? void 0 === r ? null : t.upperBound(r, !!i) : void 0 === r ? t.lowerBound(n, !!s) : t.bound(n, r, !!s, !!i);\n  }\n\n  const {\n    schema: i,\n    hasGetAll: o\n  } = function (e, t) {\n    const r = nn(e.objectStoreNames);\n    return {\n      schema: {\n        name: e.name,\n        tables: r.map(e => t.objectStore(e)).map(e => {\n          const {\n            keyPath: t,\n            autoIncrement: r\n          } = e,\n                s = n(t),\n                i = null == t,\n                o = {},\n                a = {\n            name: e.name,\n            primaryKey: {\n              name: null,\n              isPrimaryKey: !0,\n              outbound: i,\n              compound: s,\n              keyPath: t,\n              autoIncrement: r,\n              unique: !0,\n              extractKey: tn(t)\n            },\n            indexes: nn(e.indexNames).map(t => e.index(t)).map(e => {\n              const {\n                name: t,\n                unique: r,\n                multiEntry: s,\n                keyPath: i\n              } = e,\n                    a = {\n                name: t,\n                compound: n(i),\n                keyPath: i,\n                unique: r,\n                multiEntry: s,\n                extractKey: tn(i)\n              };\n              return o[sn(i)] = a, a;\n            }),\n            getIndexByKeyPath: e => o[sn(e)]\n          };\n          return o[\":id\"] = a.primaryKey, null != t && (o[sn(t)] = a.primaryKey), a;\n        })\n      },\n      hasGetAll: r.length > 0 && \"getAll\" in t.objectStore(r[0]) && !(\"undefined\" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n    };\n  }(e, r),\n        a = i.tables.map(e => function (e) {\n    const t = e.name;\n    return {\n      name: t,\n      schema: e,\n      mutate: function ({\n        trans: e,\n        type: n,\n        keys: r,\n        values: i,\n        range: o\n      }) {\n        return new Promise((a, u) => {\n          a = We(a);\n          const l = e.objectStore(t),\n                c = null == l.keyPath,\n                h = \"put\" === n || \"add\" === n;\n          if (!h && \"delete\" !== n && \"deleteRange\" !== n) throw new Error(\"Invalid operation type: \" + n);\n          const {\n            length: d\n          } = r || i || {\n            length: 1\n          };\n          if (r && i && r.length !== i.length) throw new Error(\"Given keys array must have same length as given values array.\");\n          if (0 === d) return a({\n            numFailures: 0,\n            failures: {},\n            results: [],\n            lastResult: void 0\n          });\n          let f;\n          const p = [],\n                y = [];\n          let m = 0;\n\n          const v = e => {\n            ++m, Gt(e);\n          };\n\n          if (\"deleteRange\" === n) {\n            if (4 === o.type) return a({\n              numFailures: m,\n              failures: y,\n              results: [],\n              lastResult: void 0\n            });\n            3 === o.type ? p.push(f = l.clear()) : p.push(f = l.delete(s(o)));\n          } else {\n            const [e, t] = h ? c ? [i, r] : [i, null] : [r, null];\n            if (h) for (let r = 0; r < d; ++r) p.push(f = t && void 0 !== t[r] ? l[n](e[r], t[r]) : l[n](e[r])), f.onerror = v;else for (let t = 0; t < d; ++t) p.push(f = l[n](e[t])), f.onerror = v;\n          }\n\n          const g = e => {\n            const t = e.target.result;\n            p.forEach((e, t) => null != e.error && (y[t] = e.error)), a({\n              numFailures: m,\n              failures: y,\n              results: \"delete\" === n ? r : p.map(e => e.result),\n              lastResult: t\n            });\n          };\n\n          f.onerror = e => {\n            v(e), g(e);\n          }, f.onsuccess = g;\n        });\n      },\n      getMany: ({\n        trans: e,\n        keys: n\n      }) => new Promise((r, s) => {\n        r = We(r);\n        const i = e.objectStore(t),\n              o = n.length,\n              a = new Array(o);\n        let u,\n            l = 0,\n            c = 0;\n\n        const h = e => {\n          const t = e.target;\n          a[t._pos] = t.result, ++c === l && r(a);\n        },\n              d = zt(s);\n\n        for (let e = 0; e < o; ++e) null != n[e] && (u = i.get(n[e]), u._pos = e, u.onsuccess = h, u.onerror = d, ++l);\n\n        0 === l && r(a);\n      }),\n      get: ({\n        trans: e,\n        key: n\n      }) => new Promise((r, s) => {\n        r = We(r);\n        const i = e.objectStore(t).get(n);\n        i.onsuccess = e => r(e.target.result), i.onerror = zt(s);\n      }),\n      query: function (e) {\n        return n => new Promise((r, i) => {\n          r = We(r);\n          const {\n            trans: o,\n            values: a,\n            limit: u,\n            query: l\n          } = n,\n                c = u === 1 / 0 ? void 0 : u,\n                {\n            index: h,\n            range: d\n          } = l,\n                f = o.objectStore(t),\n                p = h.isPrimaryKey ? f : f.index(h.name),\n                y = s(d);\n          if (0 === u) return r({\n            result: []\n          });\n\n          if (e) {\n            const e = a ? p.getAll(y, c) : p.getAllKeys(y, c);\n            e.onsuccess = e => r({\n              result: e.target.result\n            }), e.onerror = zt(i);\n          } else {\n            let e = 0;\n            const t = a || !(\"openKeyCursor\" in p) ? p.openCursor(y) : p.openKeyCursor(y),\n                  n = [];\n            t.onsuccess = s => {\n              const i = t.result;\n              return i ? (n.push(a ? i.value : i.primaryKey), ++e === u ? r({\n                result: n\n              }) : void i.continue()) : r({\n                result: n\n              });\n            }, t.onerror = zt(i);\n          }\n        });\n      }(o),\n      openCursor: function ({\n        trans: e,\n        values: n,\n        query: r,\n        reverse: i,\n        unique: o\n      }) {\n        return new Promise((a, u) => {\n          a = We(a);\n          const {\n            index: l,\n            range: c\n          } = r,\n                h = e.objectStore(t),\n                d = l.isPrimaryKey ? h : h.index(l.name),\n                f = i ? o ? \"prevunique\" : \"prev\" : o ? \"nextunique\" : \"next\",\n                p = n || !(\"openKeyCursor\" in d) ? d.openCursor(s(c), f) : d.openKeyCursor(s(c), f);\n          p.onerror = zt(u), p.onsuccess = We(t => {\n            const n = p.result;\n            if (!n) return void a(null);\n            n.___id = ++rn, n.done = !1;\n            const r = n.continue.bind(n);\n            let s = n.continuePrimaryKey;\n            s && (s = s.bind(n));\n\n            const i = n.advance.bind(n),\n                  o = () => {\n              throw new Error(\"Cursor not stopped\");\n            };\n\n            n.trans = e, n.stop = n.continue = n.continuePrimaryKey = n.advance = () => {\n              throw new Error(\"Cursor not started\");\n            }, n.fail = We(u), n.next = function () {\n              let e = 1;\n              return this.start(() => e-- ? this.continue() : this.stop()).then(() => this);\n            }, n.start = e => {\n              const t = new Promise((e, t) => {\n                e = We(e), p.onerror = zt(t), n.fail = t, n.stop = t => {\n                  n.stop = n.continue = n.continuePrimaryKey = n.advance = o, e(t);\n                };\n              }),\n                    a = () => {\n                if (p.result) try {\n                  e();\n                } catch (e) {\n                  n.fail(e);\n                } else n.done = !0, n.start = () => {\n                  throw new Error(\"Cursor behind last entry\");\n                }, n.stop();\n              };\n\n              return p.onsuccess = We(e => {\n                p.onsuccess = a, a();\n              }), n.continue = r, n.continuePrimaryKey = s, n.advance = i, a(), t;\n            }, a(n);\n          }, u);\n        });\n      },\n\n      count({\n        query: e,\n        trans: n\n      }) {\n        const {\n          index: r,\n          range: i\n        } = e;\n        return new Promise((e, o) => {\n          const a = n.objectStore(t),\n                u = r.isPrimaryKey ? a : a.index(r.name),\n                l = s(i),\n                c = l ? u.count(l) : u.count();\n          c.onsuccess = We(t => e(t.target.result)), c.onerror = zt(o);\n        });\n      }\n\n    };\n  }(e)),\n        u = {};\n\n  return a.forEach(e => u[e.name] = e), {\n    stack: \"dbcore\",\n    transaction: e.transaction.bind(e),\n\n    table(e) {\n      if (!u[e]) throw new Error(`Table '${e}' not found`);\n      return u[e];\n    },\n\n    MIN_KEY: -1 / 0,\n    MAX_KEY: en(t),\n    schema: i\n  };\n}\n\nfunction an({\n  _novip: e\n}, t) {\n  const n = t.db,\n        r = function (e, t, {\n    IDBKeyRange: n,\n    indexedDB: r\n  }, s) {\n    const i = function (e, t) {\n      return t.reduce((e, {\n        create: t\n      }) => ({ ...e,\n        ...t(e)\n      }), e);\n    }(on(t, n, s), e.dbcore);\n\n    return {\n      dbcore: i\n    };\n  }(e._middlewares, n, e._deps, t);\n\n  e.core = r.dbcore, e.tables.forEach(t => {\n    const n = t.name;\n    e.core.schema.tables.some(e => e.name === n) && (t.core = e.core.table(n), e[n] instanceof e.Table && (e[n].core = t.core));\n  });\n}\n\nfunction un({\n  _novip: e\n}, t, n, r) {\n  n.forEach(n => {\n    const s = r[n];\n    t.forEach(t => {\n      const r = d(t, n);\n      (!r || \"value\" in r && void 0 === r.value) && (t === e.Transaction.prototype || t instanceof e.Transaction ? l(t, n, {\n        get() {\n          return this.table(n);\n        },\n\n        set(e) {\n          u(this, n, {\n            value: e,\n            writable: !0,\n            configurable: !0,\n            enumerable: !0\n          });\n        }\n\n      }) : t[n] = new e.Table(n, s));\n    });\n  });\n}\n\nfunction ln({\n  _novip: e\n}, t) {\n  t.forEach(t => {\n    for (let n in t) t[n] instanceof e.Table && delete t[n];\n  });\n}\n\nfunction cn(e, t) {\n  return e._cfg.version - t._cfg.version;\n}\n\nfunction hn(e, n, r, s) {\n  const i = e._dbSchema,\n        o = e._createTransaction(\"readwrite\", e._storeNames, i);\n\n  o.create(r), o._completion.catch(s);\n\n  const a = o._reject.bind(o),\n        u = Ke.transless || Ke;\n\n  Je(() => {\n    Ke.trans = o, Ke.transless = u, 0 === n ? (t(i).forEach(e => {\n      fn(r, e, i[e].primKey, i[e].indexes);\n    }), an(e, r), Ce.follow(() => e.on.populate.fire(o)).catch(a)) : function ({\n      _novip: e\n    }, n, r, s) {\n      const i = [],\n            o = e._versions;\n      let a = e._dbSchema = yn(e, e.idbdb, s),\n          u = !1;\n\n      function l() {\n        return i.length ? Ce.resolve(i.shift()(r.idbtrans)).then(l) : Ce.resolve();\n      }\n\n      return o.filter(e => e._cfg.version >= n).forEach(o => {\n        i.push(() => {\n          const i = a,\n                l = o._cfg.dbschema;\n          mn(e, i, s), mn(e, l, s), a = e._dbSchema = l;\n          const c = dn(i, l);\n          c.add.forEach(e => {\n            fn(s, e[0], e[1].primKey, e[1].indexes);\n          }), c.change.forEach(e => {\n            if (e.recreate) throw new X.Upgrade(\"Not yet support for changing primary key\");\n            {\n              const t = s.objectStore(e.name);\n              e.add.forEach(e => pn(t, e)), e.change.forEach(e => {\n                t.deleteIndex(e.name), pn(t, e);\n              }), e.del.forEach(e => t.deleteIndex(e));\n            }\n          });\n          const h = o._cfg.contentUpgrade;\n\n          if (h && o._cfg.version > n) {\n            an(e, s), r._memoizedTables = {}, u = !0;\n            let n = w(l);\n            c.del.forEach(e => {\n              n[e] = i[e];\n            }), ln(e, [e.Transaction.prototype]), un(e, [e.Transaction.prototype], t(n), n), r.schema = n;\n            const o = T(h);\n            let a;\n            o && Ze();\n            const d = Ce.follow(() => {\n              if (a = h(r), a && o) {\n                var e = et.bind(null, null);\n                a.then(e, e);\n              }\n            });\n            return a && \"function\" == typeof a.then ? Ce.resolve(a) : d.then(() => a);\n          }\n        }), i.push(t => {\n          if (!u || !vt) {\n            !function (e, t) {\n              [].slice.call(t.db.objectStoreNames).forEach(n => null == e[n] && t.db.deleteObjectStore(n));\n            }(o._cfg.dbschema, t);\n          }\n\n          ln(e, [e.Transaction.prototype]), un(e, [e.Transaction.prototype], e._storeNames, e._dbSchema), r.schema = e._dbSchema;\n        });\n      }), l().then(() => {\n        var e, n;\n        n = s, t(e = a).forEach(t => {\n          n.db.objectStoreNames.contains(t) || fn(n, t, e[t].primKey, e[t].indexes);\n        });\n      });\n    }(e, n, o, r).catch(a);\n  });\n}\n\nfunction dn(e, t) {\n  const n = {\n    del: [],\n    add: [],\n    change: []\n  };\n  let r;\n\n  for (r in e) t[r] || n.del.push(r);\n\n  for (r in t) {\n    const s = e[r],\n          i = t[r];\n\n    if (s) {\n      const e = {\n        name: r,\n        def: i,\n        recreate: !1,\n        del: [],\n        add: [],\n        change: []\n      };\n      if (\"\" + (s.primKey.keyPath || \"\") != \"\" + (i.primKey.keyPath || \"\") || s.primKey.auto !== i.primKey.auto && !mt) e.recreate = !0, n.change.push(e);else {\n        const t = s.idxByName,\n              r = i.idxByName;\n        let o;\n\n        for (o in t) r[o] || e.del.push(o);\n\n        for (o in r) {\n          const n = t[o],\n                s = r[o];\n          n ? n.src !== s.src && e.change.push(s) : e.add.push(s);\n        }\n\n        (e.del.length > 0 || e.add.length > 0 || e.change.length > 0) && n.change.push(e);\n      }\n    } else n.add.push([r, i]);\n  }\n\n  return n;\n}\n\nfunction fn(e, t, n, r) {\n  const s = e.db.createObjectStore(t, n.keyPath ? {\n    keyPath: n.keyPath,\n    autoIncrement: n.auto\n  } : {\n    autoIncrement: n.auto\n  });\n  return r.forEach(e => pn(s, e)), s;\n}\n\nfunction pn(e, t) {\n  e.createIndex(t.name, t.keyPath, {\n    unique: t.unique,\n    multiEntry: t.multi\n  });\n}\n\nfunction yn(e, t, n) {\n  const r = {};\n  return p(t.objectStoreNames, 0).forEach(e => {\n    const t = n.objectStore(e);\n    let s = t.keyPath;\n    const i = Xt(Jt(s), s || \"\", !1, !1, !!t.autoIncrement, s && \"string\" != typeof s, !0),\n          o = [];\n\n    for (let e = 0; e < t.indexNames.length; ++e) {\n      const n = t.index(t.indexNames[e]);\n      s = n.keyPath;\n      var a = Xt(n.name, s, !!n.unique, !!n.multiEntry, !1, s && \"string\" != typeof s, !1);\n      o.push(a);\n    }\n\n    r[e] = Zt(e, i, o);\n  }), r;\n}\n\nfunction mn({\n  _novip: t\n}, n, r) {\n  const s = r.db.objectStoreNames;\n\n  for (let e = 0; e < s.length; ++e) {\n    const i = s[e],\n          o = r.objectStore(i);\n    t._hasGetAll = \"getAll\" in o;\n\n    for (let e = 0; e < o.indexNames.length; ++e) {\n      const t = o.indexNames[e],\n            r = o.index(t).keyPath,\n            s = \"string\" == typeof r ? r : \"[\" + p(r).join(\"+\") + \"]\";\n\n      if (n[i]) {\n        const e = n[i].idxByName[s];\n        e && (e.name = t, delete n[i].idxByName[s], n[i].idxByName[t] = e);\n      }\n    }\n  }\n\n  \"undefined\" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && e.WorkerGlobalScope && e instanceof e.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604 && (t._hasGetAll = !1);\n}\n\nclass vn {\n  _parseStoresSpec(e, r) {\n    t(e).forEach(t => {\n      if (null !== e[t]) {\n        var s = e[t].split(\",\").map((e, t) => {\n          const r = (e = e.trim()).replace(/([&*]|\\+\\+)/g, \"\"),\n                s = /^\\[/.test(r) ? r.match(/^\\[(.*)\\]$/)[1].split(\"+\") : r;\n          return Xt(r, s || null, /\\&/.test(e), /\\*/.test(e), /\\+\\+/.test(e), n(s), 0 === t);\n        }),\n            i = s.shift();\n        if (i.multi) throw new X.Schema(\"Primary key cannot be multi-valued\");\n        s.forEach(e => {\n          if (e.auto) throw new X.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n          if (!e.keyPath) throw new X.Schema(\"Index must have a name and cannot be an empty string\");\n        }), r[t] = Zt(t, i, s);\n      }\n    });\n  }\n\n  stores(e) {\n    const n = this.db;\n    this._cfg.storesSource = this._cfg.storesSource ? r(this._cfg.storesSource, e) : e;\n    const s = n._versions,\n          i = {};\n    let o = {};\n    return s.forEach(e => {\n      r(i, e._cfg.storesSource), o = e._cfg.dbschema = {}, e._parseStoresSpec(i, o);\n    }), n._dbSchema = o, ln(n, [n._allTables, n, n.Transaction.prototype]), un(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], t(o), o), n._storeNames = t(o), this;\n  }\n\n  upgrade(e) {\n    return this._cfg.contentUpgrade = ue(this._cfg.contentUpgrade || ee, e), this;\n  }\n\n}\n\nfunction gn(e, t) {\n  let n = e._dbNamesDB;\n  return n || (n = e._dbNamesDB = new $n(\"__dbnames\", {\n    addons: [],\n    indexedDB: e,\n    IDBKeyRange: t\n  }), n.version(1).stores({\n    dbnames: \"name\"\n  })), n.table(\"dbnames\");\n}\n\nfunction bn(e) {\n  return e && \"function\" == typeof e.databases;\n}\n\nfunction _n(e) {\n  return Je(function () {\n    return Ke.letThrough = !0, e();\n  });\n}\n\nfunction wn() {\n  var e;\n  return !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function (t) {\n    var n = function () {\n      return indexedDB.databases().finally(t);\n    };\n\n    e = setInterval(n, 100), n();\n  }).finally(function () {\n    return clearInterval(e);\n  }) : Promise.resolve();\n}\n\nfunction xn(e) {\n  const n = e._state,\n        {\n    indexedDB: r\n  } = e._deps;\n  if (n.isBeingOpened || e.idbdb) return n.dbReadyPromise.then(() => n.dbOpenError ? ht(n.dbOpenError) : e);\n  R && (n.openCanceller._stackHolder = q()), n.isBeingOpened = !0, n.dbOpenError = null, n.openComplete = !1;\n  const s = n.openCanceller;\n\n  function i() {\n    if (n.openCanceller !== s) throw new X.DatabaseClosed(\"db.open() was cancelled\");\n  }\n\n  let o = n.dbReadyResolve,\n      a = null,\n      u = !1;\n  return Ce.race([s, (\"undefined\" == typeof navigator ? Ce.resolve() : wn()).then(() => new Ce((s, o) => {\n    if (i(), !r) throw new X.MissingAPI();\n    const l = e.name,\n          c = n.autoSchema ? r.open(l) : r.open(l, Math.round(10 * e.verno));\n    if (!c) throw new X.MissingAPI();\n    c.onerror = zt(o), c.onblocked = We(e._fireOnBlocked), c.onupgradeneeded = We(t => {\n      if (a = c.transaction, n.autoSchema && !e._options.allowEmptyDB) {\n        c.onerror = Gt, a.abort(), c.result.close();\n        const e = r.deleteDatabase(l);\n        e.onsuccess = e.onerror = We(() => {\n          o(new X.NoSuchDatabase(`Database ${l} doesnt exist`));\n        });\n      } else {\n        a.onerror = zt(o);\n        var s = t.oldVersion > Math.pow(2, 62) ? 0 : t.oldVersion;\n        u = s < 1, e._novip.idbdb = c.result, hn(e, s / 10, a, o);\n      }\n    }, o), c.onsuccess = We(() => {\n      a = null;\n      const r = e._novip.idbdb = c.result,\n            i = p(r.objectStoreNames);\n      if (i.length > 0) try {\n        const s = r.transaction(1 === (o = i).length ? o[0] : o, \"readonly\");\n        n.autoSchema ? function ({\n          _novip: e\n        }, n, r) {\n          e.verno = n.version / 10;\n          const s = e._dbSchema = yn(0, n, r);\n          e._storeNames = p(n.objectStoreNames, 0), un(e, [e._allTables], t(s), s);\n        }(e, r, s) : (mn(e, e._dbSchema, s), function (e, t) {\n          const n = dn(yn(0, e.idbdb, t), e._dbSchema);\n          return !(n.add.length || n.change.some(e => e.add.length || e.change.length));\n        }(e, s) || console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.\")), an(e, s);\n      } catch (e) {}\n      var o;\n      yt.push(e), r.onversionchange = We(t => {\n        n.vcFired = !0, e.on(\"versionchange\").fire(t);\n      }), r.onclose = We(t => {\n        e.on(\"close\").fire(t);\n      }), u && function ({\n        indexedDB: e,\n        IDBKeyRange: t\n      }, n) {\n        !bn(e) && \"__dbnames\" !== n && gn(e, t).put({\n          name: n\n        }).catch(ee);\n      }(e._deps, l), s();\n    }, o);\n  }))]).then(() => (i(), n.onReadyBeingFired = [], Ce.resolve(_n(() => e.on.ready.fire(e.vip))).then(function t() {\n    if (n.onReadyBeingFired.length > 0) {\n      let r = n.onReadyBeingFired.reduce(ue, ee);\n      return n.onReadyBeingFired = [], Ce.resolve(_n(() => r(e.vip))).then(t);\n    }\n  }))).finally(() => {\n    n.onReadyBeingFired = null, n.isBeingOpened = !1;\n  }).then(() => e).catch(t => {\n    n.dbOpenError = t;\n\n    try {\n      a && a.abort();\n    } catch (e) {}\n\n    return s === n.openCanceller && e._close(), ht(t);\n  }).finally(() => {\n    n.openComplete = !0, o();\n  });\n}\n\nfunction kn(e) {\n  var t = t => e.next(t),\n      r = i(t),\n      s = i(t => e.throw(t));\n\n  function i(e) {\n    return t => {\n      var i = e(t),\n          o = i.value;\n      return i.done ? o : o && \"function\" == typeof o.then ? o.then(r, s) : n(o) ? Promise.all(o).then(r, s) : r(o);\n    };\n  }\n\n  return i(t)();\n}\n\nfunction En(e, t, n) {\n  var r = arguments.length;\n  if (r < 2) throw new X.InvalidArgument(\"Too few arguments\");\n\n  for (var s = new Array(r - 1); --r;) s[r - 1] = arguments[r];\n\n  n = s.pop();\n  var i = k(s);\n  return [e, i, n];\n}\n\nfunction Pn(e, t, n, r, s) {\n  return Ce.resolve().then(() => {\n    const i = Ke.transless || Ke,\n          o = e._createTransaction(t, n, e._dbSchema, r),\n          a = {\n      trans: o,\n      transless: i\n    };\n\n    if (r) o.idbtrans = r.idbtrans;else try {\n      o.create(), e._state.PR1398_maxLoop = 3;\n    } catch (r) {\n      return r.name === H.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn(\"Dexie: Need to reopen db\"), e._close(), e.open().then(() => Pn(e, t, n, null, s))) : ht(r);\n    }\n    const u = T(s);\n    let l;\n    u && Ze();\n    const c = Ce.follow(() => {\n      if (l = s.call(o, o), l) if (u) {\n        var e = et.bind(null, null);\n        l.then(e, e);\n      } else \"function\" == typeof l.next && \"function\" == typeof l.throw && (l = kn(l));\n    }, a);\n    return (l && \"function\" == typeof l.then ? Ce.resolve(l).then(e => o.active ? e : ht(new X.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\"))) : c.then(() => l)).then(e => (r && o._resolve(), o._completion.then(() => e))).catch(e => (o._reject(e), ht(e)));\n  });\n}\n\nfunction Kn(e, t, r) {\n  const s = n(e) ? e.slice() : [e];\n\n  for (let e = 0; e < r; ++e) s.push(t);\n\n  return s;\n}\n\nconst On = {\n  stack: \"dbcore\",\n  name: \"VirtualIndexMiddleware\",\n  level: 1,\n  create: function (e) {\n    return { ...e,\n\n      table(t) {\n        const n = e.table(t),\n              {\n          schema: r\n        } = n,\n              s = {},\n              i = [];\n\n        function o(e, t, n) {\n          const r = sn(e),\n                a = s[r] = s[r] || [],\n                u = null == e ? 0 : \"string\" == typeof e ? 1 : e.length,\n                l = t > 0,\n                c = { ...n,\n            isVirtual: l,\n            keyTail: t,\n            keyLength: u,\n            extractKey: tn(e),\n            unique: !l && n.unique\n          };\n\n          if (a.push(c), c.isPrimaryKey || i.push(c), u > 1) {\n            o(2 === u ? e[0] : e.slice(0, u - 1), t + 1, n);\n          }\n\n          return a.sort((e, t) => e.keyTail - t.keyTail), c;\n        }\n\n        const a = o(r.primaryKey.keyPath, 0, r.primaryKey);\n        s[\":id\"] = [a];\n\n        for (const e of r.indexes) o(e.keyPath, 0, e);\n\n        function u(t) {\n          const n = t.query.index;\n          return n.isVirtual ? { ...t,\n            query: {\n              index: n,\n              range: (r = t.query.range, s = n.keyTail, {\n                type: 1 === r.type ? 2 : r.type,\n                lower: Kn(r.lower, r.lowerOpen ? e.MAX_KEY : e.MIN_KEY, s),\n                lowerOpen: !0,\n                upper: Kn(r.upper, r.upperOpen ? e.MIN_KEY : e.MAX_KEY, s),\n                upperOpen: !0\n              })\n            }\n          } : t;\n          var r, s;\n        }\n\n        const l = { ...n,\n          schema: { ...r,\n            primaryKey: a,\n            indexes: i,\n            getIndexByKeyPath: function (e) {\n              const t = s[sn(e)];\n              return t && t[0];\n            }\n          },\n          count: e => n.count(u(e)),\n          query: e => n.query(u(e)),\n\n          openCursor(t) {\n            const {\n              keyTail: r,\n              isVirtual: s,\n              keyLength: i\n            } = t.query.index;\n            if (!s) return n.openCursor(t);\n            return n.openCursor(u(t)).then(n => n && function (n) {\n              const s = Object.create(n, {\n                continue: {\n                  value: function (s) {\n                    null != s ? n.continue(Kn(s, t.reverse ? e.MAX_KEY : e.MIN_KEY, r)) : t.unique ? n.continue(n.key.slice(0, i).concat(t.reverse ? e.MIN_KEY : e.MAX_KEY, r)) : n.continue();\n                  }\n                },\n                continuePrimaryKey: {\n                  value(t, s) {\n                    n.continuePrimaryKey(Kn(t, e.MAX_KEY, r), s);\n                  }\n\n                },\n                primaryKey: {\n                  get: () => n.primaryKey\n                },\n                key: {\n                  get() {\n                    const e = n.key;\n                    return 1 === i ? e[0] : e.slice(0, i);\n                  }\n\n                },\n                value: {\n                  get: () => n.value\n                }\n              });\n              return s;\n            }(n));\n          }\n\n        };\n        return l;\n      }\n\n    };\n  }\n};\n\nfunction Sn(e, n, r, s) {\n  return r = r || {}, s = s || \"\", t(e).forEach(t => {\n    if (o(n, t)) {\n      var i = e[t],\n          a = n[t];\n\n      if (\"object\" == typeof i && \"object\" == typeof a && i && a) {\n        const e = C(i);\n        e !== C(a) ? r[s + t] = n[t] : \"Object\" === e ? Sn(i, a, r, s + t + \".\") : i !== a && (r[s + t] = n[t]);\n      } else i !== a && (r[s + t] = n[t]);\n    } else r[s + t] = void 0;\n  }), t(n).forEach(t => {\n    o(e, t) || (r[s + t] = n[t]);\n  }), r;\n}\n\nconst An = {\n  stack: \"dbcore\",\n  name: \"HooksMiddleware\",\n  level: 2,\n  create: e => ({ ...e,\n\n    table(t) {\n      const n = e.table(t),\n            {\n        primaryKey: r\n      } = n.schema,\n            s = { ...n,\n\n        mutate(e) {\n          const s = Ke.trans,\n                {\n            deleting: i,\n            creating: a,\n            updating: u\n          } = s.table(t).hook;\n\n          switch (e.type) {\n            case \"add\":\n              if (a.fire === ee) break;\n              return s._promise(\"readwrite\", () => l(e), !0);\n\n            case \"put\":\n              if (a.fire === ee && u.fire === ee) break;\n              return s._promise(\"readwrite\", () => l(e), !0);\n\n            case \"delete\":\n              if (i.fire === ee) break;\n              return s._promise(\"readwrite\", () => l(e), !0);\n\n            case \"deleteRange\":\n              if (i.fire === ee) break;\n              return s._promise(\"readwrite\", () => function (e) {\n                return c(e.trans, e.range, 1e4);\n              }(e), !0);\n          }\n\n          return n.mutate(e);\n\n          function l(e) {\n            const t = Ke.trans,\n                  s = e.keys || function (e, t) {\n              return \"delete\" === t.type ? t.keys : t.keys || t.values.map(e.extractKey);\n            }(r, e);\n\n            if (!s) throw new Error(\"Keys missing\");\n            return \"delete\" !== (e = \"add\" === e.type || \"put\" === e.type ? { ...e,\n              keys: s\n            } : { ...e\n            }).type && (e.values = [...e.values]), e.keys && (e.keys = [...e.keys]), function (e, t, n) {\n              return \"add\" === t.type ? Promise.resolve([]) : e.getMany({\n                trans: t.trans,\n                keys: n,\n                cache: \"immutable\"\n              });\n            }(n, e, s).then(l => {\n              const c = s.map((n, s) => {\n                const c = l[s],\n                      h = {\n                  onerror: null,\n                  onsuccess: null\n                };\n                if (\"delete\" === e.type) i.fire.call(h, n, c, t);else if (\"add\" === e.type || void 0 === c) {\n                  const i = a.fire.call(h, n, e.values[s], t);\n                  null == n && null != i && (n = i, e.keys[s] = n, r.outbound || _(e.values[s], r.keyPath, n));\n                } else {\n                  const r = Sn(c, e.values[s]),\n                        i = u.fire.call(h, r, n, c, t);\n\n                  if (i) {\n                    const t = e.values[s];\n                    Object.keys(i).forEach(e => {\n                      o(t, e) ? t[e] = i[e] : _(t, e, i[e]);\n                    });\n                  }\n                }\n                return h;\n              });\n              return n.mutate(e).then(({\n                failures: t,\n                results: n,\n                numFailures: r,\n                lastResult: i\n              }) => {\n                for (let r = 0; r < s.length; ++r) {\n                  const i = n ? n[r] : s[r],\n                        o = c[r];\n                  null == i ? o.onerror && o.onerror(t[r]) : o.onsuccess && o.onsuccess(\"put\" === e.type && l[r] ? e.values[r] : i);\n                }\n\n                return {\n                  failures: t,\n                  results: n,\n                  numFailures: r,\n                  lastResult: i\n                };\n              }).catch(e => (c.forEach(t => t.onerror && t.onerror(e)), Promise.reject(e)));\n            });\n          }\n\n          function c(e, t, s) {\n            return n.query({\n              trans: e,\n              values: !1,\n              query: {\n                index: r,\n                range: t\n              },\n              limit: s\n            }).then(({\n              result: n\n            }) => l({\n              type: \"delete\",\n              keys: n,\n              trans: e\n            }).then(r => r.numFailures > 0 ? Promise.reject(r.failures[0]) : n.length < s ? {\n              failures: [],\n              numFailures: 0,\n              lastResult: void 0\n            } : c(e, { ...t,\n              lower: n[n.length - 1],\n              lowerOpen: !0\n            }, s)));\n          }\n        }\n\n      };\n      return s;\n    }\n\n  })\n};\n\nfunction Cn(e, t, n) {\n  try {\n    if (!t) return null;\n    if (t.keys.length < e.length) return null;\n    const r = [];\n\n    for (let s = 0, i = 0; s < t.keys.length && i < e.length; ++s) 0 === It(t.keys[s], e[i]) && (r.push(n ? O(t.values[s]) : t.values[s]), ++i);\n\n    return r.length === e.length ? r : null;\n  } catch (e) {\n    return null;\n  }\n}\n\nconst jn = {\n  stack: \"dbcore\",\n  level: -1,\n  create: e => ({\n    table: t => {\n      const n = e.table(t);\n      return { ...n,\n        getMany: e => {\n          if (!e.cache) return n.getMany(e);\n          const t = Cn(e.keys, e.trans._cache, \"clone\" === e.cache);\n          return t ? Ce.resolve(t) : n.getMany(e).then(t => (e.trans._cache = {\n            keys: e.keys,\n            values: \"clone\" === e.cache ? O(t) : t\n          }, t));\n        },\n        mutate: e => (\"add\" !== e.type && (e.trans._cache = null), n.mutate(e))\n      };\n    }\n  })\n};\n\nfunction Dn(e) {\n  return !(\"from\" in e);\n}\n\nconst In = function (e, t) {\n  if (!this) {\n    const t = new In();\n    return e && \"d\" in e && r(t, e), t;\n  }\n\n  r(this, arguments.length ? {\n    d: 1,\n    from: e,\n    to: arguments.length > 1 ? t : e\n  } : {\n    d: 0\n  });\n};\n\nfunction Bn(e, t, n) {\n  const s = It(t, n);\n  if (isNaN(s)) return;\n  if (s > 0) throw RangeError();\n  if (Dn(e)) return r(e, {\n    from: t,\n    to: n,\n    d: 1\n  });\n  const i = e.l,\n        o = e.r;\n  if (It(n, e.from) < 0) return i ? Bn(i, t, n) : e.l = {\n    from: t,\n    to: n,\n    d: 1,\n    l: null,\n    r: null\n  }, Mn(e);\n  if (It(t, e.to) > 0) return o ? Bn(o, t, n) : e.r = {\n    from: t,\n    to: n,\n    d: 1,\n    l: null,\n    r: null\n  }, Mn(e);\n  It(t, e.from) < 0 && (e.from = t, e.l = null, e.d = o ? o.d + 1 : 1), It(n, e.to) > 0 && (e.to = n, e.r = null, e.d = e.l ? e.l.d + 1 : 1);\n  const a = !e.r;\n  i && !e.l && Tn(e, i), o && a && Tn(e, o);\n}\n\nfunction Tn(e, t) {\n  Dn(t) || function e(t, {\n    from: n,\n    to: r,\n    l: s,\n    r: i\n  }) {\n    Bn(t, n, r), s && e(t, s), i && e(t, i);\n  }(e, t);\n}\n\nfunction Rn(e, t) {\n  const n = Fn(t);\n  let r = n.next();\n  if (r.done) return !1;\n  let s = r.value;\n  const i = Fn(e);\n  let o = i.next(s.from),\n      a = o.value;\n\n  for (; !r.done && !o.done;) {\n    if (It(a.from, s.to) <= 0 && It(a.to, s.from) >= 0) return !0;\n    It(s.from, a.from) < 0 ? s = (r = n.next(a.from)).value : a = (o = i.next(s.from)).value;\n  }\n\n  return !1;\n}\n\nfunction Fn(e) {\n  let t = Dn(e) ? null : {\n    s: 0,\n    n: e\n  };\n  return {\n    next(e) {\n      const n = arguments.length > 0;\n\n      for (; t;) switch (t.s) {\n        case 0:\n          if (t.s = 1, n) for (; t.n.l && It(e, t.n.from) < 0;) t = {\n            up: t,\n            n: t.n.l,\n            s: 1\n          };else for (; t.n.l;) t = {\n            up: t,\n            n: t.n.l,\n            s: 1\n          };\n\n        case 1:\n          if (t.s = 2, !n || It(e, t.n.to) <= 0) return {\n            value: t.n,\n            done: !1\n          };\n\n        case 2:\n          if (t.n.r) {\n            t.s = 3, t = {\n              up: t,\n              n: t.n.r,\n              s: 0\n            };\n            continue;\n          }\n\n        case 3:\n          t = t.up;\n      }\n\n      return {\n        done: !0\n      };\n    }\n\n  };\n}\n\nfunction Mn(e) {\n  var t, n;\n  const r = ((null === (t = e.r) || void 0 === t ? void 0 : t.d) || 0) - ((null === (n = e.l) || void 0 === n ? void 0 : n.d) || 0),\n        s = r > 1 ? \"r\" : r < -1 ? \"l\" : \"\";\n\n  if (s) {\n    const t = \"r\" === s ? \"l\" : \"r\",\n          n = { ...e\n    },\n          r = e[s];\n    e.from = r.from, e.to = r.to, e[s] = r[s], n[s] = r[t], e[t] = n, n.d = Nn(n);\n  }\n\n  e.d = Nn(e);\n}\n\nfunction Nn({\n  r: e,\n  l: t\n}) {\n  return (e ? t ? Math.max(e.d, t.d) : e.d : t ? t.d : 0) + 1;\n}\n\na(In.prototype, {\n  add(e) {\n    return Tn(this, e), this;\n  },\n\n  addKey(e) {\n    return Bn(this, e, e), this;\n  },\n\n  addKeys(e) {\n    return e.forEach(e => Bn(this, e, e)), this;\n  },\n\n  [j]() {\n    return Fn(this);\n  }\n\n});\nconst qn = {\n  stack: \"dbcore\",\n  level: 0,\n  create: e => {\n    const r = e.schema.name,\n          s = new In(e.MIN_KEY, e.MAX_KEY);\n    return { ...e,\n      table: i => {\n        const o = e.table(i),\n              {\n          schema: a\n        } = o,\n              {\n          primaryKey: u\n        } = a,\n              {\n          extractKey: l,\n          outbound: c\n        } = u,\n              h = { ...o,\n          mutate: e => {\n            const t = e.trans,\n                  u = t.mutatedParts || (t.mutatedParts = {}),\n                  l = e => {\n              const t = `idb://${r}/${i}/${e}`;\n              return u[t] || (u[t] = new In());\n            },\n                  c = l(\"\"),\n                  h = l(\":dels\"),\n                  {\n              type: d\n            } = e;\n\n            let [f, p] = \"deleteRange\" === e.type ? [e.range] : \"delete\" === e.type ? [e.keys] : e.values.length < 50 ? [[], e.values] : [];\n            const y = e.trans._cache;\n            return o.mutate(e).then(e => {\n              if (n(f)) {\n                \"delete\" !== d && (f = e.results), c.addKeys(f);\n                const t = Cn(f, y);\n                t || \"add\" === d || h.addKeys(f), (t || p) && function (e, t, r, s) {\n                  function i(t) {\n                    const i = e(t.name || \"\");\n\n                    function o(e) {\n                      return null != e ? t.extractKey(e) : null;\n                    }\n\n                    const a = e => t.multiEntry && n(e) ? e.forEach(e => i.addKey(e)) : i.addKey(e);\n\n                    (r || s).forEach((e, t) => {\n                      const n = r && o(r[t]),\n                            i = s && o(s[t]);\n                      0 !== It(n, i) && (null != n && a(n), null != i && a(i));\n                    });\n                  }\n\n                  t.indexes.forEach(i);\n                }(l, a, t, p);\n              } else if (f) {\n                const e = {\n                  from: f.lower,\n                  to: f.upper\n                };\n                h.add(e), c.add(e);\n              } else c.add(s), h.add(s), a.indexes.forEach(e => l(e.name).add(s));\n\n              return e;\n            });\n          }\n        },\n              d = ({\n          query: {\n            index: t,\n            range: n\n          }\n        }) => {\n          var r, s;\n          return [t, new In(null !== (r = n.lower) && void 0 !== r ? r : e.MIN_KEY, null !== (s = n.upper) && void 0 !== s ? s : e.MAX_KEY)];\n        },\n              f = {\n          get: e => [u, new In(e.key)],\n          getMany: e => [u, new In().addKeys(e.keys)],\n          count: d,\n          query: d,\n          openCursor: d\n        };\n\n        return t(f).forEach(e => {\n          h[e] = function (t) {\n            const {\n              subscr: n\n            } = Ke;\n\n            if (n) {\n              const a = e => {\n                const t = `idb://${r}/${i}/${e}`;\n                return n[t] || (n[t] = new In());\n              },\n                    u = a(\"\"),\n                    h = a(\":dels\"),\n                    [d, p] = f[e](t);\n\n              if (a(d.name || \"\").add(p), !d.isPrimaryKey) {\n                if (\"count\" !== e) {\n                  const n = \"query\" === e && c && t.values && o.query({ ...t,\n                    values: !1\n                  });\n                  return o[e].apply(this, arguments).then(r => {\n                    if (\"query\" === e) {\n                      if (c && t.values) return n.then(({\n                        result: e\n                      }) => (u.addKeys(e), r));\n                      const e = t.values ? r.result.map(l) : r.result;\n                      t.values ? u.addKeys(e) : h.addKeys(e);\n                    } else if (\"openCursor\" === e) {\n                      const e = r,\n                            n = t.values;\n                      return e && Object.create(e, {\n                        key: {\n                          get: () => (h.addKey(e.primaryKey), e.key)\n                        },\n                        primaryKey: {\n                          get() {\n                            const t = e.primaryKey;\n                            return h.addKey(t), t;\n                          }\n\n                        },\n                        value: {\n                          get: () => (n && u.addKey(e.primaryKey), e.value)\n                        }\n                      });\n                    }\n\n                    return r;\n                  });\n                }\n\n                h.add(s);\n              }\n            }\n\n            return o[e].apply(this, arguments);\n          };\n        }), h;\n      }\n    };\n  }\n};\n\nclass $n {\n  constructor(e, t) {\n    this._middlewares = {}, this.verno = 0;\n    const n = $n.dependencies;\n    this._options = t = {\n      addons: $n.addons,\n      autoOpen: !0,\n      indexedDB: n.indexedDB,\n      IDBKeyRange: n.IDBKeyRange,\n      ...t\n    }, this._deps = {\n      indexedDB: t.indexedDB,\n      IDBKeyRange: t.IDBKeyRange\n    };\n    const {\n      addons: r\n    } = t;\n    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;\n    const s = {\n      dbOpenError: null,\n      isBeingOpened: !1,\n      onReadyBeingFired: null,\n      openComplete: !1,\n      dbReadyResolve: ee,\n      dbReadyPromise: null,\n      cancelOpen: ee,\n      openCanceller: null,\n      autoSchema: !0,\n      PR1398_maxLoop: 3\n    };\n    var i;\n    s.dbReadyPromise = new Ce(e => {\n      s.dbReadyResolve = e;\n    }), s.openCanceller = new Ce((e, t) => {\n      s.cancelOpen = t;\n    }), this._state = s, this.name = e, this.on = Et(this, \"populate\", \"blocked\", \"versionchange\", \"close\", {\n      ready: [ue, ee]\n    }), this.on.ready.subscribe = y(this.on.ready.subscribe, e => (t, n) => {\n      $n.vip(() => {\n        const r = this._state;\n        if (r.openComplete) r.dbOpenError || Ce.resolve().then(t), n && e(t);else if (r.onReadyBeingFired) r.onReadyBeingFired.push(t), n && e(t);else {\n          e(t);\n          const r = this;\n          n || e(function e() {\n            r.on.ready.unsubscribe(t), r.on.ready.unsubscribe(e);\n          });\n        }\n      });\n    }), this.Collection = (i = this, Pt(Rt.prototype, function (e, t) {\n      this.db = i;\n      let n = wt,\n          r = null;\n      if (t) try {\n        n = t();\n      } catch (e) {\n        r = e;\n      }\n      const s = e._ctx,\n            o = s.table,\n            a = o.hook.reading.fire;\n      this._ctx = {\n        table: o,\n        index: s.index,\n        isPrimKey: !s.index || o.schema.primKey.keyPath && s.index === o.schema.primKey.name,\n        range: n,\n        keysOnly: !1,\n        dir: \"next\",\n        unique: \"\",\n        algorithm: null,\n        filter: null,\n        replayFilter: null,\n        justLimit: !0,\n        isMatch: null,\n        offset: 0,\n        limit: 1 / 0,\n        error: r,\n        or: s.or,\n        valueMapper: a !== te ? a : null\n      };\n    })), this.Table = function (e) {\n      return Pt(kt.prototype, function (t, n, r) {\n        this.db = e, this._tx = r, this.name = t, this.schema = n, this.hook = e._allTables[t] ? e._allTables[t].hook : Et(null, {\n          creating: [se, ee],\n          reading: [ne, te],\n          updating: [oe, ee],\n          deleting: [ie, ee]\n        });\n      });\n    }(this), this.Transaction = function (e) {\n      return Pt(Qt.prototype, function (t, n, r, s, i) {\n        this.db = e, this.mode = t, this.storeNames = n, this.schema = r, this.chromeTransactionDurability = s, this.idbtrans = null, this.on = Et(this, \"complete\", \"error\", \"abort\"), this.parent = i || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Ce((e, t) => {\n          this._resolve = e, this._reject = t;\n        }), this._completion.then(() => {\n          this.active = !1, this.on.complete.fire();\n        }, e => {\n          var t = this.active;\n          return this.active = !1, this.on.error.fire(e), this.parent ? this.parent._reject(e) : t && this.idbtrans && this.idbtrans.abort(), ht(e);\n        });\n      });\n    }(this), this.Version = function (e) {\n      return Pt(vn.prototype, function (t) {\n        this.db = e, this._cfg = {\n          version: t,\n          storesSource: null,\n          dbschema: {},\n          tables: {},\n          contentUpgrade: null\n        };\n      });\n    }(this), this.WhereClause = function (e) {\n      return Pt(Yt.prototype, function (t, n, r) {\n        this.db = e, this._ctx = {\n          table: t,\n          index: \":id\" === n ? null : n,\n          or: r\n        };\n        const s = e._deps.indexedDB;\n        if (!s) throw new X.MissingAPI();\n        this._cmp = this._ascending = s.cmp.bind(s), this._descending = (e, t) => s.cmp(t, e), this._max = (e, t) => s.cmp(e, t) > 0 ? e : t, this._min = (e, t) => s.cmp(e, t) < 0 ? e : t, this._IDBKeyRange = e._deps.IDBKeyRange;\n      });\n    }(this), this.on(\"versionchange\", e => {\n      e.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close();\n    }), this.on(\"blocked\", e => {\n      !e.newVersion || e.newVersion < e.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${e.oldVersion / 10}`);\n    }), this._maxKey = en(t.IDBKeyRange), this._createTransaction = (e, t, n, r) => new this.Transaction(e, t, n, this._options.chromeTransactionDurability, r), this._fireOnBlocked = e => {\n      this.on(\"blocked\").fire(e), yt.filter(e => e.name === this.name && e !== this && !e._state.vcFired).map(t => t.on(\"versionchange\").fire(e));\n    }, this.use(On), this.use(An), this.use(qn), this.use(jn), this.vip = Object.create(this, {\n      _vip: {\n        value: !0\n      }\n    }), r.forEach(e => e(this));\n  }\n\n  version(e) {\n    if (isNaN(e) || e < .1) throw new X.Type(\"Given version is not a positive number\");\n    if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new X.Schema(\"Cannot add version when database is open\");\n    this.verno = Math.max(this.verno, e);\n    const t = this._versions;\n    var n = t.filter(t => t._cfg.version === e)[0];\n    return n || (n = new this.Version(e), t.push(n), t.sort(cn), n.stores({}), this._state.autoSchema = !1, n);\n  }\n\n  _whenReady(e) {\n    return this.idbdb && (this._state.openComplete || Ke.letThrough || this._vip) ? e() : new Ce((e, t) => {\n      if (this._state.openComplete) return t(new X.DatabaseClosed(this._state.dbOpenError));\n\n      if (!this._state.isBeingOpened) {\n        if (!this._options.autoOpen) return void t(new X.DatabaseClosed());\n        this.open().catch(ee);\n      }\n\n      this._state.dbReadyPromise.then(e, t);\n    }).then(e);\n  }\n\n  use({\n    stack: e,\n    create: t,\n    level: n,\n    name: r\n  }) {\n    r && this.unuse({\n      stack: e,\n      name: r\n    });\n    const s = this._middlewares[e] || (this._middlewares[e] = []);\n    return s.push({\n      stack: e,\n      create: t,\n      level: null == n ? 10 : n,\n      name: r\n    }), s.sort((e, t) => e.level - t.level), this;\n  }\n\n  unuse({\n    stack: e,\n    name: t,\n    create: n\n  }) {\n    return e && this._middlewares[e] && (this._middlewares[e] = this._middlewares[e].filter(e => n ? e.create !== n : !!t && e.name !== t)), this;\n  }\n\n  open() {\n    return xn(this);\n  }\n\n  _close() {\n    const e = this._state,\n          t = yt.indexOf(this);\n\n    if (t >= 0 && yt.splice(t, 1), this.idbdb) {\n      try {\n        this.idbdb.close();\n      } catch (e) {}\n\n      this._novip.idbdb = null;\n    }\n\n    e.dbReadyPromise = new Ce(t => {\n      e.dbReadyResolve = t;\n    }), e.openCanceller = new Ce((t, n) => {\n      e.cancelOpen = n;\n    });\n  }\n\n  close() {\n    this._close();\n\n    const e = this._state;\n    this._options.autoOpen = !1, e.dbOpenError = new X.DatabaseClosed(), e.isBeingOpened && e.cancelOpen(e.dbOpenError);\n  }\n\n  delete() {\n    const e = arguments.length > 0,\n          t = this._state;\n    return new Ce((n, r) => {\n      const s = () => {\n        this.close();\n\n        var e = this._deps.indexedDB.deleteDatabase(this.name);\n\n        e.onsuccess = We(() => {\n          !function ({\n            indexedDB: e,\n            IDBKeyRange: t\n          }, n) {\n            !bn(e) && \"__dbnames\" !== n && gn(e, t).delete(n).catch(ee);\n          }(this._deps, this.name), n();\n        }), e.onerror = zt(r), e.onblocked = this._fireOnBlocked;\n      };\n\n      if (e) throw new X.InvalidArgument(\"Arguments not allowed in db.delete()\");\n      t.isBeingOpened ? t.dbReadyPromise.then(s) : s();\n    });\n  }\n\n  backendDB() {\n    return this.idbdb;\n  }\n\n  isOpen() {\n    return null !== this.idbdb;\n  }\n\n  hasBeenClosed() {\n    const e = this._state.dbOpenError;\n    return e && \"DatabaseClosed\" === e.name;\n  }\n\n  hasFailed() {\n    return null !== this._state.dbOpenError;\n  }\n\n  dynamicallyOpened() {\n    return this._state.autoSchema;\n  }\n\n  get tables() {\n    return t(this._allTables).map(e => this._allTables[e]);\n  }\n\n  transaction() {\n    const e = En.apply(this, arguments);\n    return this._transaction.apply(this, e);\n  }\n\n  _transaction(e, t, n) {\n    let r = Ke.trans;\n    r && r.db === this && -1 === e.indexOf(\"!\") || (r = null);\n    const s = -1 !== e.indexOf(\"?\");\n    let i, o;\n    e = e.replace(\"!\", \"\").replace(\"?\", \"\");\n\n    try {\n      if (o = t.map(e => {\n        var t = e instanceof this.Table ? e.name : e;\n        if (\"string\" != typeof t) throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n        return t;\n      }), \"r\" == e || \"readonly\" === e) i = \"readonly\";else {\n        if (\"rw\" != e && \"readwrite\" != e) throw new X.InvalidArgument(\"Invalid transaction mode: \" + e);\n        i = \"readwrite\";\n      }\n\n      if (r) {\n        if (\"readonly\" === r.mode && \"readwrite\" === i) {\n          if (!s) throw new X.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n          r = null;\n        }\n\n        r && o.forEach(e => {\n          if (r && -1 === r.storeNames.indexOf(e)) {\n            if (!s) throw new X.SubTransaction(\"Table \" + e + \" not included in parent transaction.\");\n            r = null;\n          }\n        }), s && r && !r.active && (r = null);\n      }\n    } catch (e) {\n      return r ? r._promise(null, (t, n) => {\n        n(e);\n      }) : ht(e);\n    }\n\n    const a = Pn.bind(null, this, i, o, r, n);\n    return r ? r._promise(i, a, \"lock\") : Ke.trans ? ot(Ke.transless, () => this._whenReady(a)) : this._whenReady(a);\n  }\n\n  table(e) {\n    if (!o(this._allTables, e)) throw new X.InvalidTable(`Table ${e} does not exist`);\n    return this._allTables[e];\n  }\n\n}\n\nconst Un = \"undefined\" != typeof Symbol && \"observable\" in Symbol ? Symbol.observable : \"@@observable\";\n\nclass Ln {\n  constructor(e) {\n    this._subscribe = e;\n  }\n\n  subscribe(e, t, n) {\n    return this._subscribe(e && \"function\" != typeof e ? e : {\n      next: e,\n      error: t,\n      complete: n\n    });\n  }\n\n  [Un]() {\n    return this;\n  }\n\n}\n\nfunction Vn(e, n) {\n  return t(n).forEach(t => {\n    Tn(e[t] || (e[t] = new In()), n[t]);\n  }), e;\n}\n\nfunction Wn(e) {\n  return new Ln(n => {\n    const r = T(e);\n    let s = !1,\n        i = {},\n        o = {};\n    const a = {\n      get closed() {\n        return s;\n      },\n\n      unsubscribe: () => {\n        s = !0, Ht.storagemutated.unsubscribe(h);\n      }\n    };\n    n.start && n.start(a);\n    let u = !1,\n        l = !1;\n\n    function c() {\n      return t(o).some(e => i[e] && Rn(i[e], o[e]));\n    }\n\n    const h = e => {\n      Vn(i, e), c() && d();\n    },\n          d = () => {\n      if (u || s) return;\n      i = {};\n\n      const t = {},\n            f = function (t) {\n        r && Ze();\n\n        const n = () => Je(e, {\n          subscr: t,\n          trans: null\n        }),\n              s = Ke.trans ? ot(Ke.transless, n) : n();\n\n        return r && s.then(et, et), s;\n      }(t);\n\n      l || (Ht(\"storagemutated\", h), l = !0), u = !0, Promise.resolve(f).then(e => {\n        u = !1, s || (c() ? d() : (i = {}, o = t, n.next && n.next(e)));\n      }, e => {\n        u = !1, n.error && n.error(e), a.unsubscribe();\n      });\n    };\n\n    return d(), a;\n  });\n}\n\nlet Yn;\n\ntry {\n  Yn = {\n    indexedDB: e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB,\n    IDBKeyRange: e.IDBKeyRange || e.webkitIDBKeyRange\n  };\n} catch (e) {\n  Yn = {\n    indexedDB: null,\n    IDBKeyRange: null\n  };\n}\n\nconst zn = $n;\n\nfunction Gn(e) {\n  let t = Hn;\n\n  try {\n    Hn = !0, Ht.storagemutated.fire(e);\n  } finally {\n    Hn = t;\n  }\n}\n\na(zn, { ...Z,\n  delete: e => new zn(e, {\n    addons: []\n  }).delete(),\n  exists: e => new zn(e, {\n    addons: []\n  }).open().then(e => (e.close(), !0)).catch(\"NoSuchDatabaseError\", () => !1),\n\n  getDatabaseNames(e) {\n    try {\n      return function ({\n        indexedDB: e,\n        IDBKeyRange: t\n      }) {\n        return bn(e) ? Promise.resolve(e.databases()).then(e => e.map(e => e.name).filter(e => \"__dbnames\" !== e)) : gn(e, t).toCollection().primaryKeys();\n      }(zn.dependencies).then(e);\n    } catch (e) {\n      return ht(new X.MissingAPI());\n    }\n  },\n\n  defineClass: () => function (e) {\n    r(this, e);\n  },\n  ignoreTransaction: e => Ke.trans ? ot(Ke.transless, e) : e(),\n  vip: _n,\n  async: function (e) {\n    return function () {\n      try {\n        var t = kn(e.apply(this, arguments));\n        return t && \"function\" == typeof t.then ? t : Ce.resolve(t);\n      } catch (e) {\n        return ht(e);\n      }\n    };\n  },\n  spawn: function (e, t, n) {\n    try {\n      var r = kn(e.apply(n, t || []));\n      return r && \"function\" == typeof r.then ? r : Ce.resolve(r);\n    } catch (e) {\n      return ht(e);\n    }\n  },\n  currentTransaction: {\n    get: () => Ke.trans || null\n  },\n  waitFor: function (e, t) {\n    const n = Ce.resolve(\"function\" == typeof e ? zn.ignoreTransaction(e) : e).timeout(t || 6e4);\n    return Ke.trans ? Ke.trans.waitFor(n) : n;\n  },\n  Promise: Ce,\n  debug: {\n    get: () => R,\n    set: e => {\n      F(e, \"dexie\" === e ? () => !0 : bt);\n    }\n  },\n  derive: c,\n  extend: r,\n  props: a,\n  override: y,\n  Events: Et,\n  on: Ht,\n  liveQuery: Wn,\n  extendObservabilitySet: Vn,\n  getByKeyPath: b,\n  setByKeyPath: _,\n  delByKeyPath: function (e, t) {\n    \"string\" == typeof t ? _(e, t, void 0) : \"length\" in t && [].map.call(t, function (t) {\n      _(e, t, void 0);\n    });\n  },\n  shallowClone: w,\n  deepClone: O,\n  getObjectDiff: Sn,\n  cmp: It,\n  asap: v,\n  minKey: -(1 / 0),\n  addons: [],\n  connections: yt,\n  errnames: H,\n  dependencies: Yn,\n  semVer: \"3.2.2\",\n  version: \"3.2.2\".split(\".\").map(e => parseInt(e)).reduce((e, t, n) => e + t / Math.pow(10, 2 * n))\n}), zn.maxKey = en(zn.dependencies.IDBKeyRange), \"undefined\" != typeof dispatchEvent && \"undefined\" != typeof addEventListener && (Ht(\"storagemutated\", e => {\n  if (!Hn) {\n    let t;\n    mt ? (t = document.createEvent(\"CustomEvent\"), t.initCustomEvent(\"x-storagemutated-1\", !0, !0, e)) : t = new CustomEvent(\"x-storagemutated-1\", {\n      detail: e\n    }), Hn = !0, dispatchEvent(t), Hn = !1;\n  }\n}), addEventListener(\"x-storagemutated-1\", ({\n  detail: e\n}) => {\n  Hn || Gn(e);\n}));\nlet Hn = !1;\n\nif (\"undefined\" != typeof BroadcastChannel) {\n  const e = new BroadcastChannel(\"x-storagemutated-1\");\n  Ht(\"storagemutated\", t => {\n    Hn || e.postMessage(t);\n  }), e.onmessage = e => {\n    e.data && Gn(e.data);\n  };\n} else if (\"undefined\" != typeof self && \"undefined\" != typeof navigator) {\n  Ht(\"storagemutated\", e => {\n    try {\n      Hn || (\"undefined\" != typeof localStorage && localStorage.setItem(\"x-storagemutated-1\", JSON.stringify({\n        trig: Math.random(),\n        changedParts: e\n      })), \"object\" == typeof self.clients && [...self.clients.matchAll({\n        includeUncontrolled: !0\n      })].forEach(t => t.postMessage({\n        type: \"x-storagemutated-1\",\n        changedParts: e\n      })));\n    } catch (e) {}\n  }), \"undefined\" != typeof addEventListener && addEventListener(\"storage\", e => {\n    if (\"x-storagemutated-1\" === e.key) {\n      const t = JSON.parse(e.newValue);\n      t && Gn(t.changedParts);\n    }\n  });\n  const e = self.document && navigator.serviceWorker;\n  e && e.addEventListener(\"message\", function ({\n    data: e\n  }) {\n    e && \"x-storagemutated-1\" === e.type && Gn(e.changedParts);\n  });\n}\n\nCe.rejectionMapper = function (e, t) {\n  if (!e || e instanceof W || e instanceof TypeError || e instanceof SyntaxError || !e.name || !J[e.name]) return e;\n  var n = new J[e.name](t || e.message, e);\n  return \"stack\" in e && l(n, \"stack\", {\n    get: function () {\n      return this.inner.stack;\n    }\n  }), n;\n}, F(R, bt);\nexport { $n as Dexie, In as RangeSet, $n as default, Wn as liveQuery, Tn as mergeRanges, Rn as rangesOverlap };","map":null,"metadata":{},"sourceType":"module"}