{"ast":null,"code":"/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.2, Wed Apr 27 2022\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\nconst _global = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : global;\n\nconst keys = Object.keys;\nconst isArray = Array.isArray;\n\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n  _global.Promise = Promise;\n}\n\nfunction extend(obj, extension) {\n  if (typeof extension !== 'object') return obj;\n  keys(extension).forEach(function (key) {\n    obj[key] = extension[key];\n  });\n  return obj;\n}\n\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\n\nfunction hasOwn(obj, prop) {\n  return _hasOwn.call(obj, prop);\n}\n\nfunction props(proto, extension) {\n  if (typeof extension === 'function') extension = extension(getProto(proto));\n  (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n    setProp(proto, key, extension[key]);\n  });\n}\n\nconst defineProperty = Object.defineProperty;\n\nfunction setProp(obj, prop, functionOrGetSet, options) {\n  defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ? {\n    get: functionOrGetSet.get,\n    set: functionOrGetSet.set,\n    configurable: true\n  } : {\n    value: functionOrGetSet,\n    configurable: true,\n    writable: true\n  }, options));\n}\n\nfunction derive(Child) {\n  return {\n    from: function (Parent) {\n      Child.prototype = Object.create(Parent.prototype);\n      setProp(Child.prototype, \"constructor\", Child);\n      return {\n        extend: props.bind(null, Child.prototype)\n      };\n    }\n  };\n}\n\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\nfunction getPropertyDescriptor(obj, prop) {\n  const pd = getOwnPropertyDescriptor(obj, prop);\n  let proto;\n  return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\n\nconst _slice = [].slice;\n\nfunction slice(args, start, end) {\n  return _slice.call(args, start, end);\n}\n\nfunction override(origFunc, overridedFactory) {\n  return overridedFactory(origFunc);\n}\n\nfunction assert(b) {\n  if (!b) throw new Error(\"Assertion Failed\");\n}\n\nfunction asap$1(fn) {\n  if (_global.setImmediate) setImmediate(fn);else setTimeout(fn, 0);\n}\n\nfunction arrayToObject(array, extractor) {\n  return array.reduce((result, item, i) => {\n    var nameAndValue = extractor(item, i);\n    if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];\n    return result;\n  }, {});\n}\n\nfunction tryCatch(fn, onerror, args) {\n  try {\n    fn.apply(null, args);\n  } catch (ex) {\n    onerror && onerror(ex);\n  }\n}\n\nfunction getByKeyPath(obj, keyPath) {\n  if (hasOwn(obj, keyPath)) return obj[keyPath];\n  if (!keyPath) return obj;\n\n  if (typeof keyPath !== 'string') {\n    var rv = [];\n\n    for (var i = 0, l = keyPath.length; i < l; ++i) {\n      var val = getByKeyPath(obj, keyPath[i]);\n      rv.push(val);\n    }\n\n    return rv;\n  }\n\n  var period = keyPath.indexOf('.');\n\n  if (period !== -1) {\n    var innerObj = obj[keyPath.substr(0, period)];\n    return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n  }\n\n  return undefined;\n}\n\nfunction setByKeyPath(obj, keyPath, value) {\n  if (!obj || keyPath === undefined) return;\n  if ('isFrozen' in Object && Object.isFrozen(obj)) return;\n\n  if (typeof keyPath !== 'string' && 'length' in keyPath) {\n    assert(typeof value !== 'string' && 'length' in value);\n\n    for (var i = 0, l = keyPath.length; i < l; ++i) {\n      setByKeyPath(obj, keyPath[i], value[i]);\n    }\n  } else {\n    var period = keyPath.indexOf('.');\n\n    if (period !== -1) {\n      var currentKeyPath = keyPath.substr(0, period);\n      var remainingKeyPath = keyPath.substr(period + 1);\n      if (remainingKeyPath === \"\") {\n        if (value === undefined) {\n          if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);else delete obj[currentKeyPath];\n        } else obj[currentKeyPath] = value;\n      } else {\n        var innerObj = obj[currentKeyPath];\n        if (!innerObj || !hasOwn(obj, currentKeyPath)) innerObj = obj[currentKeyPath] = {};\n        setByKeyPath(innerObj, remainingKeyPath, value);\n      }\n    } else {\n      if (value === undefined) {\n        if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);else delete obj[keyPath];\n      } else obj[keyPath] = value;\n    }\n  }\n}\n\nfunction delByKeyPath(obj, keyPath) {\n  if (typeof keyPath === 'string') setByKeyPath(obj, keyPath, undefined);else if ('length' in keyPath) [].map.call(keyPath, function (kp) {\n    setByKeyPath(obj, kp, undefined);\n  });\n}\n\nfunction shallowClone(obj) {\n  var rv = {};\n\n  for (var m in obj) {\n    if (hasOwn(obj, m)) rv[m] = obj[m];\n  }\n\n  return rv;\n}\n\nconst concat = [].concat;\n\nfunction flatten(a) {\n  return concat.apply([], a);\n}\n\nconst intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\".split(',').concat(flatten([8, 16, 32, 64].map(num => [\"Int\", \"Uint\", \"Float\"].map(t => t + num + \"Array\")))).filter(t => _global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);\narrayToObject(intrinsicTypeNames, x => [x, true]);\nlet circularRefs = null;\n\nfunction deepClone(any) {\n  circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n  const rv = innerDeepClone(any);\n  circularRefs = null;\n  return rv;\n}\n\nfunction innerDeepClone(any) {\n  if (!any || typeof any !== 'object') return any;\n  let rv = circularRefs && circularRefs.get(any);\n  if (rv) return rv;\n\n  if (isArray(any)) {\n    rv = [];\n    circularRefs && circularRefs.set(any, rv);\n\n    for (var i = 0, l = any.length; i < l; ++i) {\n      rv.push(innerDeepClone(any[i]));\n    }\n  } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n    rv = any;\n  } else {\n    const proto = getProto(any);\n    rv = proto === Object.prototype ? {} : Object.create(proto);\n    circularRefs && circularRefs.set(any, rv);\n\n    for (var prop in any) {\n      if (hasOwn(any, prop)) {\n        rv[prop] = innerDeepClone(any[prop]);\n      }\n    }\n  }\n\n  return rv;\n}\n\nconst {\n  toString\n} = {};\n\nfunction toStringTag(o) {\n  return toString.call(o).slice(8, -1);\n}\n\nconst iteratorSymbol = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n  var i;\n  return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () {\n  return null;\n};\nconst NO_CHAR_ARRAY = {};\n\nfunction getArrayOf(arrayLike) {\n  var i, a, x, it;\n\n  if (arguments.length === 1) {\n    if (isArray(arrayLike)) return arrayLike.slice();\n    if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string') return [arrayLike];\n\n    if (it = getIteratorOf(arrayLike)) {\n      a = [];\n\n      while (x = it.next(), !x.done) a.push(x.value);\n\n      return a;\n    }\n\n    if (arrayLike == null) return [arrayLike];\n    i = arrayLike.length;\n\n    if (typeof i === 'number') {\n      a = new Array(i);\n\n      while (i--) a[i] = arrayLike[i];\n\n      return a;\n    }\n\n    return [arrayLike];\n  }\n\n  i = arguments.length;\n  a = new Array(i);\n\n  while (i--) a[i] = arguments[i];\n\n  return a;\n}\n\nconst isAsyncFunction = typeof Symbol !== 'undefined' ? fn => fn[Symbol.toStringTag] === 'AsyncFunction' : () => false;\nvar debug = typeof location !== 'undefined' && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n\nfunction setDebug(value, filter) {\n  debug = value;\n  libraryFilter = filter;\n}\n\nvar libraryFilter = () => true;\n\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\n\nfunction getErrorWithStack() {\n  if (NEEDS_THROW_FOR_STACK) try {\n    getErrorWithStack.arguments;\n    throw new Error();\n  } catch (e) {\n    return e;\n  }\n  return new Error();\n}\n\nfunction prettyStack(exception, numIgnoredFrames) {\n  var stack = exception.stack;\n  if (!stack) return \"\";\n  numIgnoredFrames = numIgnoredFrames || 0;\n  if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n  return stack.split('\\n').slice(numIgnoredFrames).filter(libraryFilter).map(frame => \"\\n\" + frame).join('');\n}\n\nvar dexieErrorNames = ['Modify', 'Bulk', 'OpenFailed', 'VersionChange', 'Schema', 'Upgrade', 'InvalidTable', 'MissingAPI', 'NoSuchDatabase', 'InvalidArgument', 'SubTransaction', 'Unsupported', 'Internal', 'DatabaseClosed', 'PrematureCommit', 'ForeignAwait'];\nvar idbDomErrorNames = ['Unknown', 'Constraint', 'Data', 'TransactionInactive', 'ReadOnly', 'Version', 'NotFound', 'InvalidState', 'InvalidAccess', 'Abort', 'Timeout', 'QuotaExceeded', 'Syntax', 'DataClone'];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n  VersionChanged: \"Database version changed by other database connection\",\n  DatabaseClosed: \"Database has been closed\",\n  Abort: \"Transaction aborted\",\n  TransactionInactive: \"Transaction has already completed or failed\",\n  MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\n\nfunction DexieError(name, msg) {\n  this._e = getErrorWithStack();\n  this.name = name;\n  this.message = msg;\n}\n\nderive(DexieError).from(Error).extend({\n  stack: {\n    get: function () {\n      return this._stack || (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n    }\n  },\n  toString: function () {\n    return this.name + \": \" + this.message;\n  }\n});\n\nfunction getMultiErrorMessage(msg, failures) {\n  return msg + \". Errors: \" + Object.keys(failures).map(key => failures[key].toString()).filter((v, i, s) => s.indexOf(v) === i).join('\\n');\n}\n\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n  this._e = getErrorWithStack();\n  this.failures = failures;\n  this.failedKeys = failedKeys;\n  this.successCount = successCount;\n  this.message = getMultiErrorMessage(msg, failures);\n}\n\nderive(ModifyError).from(DexieError);\n\nfunction BulkError(msg, failures) {\n  this._e = getErrorWithStack();\n  this.name = \"BulkError\";\n  this.failures = Object.keys(failures).map(pos => failures[pos]);\n  this.failuresByPos = failures;\n  this.message = getMultiErrorMessage(msg, failures);\n}\n\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name) => (obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name) => {\n  var fullName = name + \"Error\";\n\n  function DexieError(msgOrInner, inner) {\n    this._e = getErrorWithStack();\n    this.name = fullName;\n\n    if (!msgOrInner) {\n      this.message = defaultTexts[name] || fullName;\n      this.inner = null;\n    } else if (typeof msgOrInner === 'string') {\n      this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\n      this.inner = inner || null;\n    } else if (typeof msgOrInner === 'object') {\n      this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n      this.inner = msgOrInner;\n    }\n  }\n\n  derive(DexieError).from(BaseException);\n  obj[name] = DexieError;\n  return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name) => {\n  obj[name + \"Error\"] = exceptions[name];\n  return obj;\n}, {});\n\nfunction mapError(domError, message) {\n  if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;\n  var rv = new exceptionMap[domError.name](message || domError.message, domError);\n\n  if (\"stack\" in domError) {\n    setProp(rv, \"stack\", {\n      get: function () {\n        return this.inner.stack;\n      }\n    });\n  }\n\n  return rv;\n}\n\nvar fullNameExceptions = errorList.reduce((obj, name) => {\n  if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1) obj[name + \"Error\"] = exceptions[name];\n  return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() {}\n\nfunction mirror(val) {\n  return val;\n}\n\nfunction pureFunctionChain(f1, f2) {\n  if (f1 == null || f1 === mirror) return f2;\n  return function (val) {\n    return f2(f1(val));\n  };\n}\n\nfunction callBoth(on1, on2) {\n  return function () {\n    on1.apply(this, arguments);\n    on2.apply(this, arguments);\n  };\n}\n\nfunction hookCreatingChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    var res = f1.apply(this, arguments);\n    if (res !== undefined) arguments[0] = res;\n    var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n    this.onsuccess = null;\n    this.onerror = null;\n    var res2 = f2.apply(this, arguments);\n    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    return res2 !== undefined ? res2 : res;\n  };\n}\n\nfunction hookDeletingChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    f1.apply(this, arguments);\n    var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n    this.onsuccess = this.onerror = null;\n    f2.apply(this, arguments);\n    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n  };\n}\n\nfunction hookUpdatingChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function (modifications) {\n    var res = f1.apply(this, arguments);\n    extend(modifications, res);\n    var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n    this.onsuccess = null;\n    this.onerror = null;\n    var res2 = f2.apply(this, arguments);\n    if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n    if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);\n  };\n}\n\nfunction reverseStoppableEventChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    if (f2.apply(this, arguments) === false) return false;\n    return f1.apply(this, arguments);\n  };\n}\n\nfunction promisableChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    var res = f1.apply(this, arguments);\n\n    if (res && typeof res.then === 'function') {\n      var thiz = this,\n          i = arguments.length,\n          args = new Array(i);\n\n      while (i--) args[i] = arguments[i];\n\n      return res.then(function () {\n        return f2.apply(thiz, args);\n      });\n    }\n\n    return f2.apply(this, arguments);\n  };\n}\n\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100,\n      MAX_LONG_STACKS = 20,\n      ZONE_ECHO_LIMIT = 100,\n      [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ? [] : (() => {\n  let globalP = Promise.resolve();\n  if (typeof crypto === 'undefined' || !crypto.subtle) return [globalP, getProto(globalP), globalP];\n  const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n  return [nativeP, getProto(nativeP), globalP];\n})(),\n      nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ? () => {\n  resolvedGlobalPromise.then(physicalTick);\n} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? () => {\n  var hiddenDiv = document.createElement(\"div\");\n  new MutationObserver(() => {\n    physicalTick();\n    hiddenDiv = null;\n  }).observe(hiddenDiv, {\n    attributes: true\n  });\n  hiddenDiv.setAttribute('i', '1');\n} : () => {\n  setTimeout(physicalTick, 0);\n};\n\nvar asap = function (callback, args) {\n  microtickQueue.push([callback, args]);\n\n  if (needsNewPhysicalTick) {\n    schedulePhysicalTick();\n    needsNewPhysicalTick = false;\n  }\n};\n\nvar isOutsideMicroTick = true,\n    needsNewPhysicalTick = true,\n    unhandledErrors = [],\n    rejectingErrors = [],\n    currentFulfiller = null,\n    rejectionMapper = mirror;\nvar globalPSD = {\n  id: 'global',\n  global: true,\n  ref: 0,\n  unhandleds: [],\n  onunhandled: globalError,\n  pgp: false,\n  env: {},\n  finalize: function () {\n    this.unhandleds.forEach(uh => {\n      try {\n        globalError(uh[0], uh[1]);\n      } catch (e) {}\n    });\n  }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\n\nfunction DexiePromise(fn) {\n  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n  this._listeners = [];\n  this.onuncatched = nop;\n  this._lib = false;\n  var psd = this._PSD = PSD;\n\n  if (debug) {\n    this._stackHolder = getErrorWithStack();\n    this._prev = null;\n    this._numPrev = 0;\n  }\n\n  if (typeof fn !== 'function') {\n    if (fn !== INTERNAL) throw new TypeError('Not a function');\n    this._state = arguments[1];\n    this._value = arguments[2];\n    if (this._state === false) handleRejection(this, this._value);\n    return;\n  }\n\n  this._state = null;\n  this._value = null;\n  ++psd.ref;\n  executePromiseTask(this, fn);\n}\n\nconst thenProp = {\n  get: function () {\n    var psd = PSD,\n        microTaskId = totalEchoes;\n\n    function then(onFulfilled, onRejected) {\n      var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n      const cleanup = possibleAwait && !decrementExpectedAwaits();\n      var rv = new DexiePromise((resolve, reject) => {\n        propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n      });\n      debug && linkToPreviousPromise(rv, this);\n      return rv;\n    }\n\n    then.prototype = INTERNAL;\n    return then;\n  },\n  set: function (value) {\n    setProp(this, 'then', value && value.prototype === INTERNAL ? thenProp : {\n      get: function () {\n        return value;\n      },\n      set: thenProp.set\n    });\n  }\n};\nprops(DexiePromise.prototype, {\n  then: thenProp,\n  _then: function (onFulfilled, onRejected) {\n    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n  },\n  catch: function (onRejected) {\n    if (arguments.length === 1) return this.then(null, onRejected);\n    var type = arguments[0],\n        handler = arguments[1];\n    return typeof type === 'function' ? this.then(null, err => err instanceof type ? handler(err) : PromiseReject(err)) : this.then(null, err => err && err.name === type ? handler(err) : PromiseReject(err));\n  },\n  finally: function (onFinally) {\n    return this.then(value => {\n      onFinally();\n      return value;\n    }, err => {\n      onFinally();\n      return PromiseReject(err);\n    });\n  },\n  stack: {\n    get: function () {\n      if (this._stack) return this._stack;\n\n      try {\n        stack_being_generated = true;\n        var stacks = getStack(this, [], MAX_LONG_STACKS);\n        var stack = stacks.join(\"\\nFrom previous: \");\n        if (this._state !== null) this._stack = stack;\n        return stack;\n      } finally {\n        stack_being_generated = false;\n      }\n    }\n  },\n  timeout: function (ms, msg) {\n    return ms < Infinity ? new DexiePromise((resolve, reject) => {\n      var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n      this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n    }) : this;\n  }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag) setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\n\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.resolve = resolve;\n  this.reject = reject;\n  this.psd = zone;\n}\n\nprops(DexiePromise, {\n  all: function () {\n    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise(function (resolve, reject) {\n      if (values.length === 0) resolve([]);\n      var remaining = values.length;\n      values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\n        values[i] = x;\n        if (! --remaining) resolve(values);\n      }, reject));\n    });\n  },\n  resolve: value => {\n    if (value instanceof DexiePromise) return value;\n    if (value && typeof value.then === 'function') return new DexiePromise((resolve, reject) => {\n      value.then(resolve, reject);\n    });\n    var rv = new DexiePromise(INTERNAL, true, value);\n    linkToPreviousPromise(rv, currentFulfiller);\n    return rv;\n  },\n  reject: PromiseReject,\n  race: function () {\n    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise((resolve, reject) => {\n      values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n    });\n  },\n  PSD: {\n    get: () => PSD,\n    set: value => PSD = value\n  },\n  totalEchoes: {\n    get: () => totalEchoes\n  },\n  newPSD: newScope,\n  usePSD: usePSD,\n  scheduler: {\n    get: () => asap,\n    set: value => {\n      asap = value;\n    }\n  },\n  rejectionMapper: {\n    get: () => rejectionMapper,\n    set: value => {\n      rejectionMapper = value;\n    }\n  },\n  follow: (fn, zoneProps) => {\n    return new DexiePromise((resolve, reject) => {\n      return newScope((resolve, reject) => {\n        var psd = PSD;\n        psd.unhandleds = [];\n        psd.onunhandled = reject;\n        psd.finalize = callBoth(function () {\n          run_at_end_of_this_or_next_physical_tick(() => {\n            this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n          });\n        }, psd.finalize);\n        fn();\n      }, zoneProps, resolve, reject);\n    });\n  }\n});\n\nif (NativePromise) {\n  if (NativePromise.allSettled) setProp(DexiePromise, \"allSettled\", function () {\n    const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise(resolve => {\n      if (possiblePromises.length === 0) resolve([]);\n      let remaining = possiblePromises.length;\n      const results = new Array(remaining);\n      possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = {\n        status: \"fulfilled\",\n        value\n      }, reason => results[i] = {\n        status: \"rejected\",\n        reason\n      }).then(() => --remaining || resolve(results)));\n    });\n  });\n  if (NativePromise.any && typeof AggregateError !== 'undefined') setProp(DexiePromise, \"any\", function () {\n    const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n    return new DexiePromise((resolve, reject) => {\n      if (possiblePromises.length === 0) reject(new AggregateError([]));\n      let remaining = possiblePromises.length;\n      const failures = new Array(remaining);\n      possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {\n        failures[i] = failure;\n        if (! --remaining) reject(new AggregateError(failures));\n      }));\n    });\n  });\n}\n\nfunction executePromiseTask(promise, fn) {\n  try {\n    fn(value => {\n      if (promise._state !== null) return;\n      if (value === promise) throw new TypeError('A promise cannot be resolved with itself.');\n      var shouldExecuteTick = promise._lib && beginMicroTickScope();\n\n      if (value && typeof value.then === 'function') {\n        executePromiseTask(promise, (resolve, reject) => {\n          value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);\n        });\n      } else {\n        promise._state = true;\n        promise._value = value;\n        propagateAllListeners(promise);\n      }\n\n      if (shouldExecuteTick) endMicroTickScope();\n    }, handleRejection.bind(null, promise));\n  } catch (ex) {\n    handleRejection(promise, ex);\n  }\n}\n\nfunction handleRejection(promise, reason) {\n  rejectingErrors.push(reason);\n  if (promise._state !== null) return;\n  var shouldExecuteTick = promise._lib && beginMicroTickScope();\n  reason = rejectionMapper(reason);\n  promise._state = false;\n  promise._value = reason;\n  debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {\n    var origProp = getPropertyDescriptor(reason, \"stack\");\n    reason._promise = promise;\n    setProp(reason, \"stack\", {\n      get: () => stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack\n    });\n  });\n  addPossiblyUnhandledError(promise);\n  propagateAllListeners(promise);\n  if (shouldExecuteTick) endMicroTickScope();\n}\n\nfunction propagateAllListeners(promise) {\n  var listeners = promise._listeners;\n  promise._listeners = [];\n\n  for (var i = 0, len = listeners.length; i < len; ++i) {\n    propagateToListener(promise, listeners[i]);\n  }\n\n  var psd = promise._PSD;\n  --psd.ref || psd.finalize();\n\n  if (numScheduledCalls === 0) {\n    ++numScheduledCalls;\n    asap(() => {\n      if (--numScheduledCalls === 0) finalizePhysicalTick();\n    }, []);\n  }\n}\n\nfunction propagateToListener(promise, listener) {\n  if (promise._state === null) {\n    promise._listeners.push(listener);\n\n    return;\n  }\n\n  var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n\n  if (cb === null) {\n    return (promise._state ? listener.resolve : listener.reject)(promise._value);\n  }\n\n  ++listener.psd.ref;\n  ++numScheduledCalls;\n  asap(callListener, [cb, promise, listener]);\n}\n\nfunction callListener(cb, promise, listener) {\n  try {\n    currentFulfiller = promise;\n    var ret,\n        value = promise._value;\n\n    if (promise._state) {\n      ret = cb(value);\n    } else {\n      if (rejectingErrors.length) rejectingErrors = [];\n      ret = cb(value);\n      if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise);\n    }\n\n    listener.resolve(ret);\n  } catch (e) {\n    listener.reject(e);\n  } finally {\n    currentFulfiller = null;\n    if (--numScheduledCalls === 0) finalizePhysicalTick();\n    --listener.psd.ref || listener.psd.finalize();\n  }\n}\n\nfunction getStack(promise, stacks, limit) {\n  if (stacks.length === limit) return stacks;\n  var stack = \"\";\n\n  if (promise._state === false) {\n    var failure = promise._value,\n        errorName,\n        message;\n\n    if (failure != null) {\n      errorName = failure.name || \"Error\";\n      message = failure.message || failure;\n      stack = prettyStack(failure, 0);\n    } else {\n      errorName = failure;\n      message = \"\";\n    }\n\n    stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n  }\n\n  if (debug) {\n    stack = prettyStack(promise._stackHolder, 2);\n    if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);\n    if (promise._prev) getStack(promise._prev, stacks, limit);\n  }\n\n  return stacks;\n}\n\nfunction linkToPreviousPromise(promise, prev) {\n  var numPrev = prev ? prev._numPrev + 1 : 0;\n\n  if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n    promise._prev = prev;\n    promise._numPrev = numPrev;\n  }\n}\n\nfunction physicalTick() {\n  beginMicroTickScope() && endMicroTickScope();\n}\n\nfunction beginMicroTickScope() {\n  var wasRootExec = isOutsideMicroTick;\n  isOutsideMicroTick = false;\n  needsNewPhysicalTick = false;\n  return wasRootExec;\n}\n\nfunction endMicroTickScope() {\n  var callbacks, i, l;\n\n  do {\n    while (microtickQueue.length > 0) {\n      callbacks = microtickQueue;\n      microtickQueue = [];\n      l = callbacks.length;\n\n      for (i = 0; i < l; ++i) {\n        var item = callbacks[i];\n        item[0].apply(null, item[1]);\n      }\n    }\n  } while (microtickQueue.length > 0);\n\n  isOutsideMicroTick = true;\n  needsNewPhysicalTick = true;\n}\n\nfunction finalizePhysicalTick() {\n  var unhandledErrs = unhandledErrors;\n  unhandledErrors = [];\n  unhandledErrs.forEach(p => {\n    p._PSD.onunhandled.call(null, p._value, p);\n  });\n  var finalizers = tickFinalizers.slice(0);\n  var i = finalizers.length;\n\n  while (i) finalizers[--i]();\n}\n\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n  function finalizer() {\n    fn();\n    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n  }\n\n  tickFinalizers.push(finalizer);\n  ++numScheduledCalls;\n  asap(() => {\n    if (--numScheduledCalls === 0) finalizePhysicalTick();\n  }, []);\n}\n\nfunction addPossiblyUnhandledError(promise) {\n  if (!unhandledErrors.some(p => p._value === promise._value)) unhandledErrors.push(promise);\n}\n\nfunction markErrorAsHandled(promise) {\n  var i = unhandledErrors.length;\n\n  while (i) if (unhandledErrors[--i]._value === promise._value) {\n    unhandledErrors.splice(i, 1);\n    return;\n  }\n}\n\nfunction PromiseReject(reason) {\n  return new DexiePromise(INTERNAL, false, reason);\n}\n\nfunction wrap(fn, errorCatcher) {\n  var psd = PSD;\n  return function () {\n    var wasRootExec = beginMicroTickScope(),\n        outerScope = PSD;\n\n    try {\n      switchToZone(psd, true);\n      return fn.apply(this, arguments);\n    } catch (e) {\n      errorCatcher && errorCatcher(e);\n    } finally {\n      switchToZone(outerScope, false);\n      if (wasRootExec) endMicroTickScope();\n    }\n  };\n}\n\nconst task = {\n  awaits: 0,\n  echoes: 0,\n  id: 0\n};\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\n\nfunction newScope(fn, props, a1, a2) {\n  var parent = PSD,\n      psd = Object.create(parent);\n  psd.parent = parent;\n  psd.ref = 0;\n  psd.global = false;\n  psd.id = ++zone_id_counter;\n  var globalEnv = globalPSD.env;\n  psd.env = patchGlobalPromise ? {\n    Promise: DexiePromise,\n    PromiseProp: {\n      value: DexiePromise,\n      configurable: true,\n      writable: true\n    },\n    all: DexiePromise.all,\n    race: DexiePromise.race,\n    allSettled: DexiePromise.allSettled,\n    any: DexiePromise.any,\n    resolve: DexiePromise.resolve,\n    reject: DexiePromise.reject,\n    nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n    gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n  } : {};\n  if (props) extend(psd, props);\n  ++parent.ref;\n\n  psd.finalize = function () {\n    --this.parent.ref || this.parent.finalize();\n  };\n\n  var rv = usePSD(psd, fn, a1, a2);\n  if (psd.ref === 0) psd.finalize();\n  return rv;\n}\n\nfunction incrementExpectedAwaits() {\n  if (!task.id) task.id = ++taskCounter;\n  ++task.awaits;\n  task.echoes += ZONE_ECHO_LIMIT;\n  return task.id;\n}\n\nfunction decrementExpectedAwaits() {\n  if (!task.awaits) return false;\n  if (--task.awaits === 0) task.id = 0;\n  task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n  return true;\n}\n\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n  incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\n\nfunction onPossibleParallellAsync(possiblePromise) {\n  if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n    incrementExpectedAwaits();\n    return possiblePromise.then(x => {\n      decrementExpectedAwaits();\n      return x;\n    }, e => {\n      decrementExpectedAwaits();\n      return rejection(e);\n    });\n  }\n\n  return possiblePromise;\n}\n\nfunction zoneEnterEcho(targetZone) {\n  ++totalEchoes;\n\n  if (!task.echoes || --task.echoes === 0) {\n    task.echoes = task.id = 0;\n  }\n\n  zoneStack.push(PSD);\n  switchToZone(targetZone, true);\n}\n\nfunction zoneLeaveEcho() {\n  var zone = zoneStack[zoneStack.length - 1];\n  zoneStack.pop();\n  switchToZone(zone, false);\n}\n\nfunction switchToZone(targetZone, bEnteringZone) {\n  var currentZone = PSD;\n\n  if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (! --zoneEchoes || targetZone !== PSD)) {\n    enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n  }\n\n  if (targetZone === PSD) return;\n  PSD = targetZone;\n  if (currentZone === globalPSD) globalPSD.env = snapShot();\n\n  if (patchGlobalPromise) {\n    var GlobalPromise = globalPSD.env.Promise;\n    var targetEnv = targetZone.env;\n    nativePromiseProto.then = targetEnv.nthen;\n    GlobalPromise.prototype.then = targetEnv.gthen;\n\n    if (currentZone.global || targetZone.global) {\n      Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n      GlobalPromise.all = targetEnv.all;\n      GlobalPromise.race = targetEnv.race;\n      GlobalPromise.resolve = targetEnv.resolve;\n      GlobalPromise.reject = targetEnv.reject;\n      if (targetEnv.allSettled) GlobalPromise.allSettled = targetEnv.allSettled;\n      if (targetEnv.any) GlobalPromise.any = targetEnv.any;\n    }\n  }\n}\n\nfunction snapShot() {\n  var GlobalPromise = _global.Promise;\n  return patchGlobalPromise ? {\n    Promise: GlobalPromise,\n    PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n    all: GlobalPromise.all,\n    race: GlobalPromise.race,\n    allSettled: GlobalPromise.allSettled,\n    any: GlobalPromise.any,\n    resolve: GlobalPromise.resolve,\n    reject: GlobalPromise.reject,\n    nthen: nativePromiseProto.then,\n    gthen: GlobalPromise.prototype.then\n  } : {};\n}\n\nfunction usePSD(psd, fn, a1, a2, a3) {\n  var outerScope = PSD;\n\n  try {\n    switchToZone(psd, true);\n    return fn(a1, a2, a3);\n  } finally {\n    switchToZone(outerScope, false);\n  }\n}\n\nfunction enqueueNativeMicroTask(job) {\n  nativePromiseThen.call(resolvedNativePromise, job);\n}\n\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n  return typeof fn !== 'function' ? fn : function () {\n    var outerZone = PSD;\n    if (possibleAwait) incrementExpectedAwaits();\n    switchToZone(zone, true);\n\n    try {\n      return fn.apply(this, arguments);\n    } finally {\n      switchToZone(outerZone, false);\n      if (cleanup) enqueueNativeMicroTask(decrementExpectedAwaits);\n    }\n  };\n}\n\nfunction getPatchedPromiseThen(origThen, zone) {\n  return function (onResolved, onRejected) {\n    return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n  };\n}\n\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\n\nfunction globalError(err, promise) {\n  var rv;\n\n  try {\n    rv = promise.onuncatched(err);\n  } catch (e) {}\n\n  if (rv !== false) try {\n    var event,\n        eventData = {\n      promise: promise,\n      reason: err\n    };\n\n    if (_global.document && document.createEvent) {\n      event = document.createEvent('Event');\n      event.initEvent(UNHANDLEDREJECTION, true, true);\n      extend(event, eventData);\n    } else if (_global.CustomEvent) {\n      event = new CustomEvent(UNHANDLEDREJECTION, {\n        detail: eventData\n      });\n      extend(event, eventData);\n    }\n\n    if (event && _global.dispatchEvent) {\n      dispatchEvent(event);\n      if (!_global.PromiseRejectionEvent && _global.onunhandledrejection) try {\n        _global.onunhandledrejection(event);\n      } catch (_) {}\n    }\n\n    if (debug && event && !event.defaultPrevented) {\n      console.warn(`Unhandled rejection: ${err.stack || err}`);\n    }\n  } catch (e) {}\n}\n\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n  if (!db.idbdb || !db._state.openComplete && !PSD.letThrough && !db._vip) {\n    if (db._state.openComplete) {\n      return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n    }\n\n    if (!db._state.isBeingOpened) {\n      if (!db._options.autoOpen) return rejection(new exceptions.DatabaseClosed());\n      db.open().catch(nop);\n    }\n\n    return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n  } else {\n    var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n\n    try {\n      trans.create();\n      db._state.PR1398_maxLoop = 3;\n    } catch (ex) {\n      if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n        console.warn('Dexie: Need to reopen db');\n\n        db._close();\n\n        return db.open().then(() => tempTransaction(db, mode, storeNames, fn));\n      }\n\n      return rejection(ex);\n    }\n\n    return trans._promise(mode, (resolve, reject) => {\n      return newScope(() => {\n        PSD.trans = trans;\n        return fn(resolve, reject, trans);\n      });\n    }).then(result => {\n      return trans._completion.then(() => result);\n    });\n  }\n}\n\nconst DEXIE_VERSION = '3.2.2';\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\n\nconst dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\n\nconst DBNAMES_DB = '__dbnames';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n  return filter1 ? filter2 ? function () {\n    return filter1.apply(this, arguments) && filter2.apply(this, arguments);\n  } : filter1 : filter2;\n}\n\nconst AnyRange = {\n  type: 3,\n  lower: -Infinity,\n  lowerOpen: false,\n  upper: [[]],\n  upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n  return typeof keyPath === \"string\" && !/\\./.test(keyPath) ? obj => {\n    if (obj[keyPath] === undefined && keyPath in obj) {\n      obj = deepClone(obj);\n      delete obj[keyPath];\n    }\n\n    return obj;\n  } : obj => obj;\n}\n\nclass Table {\n  _trans(mode, fn, writeLocked) {\n    const trans = this._tx || PSD.trans;\n    const tableName = this.name;\n\n    function checkTableInTransaction(resolve, reject, trans) {\n      if (!trans.schema[tableName]) throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n      return fn(trans.idbtrans, trans);\n    }\n\n    const wasRootExec = beginMicroTickScope();\n\n    try {\n      return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), {\n        trans: trans,\n        transless: PSD.transless || PSD\n      }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n    } finally {\n      if (wasRootExec) endMicroTickScope();\n    }\n  }\n\n  get(keyOrCrit, cb) {\n    if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);\n    return this._trans('readonly', trans => {\n      return this.core.get({\n        trans,\n        key: keyOrCrit\n      }).then(res => this.hook.reading.fire(res));\n    }).then(cb);\n  }\n\n  where(indexOrCrit) {\n    if (typeof indexOrCrit === 'string') return new this.db.WhereClause(this, indexOrCrit);\n    if (isArray(indexOrCrit)) return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);\n    const keyPaths = keys(indexOrCrit);\n    if (keyPaths.length === 1) return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);\n    const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound && keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) && ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];\n    if (compoundIndex && this.db._maxKey !== maxString) return this.where(compoundIndex.name).equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));\n    if (!compoundIndex && debug) console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` + `compound index [${keyPaths.join('+')}]`);\n    const {\n      idxByName\n    } = this.schema;\n    const idb = this.db._deps.indexedDB;\n\n    function equals(a, b) {\n      try {\n        return idb.cmp(a, b) === 0;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n      const index = idxByName[keyPath];\n      const value = indexOrCrit[keyPath];\n      return [prevIndex || index, prevIndex || !index ? combine(prevFilterFn, index && index.multi ? x => {\n        const prop = getByKeyPath(x, keyPath);\n        return isArray(prop) && prop.some(item => equals(value, item));\n      } : x => equals(value, getByKeyPath(x, keyPath))) : prevFilterFn];\n    }, [null, null]);\n    return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals('');\n  }\n\n  filter(filterFunction) {\n    return this.toCollection().and(filterFunction);\n  }\n\n  count(thenShortcut) {\n    return this.toCollection().count(thenShortcut);\n  }\n\n  offset(offset) {\n    return this.toCollection().offset(offset);\n  }\n\n  limit(numRows) {\n    return this.toCollection().limit(numRows);\n  }\n\n  each(callback) {\n    return this.toCollection().each(callback);\n  }\n\n  toArray(thenShortcut) {\n    return this.toCollection().toArray(thenShortcut);\n  }\n\n  toCollection() {\n    return new this.db.Collection(new this.db.WhereClause(this));\n  }\n\n  orderBy(index) {\n    return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? `[${index.join('+')}]` : index));\n  }\n\n  reverse() {\n    return this.toCollection().reverse();\n  }\n\n  mapToClass(constructor) {\n    this.schema.mappedClass = constructor;\n\n    const readHook = obj => {\n      if (!obj) return obj;\n      const res = Object.create(constructor.prototype);\n\n      for (var m in obj) if (hasOwn(obj, m)) try {\n        res[m] = obj[m];\n      } catch (_) {}\n\n      return res;\n    };\n\n    if (this.schema.readHook) {\n      this.hook.reading.unsubscribe(this.schema.readHook);\n    }\n\n    this.schema.readHook = readHook;\n    this.hook(\"reading\", readHook);\n    return constructor;\n  }\n\n  defineClass() {\n    function Class(content) {\n      extend(this, content);\n    }\n\n    return this.mapToClass(Class);\n  }\n\n  add(obj, key) {\n    const {\n      auto,\n      keyPath\n    } = this.schema.primKey;\n    let objToAdd = obj;\n\n    if (keyPath && auto) {\n      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n    }\n\n    return this._trans('readwrite', trans => {\n      return this.core.mutate({\n        trans,\n        type: 'add',\n        keys: key != null ? [key] : null,\n        values: [objToAdd]\n      });\n    }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then(lastResult => {\n      if (keyPath) {\n        try {\n          setByKeyPath(obj, keyPath, lastResult);\n        } catch (_) {}\n      }\n\n      return lastResult;\n    });\n  }\n\n  update(keyOrObject, modifications) {\n    if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n      const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n      if (key === undefined) return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n\n      try {\n        if (typeof modifications !== \"function\") {\n          keys(modifications).forEach(keyPath => {\n            setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n          });\n        } else {\n          modifications(keyOrObject, {\n            value: keyOrObject,\n            primKey: key\n          });\n        }\n      } catch (_a) {}\n\n      return this.where(\":id\").equals(key).modify(modifications);\n    } else {\n      return this.where(\":id\").equals(keyOrObject).modify(modifications);\n    }\n  }\n\n  put(obj, key) {\n    const {\n      auto,\n      keyPath\n    } = this.schema.primKey;\n    let objToAdd = obj;\n\n    if (keyPath && auto) {\n      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n    }\n\n    return this._trans('readwrite', trans => this.core.mutate({\n      trans,\n      type: 'put',\n      values: [objToAdd],\n      keys: key != null ? [key] : null\n    })).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then(lastResult => {\n      if (keyPath) {\n        try {\n          setByKeyPath(obj, keyPath, lastResult);\n        } catch (_) {}\n      }\n\n      return lastResult;\n    });\n  }\n\n  delete(key) {\n    return this._trans('readwrite', trans => this.core.mutate({\n      trans,\n      type: 'delete',\n      keys: [key]\n    })).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n  }\n\n  clear() {\n    return this._trans('readwrite', trans => this.core.mutate({\n      trans,\n      type: 'deleteRange',\n      range: AnyRange\n    })).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n  }\n\n  bulkGet(keys) {\n    return this._trans('readonly', trans => {\n      return this.core.getMany({\n        keys,\n        trans\n      }).then(result => result.map(res => this.hook.reading.fire(res)));\n    });\n  }\n\n  bulkAdd(objects, keysOrOptions, options) {\n    const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n    options = options || (keys ? undefined : keysOrOptions);\n    const wantResults = options ? options.allKeys : undefined;\n    return this._trans('readwrite', trans => {\n      const {\n        auto,\n        keyPath\n      } = this.schema.primKey;\n      if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n      if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n      const numObjects = objects.length;\n      let objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n      return this.core.mutate({\n        trans,\n        type: 'add',\n        keys: keys,\n        values: objectsToAdd,\n        wantResults\n      }).then(({\n        numFailures,\n        results,\n        lastResult,\n        failures\n      }) => {\n        const result = wantResults ? results : lastResult;\n        if (numFailures === 0) return result;\n        throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n      });\n    });\n  }\n\n  bulkPut(objects, keysOrOptions, options) {\n    const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n    options = options || (keys ? undefined : keysOrOptions);\n    const wantResults = options ? options.allKeys : undefined;\n    return this._trans('readwrite', trans => {\n      const {\n        auto,\n        keyPath\n      } = this.schema.primKey;\n      if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n      if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n      const numObjects = objects.length;\n      let objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n      return this.core.mutate({\n        trans,\n        type: 'put',\n        keys: keys,\n        values: objectsToPut,\n        wantResults\n      }).then(({\n        numFailures,\n        results,\n        lastResult,\n        failures\n      }) => {\n        const result = wantResults ? results : lastResult;\n        if (numFailures === 0) return result;\n        throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n      });\n    });\n  }\n\n  bulkDelete(keys) {\n    const numKeys = keys.length;\n    return this._trans('readwrite', trans => {\n      return this.core.mutate({\n        trans,\n        type: 'delete',\n        keys: keys\n      });\n    }).then(({\n      numFailures,\n      lastResult,\n      failures\n    }) => {\n      if (numFailures === 0) return lastResult;\n      throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n    });\n  }\n\n}\n\nfunction Events(ctx) {\n  var evs = {};\n\n  var rv = function (eventName, subscriber) {\n    if (subscriber) {\n      var i = arguments.length,\n          args = new Array(i - 1);\n\n      while (--i) args[i - 1] = arguments[i];\n\n      evs[eventName].subscribe.apply(null, args);\n      return ctx;\n    } else if (typeof eventName === 'string') {\n      return evs[eventName];\n    }\n  };\n\n  rv.addEventType = add;\n\n  for (var i = 1, l = arguments.length; i < l; ++i) {\n    add(arguments[i]);\n  }\n\n  return rv;\n\n  function add(eventName, chainFunction, defaultFunction) {\n    if (typeof eventName === 'object') return addConfiguredEvents(eventName);\n    if (!chainFunction) chainFunction = reverseStoppableEventChain;\n    if (!defaultFunction) defaultFunction = nop;\n    var context = {\n      subscribers: [],\n      fire: defaultFunction,\n      subscribe: function (cb) {\n        if (context.subscribers.indexOf(cb) === -1) {\n          context.subscribers.push(cb);\n          context.fire = chainFunction(context.fire, cb);\n        }\n      },\n      unsubscribe: function (cb) {\n        context.subscribers = context.subscribers.filter(function (fn) {\n          return fn !== cb;\n        });\n        context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n      }\n    };\n    evs[eventName] = rv[eventName] = context;\n    return context;\n  }\n\n  function addConfiguredEvents(cfg) {\n    keys(cfg).forEach(function (eventName) {\n      var args = cfg[eventName];\n\n      if (isArray(args)) {\n        add(eventName, cfg[eventName][0], cfg[eventName][1]);\n      } else if (args === 'asap') {\n        var context = add(eventName, mirror, function fire() {\n          var i = arguments.length,\n              args = new Array(i);\n\n          while (i--) args[i] = arguments[i];\n\n          context.subscribers.forEach(function (fn) {\n            asap$1(function fireEvent() {\n              fn.apply(null, args);\n            });\n          });\n        });\n      } else throw new exceptions.InvalidArgument(\"Invalid event config\");\n    });\n  }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n  derive(constructor).from({\n    prototype\n  });\n  return constructor;\n}\n\nfunction createTableConstructor(db) {\n  return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n    this.db = db;\n    this._tx = trans;\n    this.name = name;\n    this.schema = tableSchema;\n    this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n      \"creating\": [hookCreatingChain, nop],\n      \"reading\": [pureFunctionChain, mirror],\n      \"updating\": [hookUpdatingChain, nop],\n      \"deleting\": [hookDeletingChain, nop]\n    });\n  });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n  return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\n\nfunction addFilter(ctx, fn) {\n  ctx.filter = combine(ctx.filter, fn);\n}\n\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n  var curr = ctx.replayFilter;\n  ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;\n  ctx.justLimit = isLimitFilter && !curr;\n}\n\nfunction addMatchFilter(ctx, fn) {\n  ctx.isMatch = combine(ctx.isMatch, fn);\n}\n\nfunction getIndexOrStore(ctx, coreSchema) {\n  if (ctx.isPrimKey) return coreSchema.primaryKey;\n  const index = coreSchema.getIndexByKeyPath(ctx.index);\n  if (!index) throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n  return index;\n}\n\nfunction openCursor(ctx, coreTable, trans) {\n  const index = getIndexOrStore(ctx, coreTable.schema);\n  return coreTable.openCursor({\n    trans,\n    values: !ctx.keysOnly,\n    reverse: ctx.dir === 'prev',\n    unique: !!ctx.unique,\n    query: {\n      index,\n      range: ctx.range\n    }\n  });\n}\n\nfunction iter(ctx, fn, coreTrans, coreTable) {\n  const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n\n  if (!ctx.or) {\n    return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n  } else {\n    const set = {};\n\n    const union = (item, cursor, advance) => {\n      if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {\n        var primaryKey = cursor.primaryKey;\n        var key = '' + primaryKey;\n        if (key === '[object ArrayBuffer]') key = '' + new Uint8Array(primaryKey);\n\n        if (!hasOwn(set, key)) {\n          set[key] = true;\n          fn(item, cursor, advance);\n        }\n      }\n    };\n\n    return Promise.all([ctx.or._iterate(union, coreTrans), iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)]);\n  }\n}\n\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n  var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;\n  var wrappedFn = wrap(mappedFn);\n  return cursorPromise.then(cursor => {\n    if (cursor) {\n      return cursor.start(() => {\n        var c = () => cursor.continue();\n\n        if (!filter || filter(cursor, advancer => c = advancer, val => {\n          cursor.stop(val);\n          c = nop;\n        }, e => {\n          cursor.fail(e);\n          c = nop;\n        })) wrappedFn(cursor.value, cursor, advancer => c = advancer);\n        c();\n      });\n    }\n  });\n}\n\nfunction cmp(a, b) {\n  try {\n    const ta = type(a);\n    const tb = type(b);\n\n    if (ta !== tb) {\n      if (ta === 'Array') return 1;\n      if (tb === 'Array') return -1;\n      if (ta === 'binary') return 1;\n      if (tb === 'binary') return -1;\n      if (ta === 'string') return 1;\n      if (tb === 'string') return -1;\n      if (ta === 'Date') return 1;\n      if (tb !== 'Date') return NaN;\n      return -1;\n    }\n\n    switch (ta) {\n      case 'number':\n      case 'Date':\n      case 'string':\n        return a > b ? 1 : a < b ? -1 : 0;\n\n      case 'binary':\n        {\n          return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n        }\n\n      case 'Array':\n        return compareArrays(a, b);\n    }\n  } catch (_a) {}\n\n  return NaN;\n}\n\nfunction compareArrays(a, b) {\n  const al = a.length;\n  const bl = b.length;\n  const l = al < bl ? al : bl;\n\n  for (let i = 0; i < l; ++i) {\n    const res = cmp(a[i], b[i]);\n    if (res !== 0) return res;\n  }\n\n  return al === bl ? 0 : al < bl ? -1 : 1;\n}\n\nfunction compareUint8Arrays(a, b) {\n  const al = a.length;\n  const bl = b.length;\n  const l = al < bl ? al : bl;\n\n  for (let i = 0; i < l; ++i) {\n    if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;\n  }\n\n  return al === bl ? 0 : al < bl ? -1 : 1;\n}\n\nfunction type(x) {\n  const t = typeof x;\n  if (t !== 'object') return t;\n  if (ArrayBuffer.isView(x)) return 'binary';\n  const tsTag = toStringTag(x);\n  return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\n\nfunction getUint8Array(a) {\n  if (a instanceof Uint8Array) return a;\n  if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return new Uint8Array(a);\n}\n\nclass Collection {\n  _read(fn, cb) {\n    var ctx = this._ctx;\n    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readonly', fn).then(cb);\n  }\n\n  _write(fn) {\n    var ctx = this._ctx;\n    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans('readwrite', fn, \"locked\");\n  }\n\n  _addAlgorithm(fn) {\n    var ctx = this._ctx;\n    ctx.algorithm = combine(ctx.algorithm, fn);\n  }\n\n  _iterate(fn, coreTrans) {\n    return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n  }\n\n  clone(props) {\n    var rv = Object.create(this.constructor.prototype),\n        ctx = Object.create(this._ctx);\n    if (props) extend(ctx, props);\n    rv._ctx = ctx;\n    return rv;\n  }\n\n  raw() {\n    this._ctx.valueMapper = null;\n    return this;\n  }\n\n  each(fn) {\n    var ctx = this._ctx;\n    return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n  }\n\n  count(cb) {\n    return this._read(trans => {\n      const ctx = this._ctx;\n      const coreTable = ctx.table.core;\n\n      if (isPlainKeyRange(ctx, true)) {\n        return coreTable.count({\n          trans,\n          query: {\n            index: getIndexOrStore(ctx, coreTable.schema),\n            range: ctx.range\n          }\n        }).then(count => Math.min(count, ctx.limit));\n      } else {\n        var count = 0;\n        return iter(ctx, () => {\n          ++count;\n          return false;\n        }, trans, coreTable).then(() => count);\n      }\n    }).then(cb);\n  }\n\n  sortBy(keyPath, cb) {\n    const parts = keyPath.split('.').reverse(),\n          lastPart = parts[0],\n          lastIndex = parts.length - 1;\n\n    function getval(obj, i) {\n      if (i) return getval(obj[parts[i]], i - 1);\n      return obj[lastPart];\n    }\n\n    var order = this._ctx.dir === \"next\" ? 1 : -1;\n\n    function sorter(a, b) {\n      var aVal = getval(a, lastIndex),\n          bVal = getval(b, lastIndex);\n      return aVal < bVal ? -order : aVal > bVal ? order : 0;\n    }\n\n    return this.toArray(function (a) {\n      return a.sort(sorter);\n    }).then(cb);\n  }\n\n  toArray(cb) {\n    return this._read(trans => {\n      var ctx = this._ctx;\n\n      if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n        const {\n          valueMapper\n        } = ctx;\n        const index = getIndexOrStore(ctx, ctx.table.core.schema);\n        return ctx.table.core.query({\n          trans,\n          limit: ctx.limit,\n          values: true,\n          query: {\n            index,\n            range: ctx.range\n          }\n        }).then(({\n          result\n        }) => valueMapper ? result.map(valueMapper) : result);\n      } else {\n        const a = [];\n        return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);\n      }\n    }, cb);\n  }\n\n  offset(offset) {\n    var ctx = this._ctx;\n    if (offset <= 0) return this;\n    ctx.offset += offset;\n\n    if (isPlainKeyRange(ctx)) {\n      addReplayFilter(ctx, () => {\n        var offsetLeft = offset;\n        return (cursor, advance) => {\n          if (offsetLeft === 0) return true;\n\n          if (offsetLeft === 1) {\n            --offsetLeft;\n            return false;\n          }\n\n          advance(() => {\n            cursor.advance(offsetLeft);\n            offsetLeft = 0;\n          });\n          return false;\n        };\n      });\n    } else {\n      addReplayFilter(ctx, () => {\n        var offsetLeft = offset;\n        return () => --offsetLeft < 0;\n      });\n    }\n\n    return this;\n  }\n\n  limit(numRows) {\n    this._ctx.limit = Math.min(this._ctx.limit, numRows);\n    addReplayFilter(this._ctx, () => {\n      var rowsLeft = numRows;\n      return function (cursor, advance, resolve) {\n        if (--rowsLeft <= 0) advance(resolve);\n        return rowsLeft >= 0;\n      };\n    }, true);\n    return this;\n  }\n\n  until(filterFunction, bIncludeStopEntry) {\n    addFilter(this._ctx, function (cursor, advance, resolve) {\n      if (filterFunction(cursor.value)) {\n        advance(resolve);\n        return bIncludeStopEntry;\n      } else {\n        return true;\n      }\n    });\n    return this;\n  }\n\n  first(cb) {\n    return this.limit(1).toArray(function (a) {\n      return a[0];\n    }).then(cb);\n  }\n\n  last(cb) {\n    return this.reverse().first(cb);\n  }\n\n  filter(filterFunction) {\n    addFilter(this._ctx, function (cursor) {\n      return filterFunction(cursor.value);\n    });\n    addMatchFilter(this._ctx, filterFunction);\n    return this;\n  }\n\n  and(filter) {\n    return this.filter(filter);\n  }\n\n  or(indexName) {\n    return new this.db.WhereClause(this._ctx.table, indexName, this);\n  }\n\n  reverse() {\n    this._ctx.dir = this._ctx.dir === \"prev\" ? \"next\" : \"prev\";\n    if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);\n    return this;\n  }\n\n  desc() {\n    return this.reverse();\n  }\n\n  eachKey(cb) {\n    var ctx = this._ctx;\n    ctx.keysOnly = !ctx.isMatch;\n    return this.each(function (val, cursor) {\n      cb(cursor.key, cursor);\n    });\n  }\n\n  eachUniqueKey(cb) {\n    this._ctx.unique = \"unique\";\n    return this.eachKey(cb);\n  }\n\n  eachPrimaryKey(cb) {\n    var ctx = this._ctx;\n    ctx.keysOnly = !ctx.isMatch;\n    return this.each(function (val, cursor) {\n      cb(cursor.primaryKey, cursor);\n    });\n  }\n\n  keys(cb) {\n    var ctx = this._ctx;\n    ctx.keysOnly = !ctx.isMatch;\n    var a = [];\n    return this.each(function (item, cursor) {\n      a.push(cursor.key);\n    }).then(function () {\n      return a;\n    }).then(cb);\n  }\n\n  primaryKeys(cb) {\n    var ctx = this._ctx;\n\n    if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n      return this._read(trans => {\n        var index = getIndexOrStore(ctx, ctx.table.core.schema);\n        return ctx.table.core.query({\n          trans,\n          values: false,\n          limit: ctx.limit,\n          query: {\n            index,\n            range: ctx.range\n          }\n        });\n      }).then(({\n        result\n      }) => result).then(cb);\n    }\n\n    ctx.keysOnly = !ctx.isMatch;\n    var a = [];\n    return this.each(function (item, cursor) {\n      a.push(cursor.primaryKey);\n    }).then(function () {\n      return a;\n    }).then(cb);\n  }\n\n  uniqueKeys(cb) {\n    this._ctx.unique = \"unique\";\n    return this.keys(cb);\n  }\n\n  firstKey(cb) {\n    return this.limit(1).keys(function (a) {\n      return a[0];\n    }).then(cb);\n  }\n\n  lastKey(cb) {\n    return this.reverse().firstKey(cb);\n  }\n\n  distinct() {\n    var ctx = this._ctx,\n        idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n    if (!idx || !idx.multi) return this;\n    var set = {};\n    addFilter(this._ctx, function (cursor) {\n      var strKey = cursor.primaryKey.toString();\n      var found = hasOwn(set, strKey);\n      set[strKey] = true;\n      return !found;\n    });\n    return this;\n  }\n\n  modify(changes) {\n    var ctx = this._ctx;\n    return this._write(trans => {\n      var modifyer;\n\n      if (typeof changes === 'function') {\n        modifyer = changes;\n      } else {\n        var keyPaths = keys(changes);\n        var numKeys = keyPaths.length;\n\n        modifyer = function (item) {\n          var anythingModified = false;\n\n          for (var i = 0; i < numKeys; ++i) {\n            var keyPath = keyPaths[i],\n                val = changes[keyPath];\n\n            if (getByKeyPath(item, keyPath) !== val) {\n              setByKeyPath(item, keyPath, val);\n              anythingModified = true;\n            }\n          }\n\n          return anythingModified;\n        };\n      }\n\n      const coreTable = ctx.table.core;\n      const {\n        outbound,\n        extractKey\n      } = coreTable.schema.primaryKey;\n      const limit = this.db._options.modifyChunkSize || 200;\n      const totalFailures = [];\n      let successCount = 0;\n      const failedKeys = [];\n\n      const applyMutateResult = (expectedCount, res) => {\n        const {\n          failures,\n          numFailures\n        } = res;\n        successCount += expectedCount - numFailures;\n\n        for (let pos of keys(failures)) {\n          totalFailures.push(failures[pos]);\n        }\n      };\n\n      return this.clone().primaryKeys().then(keys => {\n        const nextChunk = offset => {\n          const count = Math.min(limit, keys.length - offset);\n          return coreTable.getMany({\n            trans,\n            keys: keys.slice(offset, offset + count),\n            cache: \"immutable\"\n          }).then(values => {\n            const addValues = [];\n            const putValues = [];\n            const putKeys = outbound ? [] : null;\n            const deleteKeys = [];\n\n            for (let i = 0; i < count; ++i) {\n              const origValue = values[i];\n              const ctx = {\n                value: deepClone(origValue),\n                primKey: keys[offset + i]\n              };\n\n              if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                if (ctx.value == null) {\n                  deleteKeys.push(keys[offset + i]);\n                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                  deleteKeys.push(keys[offset + i]);\n                  addValues.push(ctx.value);\n                } else {\n                  putValues.push(ctx.value);\n                  if (outbound) putKeys.push(keys[offset + i]);\n                }\n              }\n            }\n\n            const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== 'function' || changes === deleteCallback) && {\n              index: ctx.index,\n              range: ctx.range\n            };\n            return Promise.resolve(addValues.length > 0 && coreTable.mutate({\n              trans,\n              type: 'add',\n              values: addValues\n            }).then(res => {\n              for (let pos in res.failures) {\n                deleteKeys.splice(parseInt(pos), 1);\n              }\n\n              applyMutateResult(addValues.length, res);\n            })).then(() => (putValues.length > 0 || criteria && typeof changes === 'object') && coreTable.mutate({\n              trans,\n              type: 'put',\n              keys: putKeys,\n              values: putValues,\n              criteria,\n              changeSpec: typeof changes !== 'function' && changes\n            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({\n              trans,\n              type: 'delete',\n              keys: deleteKeys,\n              criteria\n            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {\n              return keys.length > offset + count && nextChunk(offset + limit);\n            });\n          });\n        };\n\n        return nextChunk(0).then(() => {\n          if (totalFailures.length > 0) throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n          return keys.length;\n        });\n      });\n    });\n  }\n\n  delete() {\n    var ctx = this._ctx,\n        range = ctx.range;\n\n    if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {\n      return this._write(trans => {\n        const {\n          primaryKey\n        } = ctx.table.core.schema;\n        const coreRange = range;\n        return ctx.table.core.count({\n          trans,\n          query: {\n            index: primaryKey,\n            range: coreRange\n          }\n        }).then(count => {\n          return ctx.table.core.mutate({\n            trans,\n            type: 'deleteRange',\n            range: coreRange\n          }).then(({\n            failures,\n            lastResult,\n            results,\n            numFailures\n          }) => {\n            if (numFailures) throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(pos => failures[pos]), count - numFailures);\n            return count - numFailures;\n          });\n        });\n      });\n    }\n\n    return this.modify(deleteCallback);\n  }\n\n}\n\nconst deleteCallback = (value, ctx) => ctx.value = null;\n\nfunction createCollectionConstructor(db) {\n  return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n    this.db = db;\n    let keyRange = AnyRange,\n        error = null;\n    if (keyRangeGenerator) try {\n      keyRange = keyRangeGenerator();\n    } catch (ex) {\n      error = ex;\n    }\n    const whereCtx = whereClause._ctx;\n    const table = whereCtx.table;\n    const readingHook = table.hook.reading.fire;\n    this._ctx = {\n      table: table,\n      index: whereCtx.index,\n      isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,\n      range: keyRange,\n      keysOnly: false,\n      dir: \"next\",\n      unique: \"\",\n      algorithm: null,\n      filter: null,\n      replayFilter: null,\n      justLimit: true,\n      isMatch: null,\n      offset: 0,\n      limit: Infinity,\n      error: error,\n      or: whereCtx.or,\n      valueMapper: readingHook !== mirror ? readingHook : null\n    };\n  });\n}\n\nfunction simpleCompare(a, b) {\n  return a < b ? -1 : a === b ? 0 : 1;\n}\n\nfunction simpleCompareReverse(a, b) {\n  return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n  var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;\n  collection._ctx.error = T ? new T(err) : new TypeError(err);\n  return collection;\n}\n\nfunction emptyCollection(whereClause) {\n  return new whereClause.Collection(whereClause, () => rangeEqual(\"\")).limit(0);\n}\n\nfunction upperFactory(dir) {\n  return dir === \"next\" ? s => s.toUpperCase() : s => s.toLowerCase();\n}\n\nfunction lowerFactory(dir) {\n  return dir === \"next\" ? s => s.toLowerCase() : s => s.toUpperCase();\n}\n\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n  var length = Math.min(key.length, lowerNeedle.length);\n  var llp = -1;\n\n  for (var i = 0; i < length; ++i) {\n    var lwrKeyChar = lowerKey[i];\n\n    if (lwrKeyChar !== lowerNeedle[i]) {\n      if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n      if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n      if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n      return null;\n    }\n\n    if (cmp(key[i], lwrKeyChar) < 0) llp = i;\n  }\n\n  if (length < lowerNeedle.length && dir === \"next\") return key + upperNeedle.substr(key.length);\n  if (length < key.length && dir === \"prev\") return key.substr(0, upperNeedle.length);\n  return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);\n}\n\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n  var upper,\n      lower,\n      compare,\n      upperNeedles,\n      lowerNeedles,\n      direction,\n      nextKeySuffix,\n      needlesLen = needles.length;\n\n  if (!needles.every(s => typeof s === 'string')) {\n    return fail(whereClause, STRING_EXPECTED);\n  }\n\n  function initDirection(dir) {\n    upper = upperFactory(dir);\n    lower = lowerFactory(dir);\n    compare = dir === \"next\" ? simpleCompare : simpleCompareReverse;\n    var needleBounds = needles.map(function (needle) {\n      return {\n        lower: lower(needle),\n        upper: upper(needle)\n      };\n    }).sort(function (a, b) {\n      return compare(a.lower, b.lower);\n    });\n    upperNeedles = needleBounds.map(function (nb) {\n      return nb.upper;\n    });\n    lowerNeedles = needleBounds.map(function (nb) {\n      return nb.lower;\n    });\n    direction = dir;\n    nextKeySuffix = dir === \"next\" ? \"\" : suffix;\n  }\n\n  initDirection(\"next\");\n  var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n\n  c._ondirectionchange = function (direction) {\n    initDirection(direction);\n  };\n\n  var firstPossibleNeedle = 0;\n\n  c._addAlgorithm(function (cursor, advance, resolve) {\n    var key = cursor.key;\n    if (typeof key !== 'string') return false;\n    var lowerKey = lower(key);\n\n    if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n      return true;\n    } else {\n      var lowestPossibleCasing = null;\n\n      for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n        if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n          lowestPossibleCasing = casing;\n        }\n      }\n\n      if (lowestPossibleCasing !== null) {\n        advance(function () {\n          cursor.continue(lowestPossibleCasing + nextKeySuffix);\n        });\n      } else {\n        advance(resolve);\n      }\n\n      return false;\n    }\n  });\n\n  return c;\n}\n\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n  return {\n    type: 2,\n    lower,\n    upper,\n    lowerOpen,\n    upperOpen\n  };\n}\n\nfunction rangeEqual(value) {\n  return {\n    type: 1,\n    lower: value,\n    upper: value\n  };\n}\n\nclass WhereClause {\n  get Collection() {\n    return this._ctx.table.db.Collection;\n  }\n\n  between(lower, upper, includeLower, includeUpper) {\n    includeLower = includeLower !== false;\n    includeUpper = includeUpper === true;\n\n    try {\n      if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this);\n      return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));\n    } catch (e) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n  }\n\n  equals(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => rangeEqual(value));\n  }\n\n  above(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(value, undefined, true));\n  }\n\n  aboveOrEqual(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(value, undefined, false));\n  }\n\n  below(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(undefined, value, false, true));\n  }\n\n  belowOrEqual(value) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(undefined, value));\n  }\n\n  startsWith(str) {\n    if (typeof str !== 'string') return fail(this, STRING_EXPECTED);\n    return this.between(str, str + maxString, true, true);\n  }\n\n  startsWithIgnoreCase(str) {\n    if (str === \"\") return this.startsWith(str);\n    return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n  }\n\n  equalsIgnoreCase(str) {\n    return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n  }\n\n  anyOfIgnoreCase() {\n    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    if (set.length === 0) return emptyCollection(this);\n    return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n  }\n\n  startsWithAnyOfIgnoreCase() {\n    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    if (set.length === 0) return emptyCollection(this);\n    return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n  }\n\n  anyOf() {\n    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    let compare = this._cmp;\n\n    try {\n      set.sort(compare);\n    } catch (e) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n\n    if (set.length === 0) return emptyCollection(this);\n    const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n\n    c._ondirectionchange = direction => {\n      compare = direction === \"next\" ? this._ascending : this._descending;\n      set.sort(compare);\n    };\n\n    let i = 0;\n\n    c._addAlgorithm((cursor, advance, resolve) => {\n      const key = cursor.key;\n\n      while (compare(key, set[i]) > 0) {\n        ++i;\n\n        if (i === set.length) {\n          advance(resolve);\n          return false;\n        }\n      }\n\n      if (compare(key, set[i]) === 0) {\n        return true;\n      } else {\n        advance(() => {\n          cursor.continue(set[i]);\n        });\n        return false;\n      }\n    });\n\n    return c;\n  }\n\n  notEqual(value) {\n    return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], {\n      includeLowers: false,\n      includeUppers: false\n    });\n  }\n\n  noneOf() {\n    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    if (set.length === 0) return new this.Collection(this);\n\n    try {\n      set.sort(this._ascending);\n    } catch (e) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n\n    const ranges = set.reduce((res, val) => res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]], null);\n    ranges.push([set[set.length - 1], this.db._maxKey]);\n    return this.inAnyRange(ranges, {\n      includeLowers: false,\n      includeUppers: false\n    });\n  }\n\n  inAnyRange(ranges, options) {\n    const cmp = this._cmp,\n          ascending = this._ascending,\n          descending = this._descending,\n          min = this._min,\n          max = this._max;\n    if (ranges.length === 0) return emptyCollection(this);\n\n    if (!ranges.every(range => range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0)) {\n      return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n    }\n\n    const includeLowers = !options || options.includeLowers !== false;\n    const includeUppers = options && options.includeUppers === true;\n\n    function addRange(ranges, newRange) {\n      let i = 0,\n          l = ranges.length;\n\n      for (; i < l; ++i) {\n        const range = ranges[i];\n\n        if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n          range[0] = min(range[0], newRange[0]);\n          range[1] = max(range[1], newRange[1]);\n          break;\n        }\n      }\n\n      if (i === l) ranges.push(newRange);\n      return ranges;\n    }\n\n    let sortDirection = ascending;\n\n    function rangeSorter(a, b) {\n      return sortDirection(a[0], b[0]);\n    }\n\n    let set;\n\n    try {\n      set = ranges.reduce(addRange, []);\n      set.sort(rangeSorter);\n    } catch (ex) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n\n    let rangePos = 0;\n    const keyIsBeyondCurrentEntry = includeUppers ? key => ascending(key, set[rangePos][1]) > 0 : key => ascending(key, set[rangePos][1]) >= 0;\n    const keyIsBeforeCurrentEntry = includeLowers ? key => descending(key, set[rangePos][0]) > 0 : key => descending(key, set[rangePos][0]) >= 0;\n\n    function keyWithinCurrentRange(key) {\n      return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n    }\n\n    let checkKey = keyIsBeyondCurrentEntry;\n    const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n\n    c._ondirectionchange = direction => {\n      if (direction === \"next\") {\n        checkKey = keyIsBeyondCurrentEntry;\n        sortDirection = ascending;\n      } else {\n        checkKey = keyIsBeforeCurrentEntry;\n        sortDirection = descending;\n      }\n\n      set.sort(rangeSorter);\n    };\n\n    c._addAlgorithm((cursor, advance, resolve) => {\n      var key = cursor.key;\n\n      while (checkKey(key)) {\n        ++rangePos;\n\n        if (rangePos === set.length) {\n          advance(resolve);\n          return false;\n        }\n      }\n\n      if (keyWithinCurrentRange(key)) {\n        return true;\n      } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n        return false;\n      } else {\n        advance(() => {\n          if (sortDirection === ascending) cursor.continue(set[rangePos][0]);else cursor.continue(set[rangePos][1]);\n        });\n        return false;\n      }\n    });\n\n    return c;\n  }\n\n  startsWithAnyOf() {\n    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\n    if (!set.every(s => typeof s === 'string')) {\n      return fail(this, \"startsWithAnyOf() only works with strings\");\n    }\n\n    if (set.length === 0) return emptyCollection(this);\n    return this.inAnyRange(set.map(str => [str, str + maxString]));\n  }\n\n}\n\nfunction createWhereClauseConstructor(db) {\n  return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n    this.db = db;\n    this._ctx = {\n      table: table,\n      index: index === \":id\" ? null : index,\n      or: orCollection\n    };\n    const indexedDB = db._deps.indexedDB;\n    if (!indexedDB) throw new exceptions.MissingAPI();\n    this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n\n    this._descending = (a, b) => indexedDB.cmp(b, a);\n\n    this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;\n\n    this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;\n\n    this._IDBKeyRange = db._deps.IDBKeyRange;\n  });\n}\n\nfunction eventRejectHandler(reject) {\n  return wrap(function (event) {\n    preventDefault(event);\n    reject(event.target.error);\n    return false;\n  });\n}\n\nfunction preventDefault(event) {\n  if (event.stopPropagation) event.stopPropagation();\n  if (event.preventDefault) event.preventDefault();\n}\n\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nconst STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nclass Transaction {\n  _lock() {\n    assert(!PSD.global);\n    ++this._reculock;\n    if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;\n    return this;\n  }\n\n  _unlock() {\n    assert(!PSD.global);\n\n    if (--this._reculock === 0) {\n      if (!PSD.global) PSD.lockOwnerFor = null;\n\n      while (this._blockedFuncs.length > 0 && !this._locked()) {\n        var fnAndPSD = this._blockedFuncs.shift();\n\n        try {\n          usePSD(fnAndPSD[1], fnAndPSD[0]);\n        } catch (e) {}\n      }\n    }\n\n    return this;\n  }\n\n  _locked() {\n    return this._reculock && PSD.lockOwnerFor !== this;\n  }\n\n  create(idbtrans) {\n    if (!this.mode) return this;\n    const idbdb = this.db.idbdb;\n    const dbOpenError = this.db._state.dbOpenError;\n    assert(!this.idbtrans);\n\n    if (!idbtrans && !idbdb) {\n      switch (dbOpenError && dbOpenError.name) {\n        case \"DatabaseClosedError\":\n          throw new exceptions.DatabaseClosed(dbOpenError);\n\n        case \"MissingAPIError\":\n          throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n\n        default:\n          throw new exceptions.OpenFailed(dbOpenError);\n      }\n    }\n\n    if (!this.active) throw new exceptions.TransactionInactive();\n    assert(this._completion._state === null);\n    idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {\n      durability: this.chromeTransactionDurability\n    }) : idbdb.transaction(this.storeNames, this.mode, {\n      durability: this.chromeTransactionDurability\n    }));\n    idbtrans.onerror = wrap(ev => {\n      preventDefault(ev);\n\n      this._reject(idbtrans.error);\n    });\n    idbtrans.onabort = wrap(ev => {\n      preventDefault(ev);\n      this.active && this._reject(new exceptions.Abort(idbtrans.error));\n      this.active = false;\n      this.on(\"abort\").fire(ev);\n    });\n    idbtrans.oncomplete = wrap(() => {\n      this.active = false;\n\n      this._resolve();\n\n      if ('mutatedParts' in idbtrans) {\n        globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n      }\n    });\n    return this;\n  }\n\n  _promise(mode, fn, bWriteLock) {\n    if (mode === 'readwrite' && this.mode !== 'readwrite') return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n    if (!this.active) return rejection(new exceptions.TransactionInactive());\n\n    if (this._locked()) {\n      return new DexiePromise((resolve, reject) => {\n        this._blockedFuncs.push([() => {\n          this._promise(mode, fn, bWriteLock).then(resolve, reject);\n        }, PSD]);\n      });\n    } else if (bWriteLock) {\n      return newScope(() => {\n        var p = new DexiePromise((resolve, reject) => {\n          this._lock();\n\n          const rv = fn(resolve, reject, this);\n          if (rv && rv.then) rv.then(resolve, reject);\n        });\n        p.finally(() => this._unlock());\n        p._lib = true;\n        return p;\n      });\n    } else {\n      var p = new DexiePromise((resolve, reject) => {\n        var rv = fn(resolve, reject, this);\n        if (rv && rv.then) rv.then(resolve, reject);\n      });\n      p._lib = true;\n      return p;\n    }\n  }\n\n  _root() {\n    return this.parent ? this.parent._root() : this;\n  }\n\n  waitFor(promiseLike) {\n    var root = this._root();\n\n    const promise = DexiePromise.resolve(promiseLike);\n\n    if (root._waitingFor) {\n      root._waitingFor = root._waitingFor.then(() => promise);\n    } else {\n      root._waitingFor = promise;\n      root._waitingQueue = [];\n      var store = root.idbtrans.objectStore(root.storeNames[0]);\n\n      (function spin() {\n        ++root._spinCount;\n\n        while (root._waitingQueue.length) root._waitingQueue.shift()();\n\n        if (root._waitingFor) store.get(-Infinity).onsuccess = spin;\n      })();\n    }\n\n    var currentWaitPromise = root._waitingFor;\n    return new DexiePromise((resolve, reject) => {\n      promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {\n        if (root._waitingFor === currentWaitPromise) {\n          root._waitingFor = null;\n        }\n      });\n    });\n  }\n\n  abort() {\n    if (this.active) {\n      this.active = false;\n      if (this.idbtrans) this.idbtrans.abort();\n\n      this._reject(new exceptions.Abort());\n    }\n  }\n\n  table(tableName) {\n    const memoizedTables = this._memoizedTables || (this._memoizedTables = {});\n    if (hasOwn(memoizedTables, tableName)) return memoizedTables[tableName];\n    const tableSchema = this.schema[tableName];\n\n    if (!tableSchema) {\n      throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n    }\n\n    const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n    transactionBoundTable.core = this.db.core.table(tableName);\n    memoizedTables[tableName] = transactionBoundTable;\n    return transactionBoundTable;\n  }\n\n}\n\nfunction createTransactionConstructor(db) {\n  return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n    this.db = db;\n    this.mode = mode;\n    this.storeNames = storeNames;\n    this.schema = dbschema;\n    this.chromeTransactionDurability = chromeTransactionDurability;\n    this.idbtrans = null;\n    this.on = Events(this, \"complete\", \"error\", \"abort\");\n    this.parent = parent || null;\n    this.active = true;\n    this._reculock = 0;\n    this._blockedFuncs = [];\n    this._resolve = null;\n    this._reject = null;\n    this._waitingFor = null;\n    this._waitingQueue = null;\n    this._spinCount = 0;\n    this._completion = new DexiePromise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n\n    this._completion.then(() => {\n      this.active = false;\n      this.on.complete.fire();\n    }, e => {\n      var wasActive = this.active;\n      this.active = false;\n      this.on.error.fire(e);\n      this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();\n      return rejection(e);\n    });\n  });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n  return {\n    name,\n    keyPath,\n    unique,\n    multi,\n    auto,\n    compound,\n    src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n  };\n}\n\nfunction nameFromKeyPath(keyPath) {\n  return typeof keyPath === 'string' ? keyPath : keyPath ? '[' + [].join.call(keyPath, '+') + ']' : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n  return {\n    name,\n    primKey,\n    indexes,\n    mappedClass: null,\n    idxByName: arrayToObject(indexes, index => [index.name, index])\n  };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n  return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\n\nlet getMaxKey = IdbKeyRange => {\n  try {\n    IdbKeyRange.only([[]]);\n\n    getMaxKey = () => [[]];\n\n    return [[]];\n  } catch (e) {\n    getMaxKey = () => maxString;\n\n    return maxString;\n  }\n};\n\nfunction getKeyExtractor(keyPath) {\n  if (keyPath == null) {\n    return () => undefined;\n  } else if (typeof keyPath === 'string') {\n    return getSinglePathKeyExtractor(keyPath);\n  } else {\n    return obj => getByKeyPath(obj, keyPath);\n  }\n}\n\nfunction getSinglePathKeyExtractor(keyPath) {\n  const split = keyPath.split('.');\n\n  if (split.length === 1) {\n    return obj => obj[keyPath];\n  } else {\n    return obj => getByKeyPath(obj, keyPath);\n  }\n}\n\nfunction arrayify(arrayLike) {\n  return [].slice.call(arrayLike);\n}\n\nlet _id_counter = 0;\n\nfunction getKeyPathAlias(keyPath) {\n  return keyPath == null ? \":id\" : typeof keyPath === 'string' ? keyPath : `[${keyPath.join('+')}]`;\n}\n\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n  function extractSchema(db, trans) {\n    const tables = arrayify(db.objectStoreNames);\n    return {\n      schema: {\n        name: db.name,\n        tables: tables.map(table => trans.objectStore(table)).map(store => {\n          const {\n            keyPath,\n            autoIncrement\n          } = store;\n          const compound = isArray(keyPath);\n          const outbound = keyPath == null;\n          const indexByKeyPath = {};\n          const result = {\n            name: store.name,\n            primaryKey: {\n              name: null,\n              isPrimaryKey: true,\n              outbound,\n              compound,\n              keyPath,\n              autoIncrement,\n              unique: true,\n              extractKey: getKeyExtractor(keyPath)\n            },\n            indexes: arrayify(store.indexNames).map(indexName => store.index(indexName)).map(index => {\n              const {\n                name,\n                unique,\n                multiEntry,\n                keyPath\n              } = index;\n              const compound = isArray(keyPath);\n              const result = {\n                name,\n                compound,\n                keyPath,\n                unique,\n                multiEntry,\n                extractKey: getKeyExtractor(keyPath)\n              };\n              indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n              return result;\n            }),\n            getIndexByKeyPath: keyPath => indexByKeyPath[getKeyPathAlias(keyPath)]\n          };\n          indexByKeyPath[\":id\"] = result.primaryKey;\n\n          if (keyPath != null) {\n            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n          }\n\n          return result;\n        })\n      },\n      hasGetAll: tables.length > 0 && 'getAll' in trans.objectStore(tables[0]) && !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n    };\n  }\n\n  function makeIDBKeyRange(range) {\n    if (range.type === 3) return null;\n    if (range.type === 4) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n    const {\n      lower,\n      upper,\n      lowerOpen,\n      upperOpen\n    } = range;\n    const idbRange = lower === undefined ? upper === undefined ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === undefined ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n    return idbRange;\n  }\n\n  function createDbCoreTable(tableSchema) {\n    const tableName = tableSchema.name;\n\n    function mutate({\n      trans,\n      type,\n      keys,\n      values,\n      range\n    }) {\n      return new Promise((resolve, reject) => {\n        resolve = wrap(resolve);\n        const store = trans.objectStore(tableName);\n        const outbound = store.keyPath == null;\n        const isAddOrPut = type === \"put\" || type === \"add\";\n        if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange') throw new Error(\"Invalid operation type: \" + type);\n        const {\n          length\n        } = keys || values || {\n          length: 1\n        };\n\n        if (keys && values && keys.length !== values.length) {\n          throw new Error(\"Given keys array must have same length as given values array.\");\n        }\n\n        if (length === 0) return resolve({\n          numFailures: 0,\n          failures: {},\n          results: [],\n          lastResult: undefined\n        });\n        let req;\n        const reqs = [];\n        const failures = [];\n        let numFailures = 0;\n\n        const errorHandler = event => {\n          ++numFailures;\n          preventDefault(event);\n        };\n\n        if (type === 'deleteRange') {\n          if (range.type === 4) return resolve({\n            numFailures,\n            failures,\n            results: [],\n            lastResult: undefined\n          });\n          if (range.type === 3) reqs.push(req = store.clear());else reqs.push(req = store.delete(makeIDBKeyRange(range)));\n        } else {\n          const [args1, args2] = isAddOrPut ? outbound ? [values, keys] : [values, null] : [keys, null];\n\n          if (isAddOrPut) {\n            for (let i = 0; i < length; ++i) {\n              reqs.push(req = args2 && args2[i] !== undefined ? store[type](args1[i], args2[i]) : store[type](args1[i]));\n              req.onerror = errorHandler;\n            }\n          } else {\n            for (let i = 0; i < length; ++i) {\n              reqs.push(req = store[type](args1[i]));\n              req.onerror = errorHandler;\n            }\n          }\n        }\n\n        const done = event => {\n          const lastResult = event.target.result;\n          reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));\n          resolve({\n            numFailures,\n            failures,\n            results: type === \"delete\" ? keys : reqs.map(req => req.result),\n            lastResult\n          });\n        };\n\n        req.onerror = event => {\n          errorHandler(event);\n          done(event);\n        };\n\n        req.onsuccess = done;\n      });\n    }\n\n    function openCursor({\n      trans,\n      values,\n      query,\n      reverse,\n      unique\n    }) {\n      return new Promise((resolve, reject) => {\n        resolve = wrap(resolve);\n        const {\n          index,\n          range\n        } = query;\n        const store = trans.objectStore(tableName);\n        const source = index.isPrimaryKey ? store : store.index(index.name);\n        const direction = reverse ? unique ? \"prevunique\" : \"prev\" : unique ? \"nextunique\" : \"next\";\n        const req = values || !('openKeyCursor' in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);\n        req.onerror = eventRejectHandler(reject);\n        req.onsuccess = wrap(ev => {\n          const cursor = req.result;\n\n          if (!cursor) {\n            resolve(null);\n            return;\n          }\n\n          cursor.___id = ++_id_counter;\n          cursor.done = false;\n\n          const _cursorContinue = cursor.continue.bind(cursor);\n\n          let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n          if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n\n          const _cursorAdvance = cursor.advance.bind(cursor);\n\n          const doThrowCursorIsNotStarted = () => {\n            throw new Error(\"Cursor not started\");\n          };\n\n          const doThrowCursorIsStopped = () => {\n            throw new Error(\"Cursor not stopped\");\n          };\n\n          cursor.trans = trans;\n          cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n          cursor.fail = wrap(reject);\n\n          cursor.next = function () {\n            let gotOne = 1;\n            return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n          };\n\n          cursor.start = callback => {\n            const iterationPromise = new Promise((resolveIteration, rejectIteration) => {\n              resolveIteration = wrap(resolveIteration);\n              req.onerror = eventRejectHandler(rejectIteration);\n              cursor.fail = rejectIteration;\n\n              cursor.stop = value => {\n                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                resolveIteration(value);\n              };\n            });\n\n            const guardedCallback = () => {\n              if (req.result) {\n                try {\n                  callback();\n                } catch (err) {\n                  cursor.fail(err);\n                }\n              } else {\n                cursor.done = true;\n\n                cursor.start = () => {\n                  throw new Error(\"Cursor behind last entry\");\n                };\n\n                cursor.stop();\n              }\n            };\n\n            req.onsuccess = wrap(ev => {\n              req.onsuccess = guardedCallback;\n              guardedCallback();\n            });\n            cursor.continue = _cursorContinue;\n            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n            cursor.advance = _cursorAdvance;\n            guardedCallback();\n            return iterationPromise;\n          };\n\n          resolve(cursor);\n        }, reject);\n      });\n    }\n\n    function query(hasGetAll) {\n      return request => {\n        return new Promise((resolve, reject) => {\n          resolve = wrap(resolve);\n          const {\n            trans,\n            values,\n            limit,\n            query\n          } = request;\n          const nonInfinitLimit = limit === Infinity ? undefined : limit;\n          const {\n            index,\n            range\n          } = query;\n          const store = trans.objectStore(tableName);\n          const source = index.isPrimaryKey ? store : store.index(index.name);\n          const idbKeyRange = makeIDBKeyRange(range);\n          if (limit === 0) return resolve({\n            result: []\n          });\n\n          if (hasGetAll) {\n            const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);\n\n            req.onsuccess = event => resolve({\n              result: event.target.result\n            });\n\n            req.onerror = eventRejectHandler(reject);\n          } else {\n            let count = 0;\n            const req = values || !('openKeyCursor' in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);\n            const result = [];\n\n            req.onsuccess = event => {\n              const cursor = req.result;\n              if (!cursor) return resolve({\n                result\n              });\n              result.push(values ? cursor.value : cursor.primaryKey);\n              if (++count === limit) return resolve({\n                result\n              });\n              cursor.continue();\n            };\n\n            req.onerror = eventRejectHandler(reject);\n          }\n        });\n      };\n    }\n\n    return {\n      name: tableName,\n      schema: tableSchema,\n      mutate,\n\n      getMany({\n        trans,\n        keys\n      }) {\n        return new Promise((resolve, reject) => {\n          resolve = wrap(resolve);\n          const store = trans.objectStore(tableName);\n          const length = keys.length;\n          const result = new Array(length);\n          let keyCount = 0;\n          let callbackCount = 0;\n          let req;\n\n          const successHandler = event => {\n            const req = event.target;\n            if ((result[req._pos] = req.result) != null) ;\n            if (++callbackCount === keyCount) resolve(result);\n          };\n\n          const errorHandler = eventRejectHandler(reject);\n\n          for (let i = 0; i < length; ++i) {\n            const key = keys[i];\n\n            if (key != null) {\n              req = store.get(keys[i]);\n              req._pos = i;\n              req.onsuccess = successHandler;\n              req.onerror = errorHandler;\n              ++keyCount;\n            }\n          }\n\n          if (keyCount === 0) resolve(result);\n        });\n      },\n\n      get({\n        trans,\n        key\n      }) {\n        return new Promise((resolve, reject) => {\n          resolve = wrap(resolve);\n          const store = trans.objectStore(tableName);\n          const req = store.get(key);\n\n          req.onsuccess = event => resolve(event.target.result);\n\n          req.onerror = eventRejectHandler(reject);\n        });\n      },\n\n      query: query(hasGetAll),\n      openCursor,\n\n      count({\n        query,\n        trans\n      }) {\n        const {\n          index,\n          range\n        } = query;\n        return new Promise((resolve, reject) => {\n          const store = trans.objectStore(tableName);\n          const source = index.isPrimaryKey ? store : store.index(index.name);\n          const idbKeyRange = makeIDBKeyRange(range);\n          const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n          req.onsuccess = wrap(ev => resolve(ev.target.result));\n          req.onerror = eventRejectHandler(reject);\n        });\n      }\n\n    };\n  }\n\n  const {\n    schema,\n    hasGetAll\n  } = extractSchema(db, tmpTrans);\n  const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n  const tableMap = {};\n  tables.forEach(table => tableMap[table.name] = table);\n  return {\n    stack: \"dbcore\",\n    transaction: db.transaction.bind(db),\n\n    table(name) {\n      const result = tableMap[name];\n      if (!result) throw new Error(`Table '${name}' not found`);\n      return tableMap[name];\n    },\n\n    MIN_KEY: -Infinity,\n    MAX_KEY: getMaxKey(IdbKeyRange),\n    schema\n  };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n  return middlewares.reduce((down, {\n    create\n  }) => ({ ...down,\n    ...create(down)\n  }), stackImpl);\n}\n\nfunction createMiddlewareStacks(middlewares, idbdb, {\n  IDBKeyRange,\n  indexedDB\n}, tmpTrans) {\n  const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n  return {\n    dbcore\n  };\n}\n\nfunction generateMiddlewareStacks({\n  _novip: db\n}, tmpTrans) {\n  const idbdb = tmpTrans.db;\n  const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n  db.core = stacks.dbcore;\n  db.tables.forEach(table => {\n    const tableName = table.name;\n\n    if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n      table.core = db.core.table(tableName);\n\n      if (db[tableName] instanceof db.Table) {\n        db[tableName].core = table.core;\n      }\n    }\n  });\n}\n\nfunction setApiOnPlace({\n  _novip: db\n}, objs, tableNames, dbschema) {\n  tableNames.forEach(tableName => {\n    const schema = dbschema[tableName];\n    objs.forEach(obj => {\n      const propDesc = getPropertyDescriptor(obj, tableName);\n\n      if (!propDesc || \"value\" in propDesc && propDesc.value === undefined) {\n        if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n          setProp(obj, tableName, {\n            get() {\n              return this.table(tableName);\n            },\n\n            set(value) {\n              defineProperty(this, tableName, {\n                value,\n                writable: true,\n                configurable: true,\n                enumerable: true\n              });\n            }\n\n          });\n        } else {\n          obj[tableName] = new db.Table(tableName, schema);\n        }\n      }\n    });\n  });\n}\n\nfunction removeTablesApi({\n  _novip: db\n}, objs) {\n  objs.forEach(obj => {\n    for (let key in obj) {\n      if (obj[key] instanceof db.Table) delete obj[key];\n    }\n  });\n}\n\nfunction lowerVersionFirst(a, b) {\n  return a._cfg.version - b._cfg.version;\n}\n\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n  const globalSchema = db._dbSchema;\n\n  const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n\n  trans.create(idbUpgradeTrans);\n\n  trans._completion.catch(reject);\n\n  const rejectTransaction = trans._reject.bind(trans);\n\n  const transless = PSD.transless || PSD;\n  newScope(() => {\n    PSD.trans = trans;\n    PSD.transless = transless;\n\n    if (oldVersion === 0) {\n      keys(globalSchema).forEach(tableName => {\n        createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n      });\n      generateMiddlewareStacks(db, idbUpgradeTrans);\n      DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n    } else updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n  });\n}\n\nfunction updateTablesAndIndexes({\n  _novip: db\n}, oldVersion, trans, idbUpgradeTrans) {\n  const queue = [];\n  const versions = db._versions;\n  let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n  let anyContentUpgraderHasRun = false;\n  const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n  versToRun.forEach(version => {\n    queue.push(() => {\n      const oldSchema = globalSchema;\n      const newSchema = version._cfg.dbschema;\n      adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n      adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n      globalSchema = db._dbSchema = newSchema;\n      const diff = getSchemaDiff(oldSchema, newSchema);\n      diff.add.forEach(tuple => {\n        createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n      });\n      diff.change.forEach(change => {\n        if (change.recreate) {\n          throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n        } else {\n          const store = idbUpgradeTrans.objectStore(change.name);\n          change.add.forEach(idx => addIndex(store, idx));\n          change.change.forEach(idx => {\n            store.deleteIndex(idx.name);\n            addIndex(store, idx);\n          });\n          change.del.forEach(idxName => store.deleteIndex(idxName));\n        }\n      });\n      const contentUpgrade = version._cfg.contentUpgrade;\n\n      if (contentUpgrade && version._cfg.version > oldVersion) {\n        generateMiddlewareStacks(db, idbUpgradeTrans);\n        trans._memoizedTables = {};\n        anyContentUpgraderHasRun = true;\n        let upgradeSchema = shallowClone(newSchema);\n        diff.del.forEach(table => {\n          upgradeSchema[table] = oldSchema[table];\n        });\n        removeTablesApi(db, [db.Transaction.prototype]);\n        setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n        trans.schema = upgradeSchema;\n        const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n\n        if (contentUpgradeIsAsync) {\n          incrementExpectedAwaits();\n        }\n\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(() => {\n          returnValue = contentUpgrade(trans);\n\n          if (returnValue) {\n            if (contentUpgradeIsAsync) {\n              var decrementor = decrementExpectedAwaits.bind(null, null);\n              returnValue.then(decrementor, decrementor);\n            }\n          }\n        });\n        return returnValue && typeof returnValue.then === 'function' ? DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue);\n      }\n    });\n    queue.push(idbtrans => {\n      if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n        const newSchema = version._cfg.dbschema;\n        deleteRemovedTables(newSchema, idbtrans);\n      }\n\n      removeTablesApi(db, [db.Transaction.prototype]);\n      setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n      trans.schema = db._dbSchema;\n    });\n  });\n\n  function runQueue() {\n    return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();\n  }\n\n  return runQueue().then(() => {\n    createMissingTables(globalSchema, idbUpgradeTrans);\n  });\n}\n\nfunction getSchemaDiff(oldSchema, newSchema) {\n  const diff = {\n    del: [],\n    add: [],\n    change: []\n  };\n  let table;\n\n  for (table in oldSchema) {\n    if (!newSchema[table]) diff.del.push(table);\n  }\n\n  for (table in newSchema) {\n    const oldDef = oldSchema[table],\n          newDef = newSchema[table];\n\n    if (!oldDef) {\n      diff.add.push([table, newDef]);\n    } else {\n      const change = {\n        name: table,\n        def: newDef,\n        recreate: false,\n        del: [],\n        add: [],\n        change: []\n      };\n\n      if ('' + (oldDef.primKey.keyPath || '') !== '' + (newDef.primKey.keyPath || '') || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {\n        change.recreate = true;\n        diff.change.push(change);\n      } else {\n        const oldIndexes = oldDef.idxByName;\n        const newIndexes = newDef.idxByName;\n        let idxName;\n\n        for (idxName in oldIndexes) {\n          if (!newIndexes[idxName]) change.del.push(idxName);\n        }\n\n        for (idxName in newIndexes) {\n          const oldIdx = oldIndexes[idxName],\n                newIdx = newIndexes[idxName];\n          if (!oldIdx) change.add.push(newIdx);else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);\n        }\n\n        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n          diff.change.push(change);\n        }\n      }\n    }\n  }\n\n  return diff;\n}\n\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n  const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {\n    keyPath: primKey.keyPath,\n    autoIncrement: primKey.auto\n  } : {\n    autoIncrement: primKey.auto\n  });\n  indexes.forEach(idx => addIndex(store, idx));\n  return store;\n}\n\nfunction createMissingTables(newSchema, idbtrans) {\n  keys(newSchema).forEach(tableName => {\n    if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n      createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n    }\n  });\n}\n\nfunction deleteRemovedTables(newSchema, idbtrans) {\n  [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\n\nfunction addIndex(store, idx) {\n  store.createIndex(idx.name, idx.keyPath, {\n    unique: idx.unique,\n    multiEntry: idx.multi\n  });\n}\n\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n  const globalSchema = {};\n  const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n  dbStoreNames.forEach(storeName => {\n    const store = tmpTrans.objectStore(storeName);\n    let keyPath = store.keyPath;\n    const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n    const indexes = [];\n\n    for (let j = 0; j < store.indexNames.length; ++j) {\n      const idbindex = store.index(store.indexNames[j]);\n      keyPath = idbindex.keyPath;\n      var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n      indexes.push(index);\n    }\n\n    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n  });\n  return globalSchema;\n}\n\nfunction readGlobalSchema({\n  _novip: db\n}, idbdb, tmpTrans) {\n  db.verno = idbdb.version / 10;\n  const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n  db._storeNames = slice(idbdb.objectStoreNames, 0);\n  setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\n\nfunction verifyInstalledSchema(db, tmpTrans) {\n  const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n  const diff = getSchemaDiff(installedSchema, db._dbSchema);\n  return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\n\nfunction adjustToExistingIndexNames({\n  _novip: db\n}, schema, idbtrans) {\n  const storeNames = idbtrans.db.objectStoreNames;\n\n  for (let i = 0; i < storeNames.length; ++i) {\n    const storeName = storeNames[i];\n    const store = idbtrans.objectStore(storeName);\n    db._hasGetAll = 'getAll' in store;\n\n    for (let j = 0; j < store.indexNames.length; ++j) {\n      const indexName = store.indexNames[j];\n      const keyPath = store.index(indexName).keyPath;\n      const dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n\n      if (schema[storeName]) {\n        const indexSpec = schema[storeName].idxByName[dexieName];\n\n        if (indexSpec) {\n          indexSpec.name = indexName;\n          delete schema[storeName].idxByName[dexieName];\n          schema[storeName].idxByName[indexName] = indexSpec;\n        }\n      }\n    }\n  }\n\n  if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n    db._hasGetAll = false;\n  }\n}\n\nfunction parseIndexSyntax(primKeyAndIndexes) {\n  return primKeyAndIndexes.split(',').map((index, indexNum) => {\n    index = index.trim();\n    const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n    const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n    return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n  });\n}\n\nclass Version {\n  _parseStoresSpec(stores, outSchema) {\n    keys(stores).forEach(tableName => {\n      if (stores[tableName] !== null) {\n        var indexes = parseIndexSyntax(stores[tableName]);\n        var primKey = indexes.shift();\n        if (primKey.multi) throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n        indexes.forEach(idx => {\n          if (idx.auto) throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n          if (!idx.keyPath) throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n        });\n        outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n      }\n    });\n  }\n\n  stores(stores) {\n    const db = this.db;\n    this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;\n    const versions = db._versions;\n    const storesSpec = {};\n    let dbschema = {};\n    versions.forEach(version => {\n      extend(storesSpec, version._cfg.storesSource);\n      dbschema = version._cfg.dbschema = {};\n\n      version._parseStoresSpec(storesSpec, dbschema);\n    });\n    db._dbSchema = dbschema;\n    removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n    setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n    db._storeNames = keys(dbschema);\n    return this;\n  }\n\n  upgrade(upgradeFunction) {\n    this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n    return this;\n  }\n\n}\n\nfunction createVersionConstructor(db) {\n  return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n    this.db = db;\n    this._cfg = {\n      version: versionNumber,\n      storesSource: null,\n      dbschema: {},\n      tables: {},\n      contentUpgrade: null\n    };\n  });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n  let dbNamesDB = indexedDB[\"_dbNamesDB\"];\n\n  if (!dbNamesDB) {\n    dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n      addons: [],\n      indexedDB,\n      IDBKeyRange\n    });\n    dbNamesDB.version(1).stores({\n      dbnames: \"name\"\n    });\n  }\n\n  return dbNamesDB.table(\"dbnames\");\n}\n\nfunction hasDatabasesNative(indexedDB) {\n  return indexedDB && typeof indexedDB.databases === \"function\";\n}\n\nfunction getDatabaseNames({\n  indexedDB,\n  IDBKeyRange\n}) {\n  return hasDatabasesNative(indexedDB) ? Promise.resolve(indexedDB.databases()).then(infos => infos.map(info => info.name).filter(name => name !== DBNAMES_DB)) : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\n\nfunction _onDatabaseCreated({\n  indexedDB,\n  IDBKeyRange\n}, name) {\n  !hasDatabasesNative(indexedDB) && name !== DBNAMES_DB && getDbNamesTable(indexedDB, IDBKeyRange).put({\n    name\n  }).catch(nop);\n}\n\nfunction _onDatabaseDeleted({\n  indexedDB,\n  IDBKeyRange\n}, name) {\n  !hasDatabasesNative(indexedDB) && name !== DBNAMES_DB && getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n  return newScope(function () {\n    PSD.letThrough = true;\n    return fn();\n  });\n}\n\nfunction idbReady() {\n  var isSafari = !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent);\n  if (!isSafari || !indexedDB.databases) return Promise.resolve();\n  var intervalId;\n  return new Promise(function (resolve) {\n    var tryIdb = function () {\n      return indexedDB.databases().finally(resolve);\n    };\n\n    intervalId = setInterval(tryIdb, 100);\n    tryIdb();\n  }).finally(function () {\n    return clearInterval(intervalId);\n  });\n}\n\nfunction dexieOpen(db) {\n  const state = db._state;\n  const {\n    indexedDB\n  } = db._deps;\n  if (state.isBeingOpened || db.idbdb) return state.dbReadyPromise.then(() => state.dbOpenError ? rejection(state.dbOpenError) : db);\n  debug && (state.openCanceller._stackHolder = getErrorWithStack());\n  state.isBeingOpened = true;\n  state.dbOpenError = null;\n  state.openComplete = false;\n  const openCanceller = state.openCanceller;\n\n  function throwIfCancelled() {\n    if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed('db.open() was cancelled');\n  }\n\n  let resolveDbReady = state.dbReadyResolve,\n      upgradeTransaction = null,\n      wasCreated = false;\n  return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {\n    throwIfCancelled();\n    if (!indexedDB) throw new exceptions.MissingAPI();\n    const dbName = db.name;\n    const req = state.autoSchema ? indexedDB.open(dbName) : indexedDB.open(dbName, Math.round(db.verno * 10));\n    if (!req) throw new exceptions.MissingAPI();\n    req.onerror = eventRejectHandler(reject);\n    req.onblocked = wrap(db._fireOnBlocked);\n    req.onupgradeneeded = wrap(e => {\n      upgradeTransaction = req.transaction;\n\n      if (state.autoSchema && !db._options.allowEmptyDB) {\n        req.onerror = preventDefault;\n        upgradeTransaction.abort();\n        req.result.close();\n        const delreq = indexedDB.deleteDatabase(dbName);\n        delreq.onsuccess = delreq.onerror = wrap(() => {\n          reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n        });\n      } else {\n        upgradeTransaction.onerror = eventRejectHandler(reject);\n        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n        wasCreated = oldVer < 1;\n        db._novip.idbdb = req.result;\n        runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n      }\n    }, reject);\n    req.onsuccess = wrap(() => {\n      upgradeTransaction = null;\n      const idbdb = db._novip.idbdb = req.result;\n      const objectStoreNames = slice(idbdb.objectStoreNames);\n      if (objectStoreNames.length > 0) try {\n        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n        if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);else {\n          adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n\n          if (!verifyInstalledSchema(db, tmpTrans)) {\n            console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n          }\n        }\n        generateMiddlewareStacks(db, tmpTrans);\n      } catch (e) {}\n      connections.push(db);\n      idbdb.onversionchange = wrap(ev => {\n        state.vcFired = true;\n        db.on(\"versionchange\").fire(ev);\n      });\n      idbdb.onclose = wrap(ev => {\n        db.on(\"close\").fire(ev);\n      });\n      if (wasCreated) _onDatabaseCreated(db._deps, dbName);\n      resolve();\n    }, reject);\n  }))]).then(() => {\n    throwIfCancelled();\n    state.onReadyBeingFired = [];\n    return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {\n      if (state.onReadyBeingFired.length > 0) {\n        let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);\n      }\n    });\n  }).finally(() => {\n    state.onReadyBeingFired = null;\n    state.isBeingOpened = false;\n  }).then(() => {\n    return db;\n  }).catch(err => {\n    state.dbOpenError = err;\n\n    try {\n      upgradeTransaction && upgradeTransaction.abort();\n    } catch (_a) {}\n\n    if (openCanceller === state.openCanceller) {\n      db._close();\n    }\n\n    return rejection(err);\n  }).finally(() => {\n    state.openComplete = true;\n    resolveDbReady();\n  });\n}\n\nfunction awaitIterator(iterator) {\n  var callNext = result => iterator.next(result),\n      doThrow = error => iterator.throw(error),\n      onSuccess = step(callNext),\n      onError = step(doThrow);\n\n  function step(getNext) {\n    return val => {\n      var next = getNext(val),\n          value = next.value;\n      return next.done ? value : !value || typeof value.then !== 'function' ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);\n    };\n  }\n\n  return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n  var i = arguments.length;\n  if (i < 2) throw new exceptions.InvalidArgument(\"Too few arguments\");\n  var args = new Array(i - 1);\n\n  while (--i) args[i - 1] = arguments[i];\n\n  scopeFunc = args.pop();\n  var tables = flatten(args);\n  return [mode, tables, scopeFunc];\n}\n\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n  return DexiePromise.resolve().then(() => {\n    const transless = PSD.transless || PSD;\n\n    const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n\n    const zoneProps = {\n      trans: trans,\n      transless: transless\n    };\n\n    if (parentTransaction) {\n      trans.idbtrans = parentTransaction.idbtrans;\n    } else {\n      try {\n        trans.create();\n        db._state.PR1398_maxLoop = 3;\n      } catch (ex) {\n        if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n          console.warn('Dexie: Need to reopen db');\n\n          db._close();\n\n          return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));\n        }\n\n        return rejection(ex);\n      }\n    }\n\n    const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n\n    if (scopeFuncIsAsync) {\n      incrementExpectedAwaits();\n    }\n\n    let returnValue;\n    const promiseFollowed = DexiePromise.follow(() => {\n      returnValue = scopeFunc.call(trans, trans);\n\n      if (returnValue) {\n        if (scopeFuncIsAsync) {\n          var decrementor = decrementExpectedAwaits.bind(null, null);\n          returnValue.then(decrementor, decrementor);\n        } else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n          returnValue = awaitIterator(returnValue);\n        }\n      }\n    }, zoneProps);\n    return (returnValue && typeof returnValue.then === 'function' ? DexiePromise.resolve(returnValue).then(x => trans.active ? x : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\"))) : promiseFollowed.then(() => returnValue)).then(x => {\n      if (parentTransaction) trans._resolve();\n      return trans._completion.then(() => x);\n    }).catch(e => {\n      trans._reject(e);\n\n      return rejection(e);\n    });\n  });\n}\n\nfunction pad(a, value, count) {\n  const result = isArray(a) ? a.slice() : [a];\n\n  for (let i = 0; i < count; ++i) result.push(value);\n\n  return result;\n}\n\nfunction createVirtualIndexMiddleware(down) {\n  return { ...down,\n\n    table(tableName) {\n      const table = down.table(tableName);\n      const {\n        schema\n      } = table;\n      const indexLookup = {};\n      const allVirtualIndexes = [];\n\n      function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n        const keyPathAlias = getKeyPathAlias(keyPath);\n        const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];\n        const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n        const isVirtual = keyTail > 0;\n        const virtualIndex = { ...lowLevelIndex,\n          isVirtual,\n          keyTail,\n          keyLength,\n          extractKey: getKeyExtractor(keyPath),\n          unique: !isVirtual && lowLevelIndex.unique\n        };\n        indexList.push(virtualIndex);\n\n        if (!virtualIndex.isPrimaryKey) {\n          allVirtualIndexes.push(virtualIndex);\n        }\n\n        if (keyLength > 1) {\n          const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);\n          addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n        }\n\n        indexList.sort((a, b) => a.keyTail - b.keyTail);\n        return virtualIndex;\n      }\n\n      const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n      indexLookup[\":id\"] = [primaryKey];\n\n      for (const index of schema.indexes) {\n        addVirtualIndexes(index.keyPath, 0, index);\n      }\n\n      function findBestIndex(keyPath) {\n        const result = indexLookup[getKeyPathAlias(keyPath)];\n        return result && result[0];\n      }\n\n      function translateRange(range, keyTail) {\n        return {\n          type: range.type === 1 ? 2 : range.type,\n          lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n          lowerOpen: true,\n          upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n          upperOpen: true\n        };\n      }\n\n      function translateRequest(req) {\n        const index = req.query.index;\n        return index.isVirtual ? { ...req,\n          query: {\n            index,\n            range: translateRange(req.query.range, index.keyTail)\n          }\n        } : req;\n      }\n\n      const result = { ...table,\n        schema: { ...schema,\n          primaryKey,\n          indexes: allVirtualIndexes,\n          getIndexByKeyPath: findBestIndex\n        },\n\n        count(req) {\n          return table.count(translateRequest(req));\n        },\n\n        query(req) {\n          return table.query(translateRequest(req));\n        },\n\n        openCursor(req) {\n          const {\n            keyTail,\n            isVirtual,\n            keyLength\n          } = req.query.index;\n          if (!isVirtual) return table.openCursor(req);\n\n          function createVirtualCursor(cursor) {\n            function _continue(key) {\n              key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();\n            }\n\n            const virtualCursor = Object.create(cursor, {\n              continue: {\n                value: _continue\n              },\n              continuePrimaryKey: {\n                value(key, primaryKey) {\n                  cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                }\n\n              },\n              primaryKey: {\n                get() {\n                  return cursor.primaryKey;\n                }\n\n              },\n              key: {\n                get() {\n                  const key = cursor.key;\n                  return keyLength === 1 ? key[0] : key.slice(0, keyLength);\n                }\n\n              },\n              value: {\n                get() {\n                  return cursor.value;\n                }\n\n              }\n            });\n            return virtualCursor;\n          }\n\n          return table.openCursor(translateRequest(req)).then(cursor => cursor && createVirtualCursor(cursor));\n        }\n\n      };\n      return result;\n    }\n\n  };\n}\n\nconst virtualIndexMiddleware = {\n  stack: \"dbcore\",\n  name: \"VirtualIndexMiddleware\",\n  level: 1,\n  create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n  rv = rv || {};\n  prfx = prfx || '';\n  keys(a).forEach(prop => {\n    if (!hasOwn(b, prop)) {\n      rv[prfx + prop] = undefined;\n    } else {\n      var ap = a[prop],\n          bp = b[prop];\n\n      if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n        const apTypeName = toStringTag(ap);\n        const bpTypeName = toStringTag(bp);\n\n        if (apTypeName !== bpTypeName) {\n          rv[prfx + prop] = b[prop];\n        } else if (apTypeName === 'Object') {\n          getObjectDiff(ap, bp, rv, prfx + prop + '.');\n        } else if (ap !== bp) {\n          rv[prfx + prop] = b[prop];\n        }\n      } else if (ap !== bp) rv[prfx + prop] = b[prop];\n    }\n  });\n  keys(b).forEach(prop => {\n    if (!hasOwn(a, prop)) {\n      rv[prfx + prop] = b[prop];\n    }\n  });\n  return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n  if (req.type === 'delete') return req.keys;\n  return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nconst hooksMiddleware = {\n  stack: \"dbcore\",\n  name: \"HooksMiddleware\",\n  level: 2,\n  create: downCore => ({ ...downCore,\n\n    table(tableName) {\n      const downTable = downCore.table(tableName);\n      const {\n        primaryKey\n      } = downTable.schema;\n      const tableMiddleware = { ...downTable,\n\n        mutate(req) {\n          const dxTrans = PSD.trans;\n          const {\n            deleting,\n            creating,\n            updating\n          } = dxTrans.table(tableName).hook;\n\n          switch (req.type) {\n            case 'add':\n              if (creating.fire === nop) break;\n              return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n\n            case 'put':\n              if (creating.fire === nop && updating.fire === nop) break;\n              return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n\n            case 'delete':\n              if (deleting.fire === nop) break;\n              return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n\n            case 'deleteRange':\n              if (deleting.fire === nop) break;\n              return dxTrans._promise('readwrite', () => deleteRange(req), true);\n          }\n\n          return downTable.mutate(req);\n\n          function addPutOrDelete(req) {\n            const dxTrans = PSD.trans;\n            const keys = req.keys || getEffectiveKeys(primaryKey, req);\n            if (!keys) throw new Error(\"Keys missing\");\n            req = req.type === 'add' || req.type === 'put' ? { ...req,\n              keys\n            } : { ...req\n            };\n            if (req.type !== 'delete') req.values = [...req.values];\n            if (req.keys) req.keys = [...req.keys];\n            return getExistingValues(downTable, req, keys).then(existingValues => {\n              const contexts = keys.map((key, i) => {\n                const existingValue = existingValues[i];\n                const ctx = {\n                  onerror: null,\n                  onsuccess: null\n                };\n\n                if (req.type === 'delete') {\n                  deleting.fire.call(ctx, key, existingValue, dxTrans);\n                } else if (req.type === 'add' || existingValue === undefined) {\n                  const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n\n                  if (key == null && generatedPrimaryKey != null) {\n                    key = generatedPrimaryKey;\n                    req.keys[i] = key;\n\n                    if (!primaryKey.outbound) {\n                      setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                    }\n                  }\n                } else {\n                  const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                  const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n\n                  if (additionalChanges) {\n                    const requestedValue = req.values[i];\n                    Object.keys(additionalChanges).forEach(keyPath => {\n                      if (hasOwn(requestedValue, keyPath)) {\n                        requestedValue[keyPath] = additionalChanges[keyPath];\n                      } else {\n                        setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                      }\n                    });\n                  }\n                }\n\n                return ctx;\n              });\n              return downTable.mutate(req).then(({\n                failures,\n                results,\n                numFailures,\n                lastResult\n              }) => {\n                for (let i = 0; i < keys.length; ++i) {\n                  const primKey = results ? results[i] : keys[i];\n                  const ctx = contexts[i];\n\n                  if (primKey == null) {\n                    ctx.onerror && ctx.onerror(failures[i]);\n                  } else {\n                    ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ? req.values[i] : primKey);\n                  }\n                }\n\n                return {\n                  failures,\n                  results,\n                  numFailures,\n                  lastResult\n                };\n              }).catch(error => {\n                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                return Promise.reject(error);\n              });\n            });\n          }\n\n          function deleteRange(req) {\n            return deleteNextChunk(req.trans, req.range, 10000);\n          }\n\n          function deleteNextChunk(trans, range, limit) {\n            return downTable.query({\n              trans,\n              values: false,\n              query: {\n                index: primaryKey,\n                range\n              },\n              limit\n            }).then(({\n              result\n            }) => {\n              return addPutOrDelete({\n                type: 'delete',\n                keys: result,\n                trans\n              }).then(res => {\n                if (res.numFailures > 0) return Promise.reject(res.failures[0]);\n\n                if (result.length < limit) {\n                  return {\n                    failures: [],\n                    numFailures: 0,\n                    lastResult: undefined\n                  };\n                } else {\n                  return deleteNextChunk(trans, { ...range,\n                    lower: result[result.length - 1],\n                    lowerOpen: true\n                  }, limit);\n                }\n              });\n            });\n          }\n        }\n\n      };\n      return tableMiddleware;\n    }\n\n  })\n};\n\nfunction getExistingValues(table, req, effectiveKeys) {\n  return req.type === \"add\" ? Promise.resolve([]) : table.getMany({\n    trans: req.trans,\n    keys: effectiveKeys,\n    cache: \"immutable\"\n  });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n  try {\n    if (!cache) return null;\n    if (cache.keys.length < keys.length) return null;\n    const result = [];\n\n    for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n      if (cmp(cache.keys[i], keys[j]) !== 0) continue;\n      result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n      ++j;\n    }\n\n    return result.length === keys.length ? result : null;\n  } catch (_a) {\n    return null;\n  }\n}\n\nconst cacheExistingValuesMiddleware = {\n  stack: \"dbcore\",\n  level: -1,\n  create: core => {\n    return {\n      table: tableName => {\n        const table = core.table(tableName);\n        return { ...table,\n          getMany: req => {\n            if (!req.cache) {\n              return table.getMany(req);\n            }\n\n            const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n\n            if (cachedResult) {\n              return DexiePromise.resolve(cachedResult);\n            }\n\n            return table.getMany(req).then(res => {\n              req.trans[\"_cache\"] = {\n                keys: req.keys,\n                values: req.cache === \"clone\" ? deepClone(res) : res\n              };\n              return res;\n            });\n          },\n          mutate: req => {\n            if (req.type !== \"add\") req.trans[\"_cache\"] = null;\n            return table.mutate(req);\n          }\n        };\n      }\n    };\n  }\n};\n\nfunction isEmptyRange(node) {\n  return !(\"from\" in node);\n}\n\nconst RangeSet = function (fromOrTree, to) {\n  if (this) {\n    extend(this, arguments.length ? {\n      d: 1,\n      from: fromOrTree,\n      to: arguments.length > 1 ? to : fromOrTree\n    } : {\n      d: 0\n    });\n  } else {\n    const rv = new RangeSet();\n\n    if (fromOrTree && \"d\" in fromOrTree) {\n      extend(rv, fromOrTree);\n    }\n\n    return rv;\n  }\n};\n\nprops(RangeSet.prototype, {\n  add(rangeSet) {\n    mergeRanges(this, rangeSet);\n    return this;\n  },\n\n  addKey(key) {\n    addRange(this, key, key);\n    return this;\n  },\n\n  addKeys(keys) {\n    keys.forEach(key => addRange(this, key, key));\n    return this;\n  },\n\n  [iteratorSymbol]() {\n    return getRangeSetIterator(this);\n  }\n\n});\n\nfunction addRange(target, from, to) {\n  const diff = cmp(from, to);\n  if (isNaN(diff)) return;\n  if (diff > 0) throw RangeError();\n  if (isEmptyRange(target)) return extend(target, {\n    from,\n    to,\n    d: 1\n  });\n  const left = target.l;\n  const right = target.r;\n\n  if (cmp(to, target.from) < 0) {\n    left ? addRange(left, from, to) : target.l = {\n      from,\n      to,\n      d: 1,\n      l: null,\n      r: null\n    };\n    return rebalance(target);\n  }\n\n  if (cmp(from, target.to) > 0) {\n    right ? addRange(right, from, to) : target.r = {\n      from,\n      to,\n      d: 1,\n      l: null,\n      r: null\n    };\n    return rebalance(target);\n  }\n\n  if (cmp(from, target.from) < 0) {\n    target.from = from;\n    target.l = null;\n    target.d = right ? right.d + 1 : 1;\n  }\n\n  if (cmp(to, target.to) > 0) {\n    target.to = to;\n    target.r = null;\n    target.d = target.l ? target.l.d + 1 : 1;\n  }\n\n  const rightWasCutOff = !target.r;\n\n  if (left && !target.l) {\n    mergeRanges(target, left);\n  }\n\n  if (right && rightWasCutOff) {\n    mergeRanges(target, right);\n  }\n}\n\nfunction mergeRanges(target, newSet) {\n  function _addRangeSet(target, {\n    from,\n    to,\n    l,\n    r\n  }) {\n    addRange(target, from, to);\n    if (l) _addRangeSet(target, l);\n    if (r) _addRangeSet(target, r);\n  }\n\n  if (!isEmptyRange(newSet)) _addRangeSet(target, newSet);\n}\n\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n  const i1 = getRangeSetIterator(rangeSet2);\n  let nextResult1 = i1.next();\n  if (nextResult1.done) return false;\n  let a = nextResult1.value;\n  const i2 = getRangeSetIterator(rangeSet1);\n  let nextResult2 = i2.next(a.from);\n  let b = nextResult2.value;\n\n  while (!nextResult1.done && !nextResult2.done) {\n    if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0) return true;\n    cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;\n  }\n\n  return false;\n}\n\nfunction getRangeSetIterator(node) {\n  let state = isEmptyRange(node) ? null : {\n    s: 0,\n    n: node\n  };\n  return {\n    next(key) {\n      const keyProvided = arguments.length > 0;\n\n      while (state) {\n        switch (state.s) {\n          case 0:\n            state.s = 1;\n\n            if (keyProvided) {\n              while (state.n.l && cmp(key, state.n.from) < 0) state = {\n                up: state,\n                n: state.n.l,\n                s: 1\n              };\n            } else {\n              while (state.n.l) state = {\n                up: state,\n                n: state.n.l,\n                s: 1\n              };\n            }\n\n          case 1:\n            state.s = 2;\n            if (!keyProvided || cmp(key, state.n.to) <= 0) return {\n              value: state.n,\n              done: false\n            };\n\n          case 2:\n            if (state.n.r) {\n              state.s = 3;\n              state = {\n                up: state,\n                n: state.n.r,\n                s: 0\n              };\n              continue;\n            }\n\n          case 3:\n            state = state.up;\n        }\n      }\n\n      return {\n        done: true\n      };\n    }\n\n  };\n}\n\nfunction rebalance(target) {\n  var _a, _b;\n\n  const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n  const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n\n  if (r) {\n    const l = r === \"r\" ? \"l\" : \"r\";\n    const rootClone = { ...target\n    };\n    const oldRootRight = target[r];\n    target.from = oldRootRight.from;\n    target.to = oldRootRight.to;\n    target[r] = oldRootRight[r];\n    rootClone[r] = oldRootRight[l];\n    target[l] = rootClone;\n    rootClone.d = computeDepth(rootClone);\n  }\n\n  target.d = computeDepth(target);\n}\n\nfunction computeDepth({\n  r,\n  l\n}) {\n  return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;\n}\n\nconst observabilityMiddleware = {\n  stack: \"dbcore\",\n  level: 0,\n  create: core => {\n    const dbName = core.schema.name;\n    const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n    return { ...core,\n      table: tableName => {\n        const table = core.table(tableName);\n        const {\n          schema\n        } = table;\n        const {\n          primaryKey\n        } = schema;\n        const {\n          extractKey,\n          outbound\n        } = primaryKey;\n        const tableClone = { ...table,\n          mutate: req => {\n            const trans = req.trans;\n            const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n\n            const getRangeSet = indexName => {\n              const part = `idb://${dbName}/${tableName}/${indexName}`;\n              return mutatedParts[part] || (mutatedParts[part] = new RangeSet());\n            };\n\n            const pkRangeSet = getRangeSet(\"\");\n            const delsRangeSet = getRangeSet(\":dels\");\n            const {\n              type\n            } = req;\n            let [keys, newObjs] = req.type === \"deleteRange\" ? [req.range] : req.type === \"delete\" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [];\n            const oldCache = req.trans[\"_cache\"];\n            return table.mutate(req).then(res => {\n              if (isArray(keys)) {\n                if (type !== \"delete\") keys = res.results;\n                pkRangeSet.addKeys(keys);\n                const oldObjs = getFromTransactionCache(keys, oldCache);\n\n                if (!oldObjs && type !== \"add\") {\n                  delsRangeSet.addKeys(keys);\n                }\n\n                if (oldObjs || newObjs) {\n                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                }\n              } else if (keys) {\n                const range = {\n                  from: keys.lower,\n                  to: keys.upper\n                };\n                delsRangeSet.add(range);\n                pkRangeSet.add(range);\n              } else {\n                pkRangeSet.add(FULL_RANGE);\n                delsRangeSet.add(FULL_RANGE);\n                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n              }\n\n              return res;\n            });\n          }\n        };\n\n        const getRange = ({\n          query: {\n            index,\n            range\n          }\n        }) => {\n          var _a, _b;\n\n          return [index, new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY)];\n        };\n\n        const readSubscribers = {\n          get: req => [primaryKey, new RangeSet(req.key)],\n          getMany: req => [primaryKey, new RangeSet().addKeys(req.keys)],\n          count: getRange,\n          query: getRange,\n          openCursor: getRange\n        };\n        keys(readSubscribers).forEach(method => {\n          tableClone[method] = function (req) {\n            const {\n              subscr\n            } = PSD;\n\n            if (subscr) {\n              const getRangeSet = indexName => {\n                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                return subscr[part] || (subscr[part] = new RangeSet());\n              };\n\n              const pkRangeSet = getRangeSet(\"\");\n              const delsRangeSet = getRangeSet(\":dels\");\n              const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n              getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n\n              if (!queriedIndex.isPrimaryKey) {\n                if (method === \"count\") {\n                  delsRangeSet.add(FULL_RANGE);\n                } else {\n                  const keysPromise = method === \"query\" && outbound && req.values && table.query({ ...req,\n                    values: false\n                  });\n                  return table[method].apply(this, arguments).then(res => {\n                    if (method === \"query\") {\n                      if (outbound && req.values) {\n                        return keysPromise.then(({\n                          result: resultingKeys\n                        }) => {\n                          pkRangeSet.addKeys(resultingKeys);\n                          return res;\n                        });\n                      }\n\n                      const pKeys = req.values ? res.result.map(extractKey) : res.result;\n\n                      if (req.values) {\n                        pkRangeSet.addKeys(pKeys);\n                      } else {\n                        delsRangeSet.addKeys(pKeys);\n                      }\n                    } else if (method === \"openCursor\") {\n                      const cursor = res;\n                      const wantValues = req.values;\n                      return cursor && Object.create(cursor, {\n                        key: {\n                          get() {\n                            delsRangeSet.addKey(cursor.primaryKey);\n                            return cursor.key;\n                          }\n\n                        },\n                        primaryKey: {\n                          get() {\n                            const pkey = cursor.primaryKey;\n                            delsRangeSet.addKey(pkey);\n                            return pkey;\n                          }\n\n                        },\n                        value: {\n                          get() {\n                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                            return cursor.value;\n                          }\n\n                        }\n                      });\n                    }\n\n                    return res;\n                  });\n                }\n              }\n            }\n\n            return table[method].apply(this, arguments);\n          };\n        });\n        return tableClone;\n      }\n    };\n  }\n};\n\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n  function addAffectedIndex(ix) {\n    const rangeSet = getRangeSet(ix.name || \"\");\n\n    function extractKey(obj) {\n      return obj != null ? ix.extractKey(obj) : null;\n    }\n\n    const addKeyOrKeys = key => ix.multiEntry && isArray(key) ? key.forEach(key => rangeSet.addKey(key)) : rangeSet.addKey(key);\n\n    (oldObjs || newObjs).forEach((_, i) => {\n      const oldKey = oldObjs && extractKey(oldObjs[i]);\n      const newKey = newObjs && extractKey(newObjs[i]);\n\n      if (cmp(oldKey, newKey) !== 0) {\n        if (oldKey != null) addKeyOrKeys(oldKey);\n        if (newKey != null) addKeyOrKeys(newKey);\n      }\n    });\n  }\n\n  schema.indexes.forEach(addAffectedIndex);\n}\n\nclass Dexie$1 {\n  constructor(name, options) {\n    this._middlewares = {};\n    this.verno = 0;\n    const deps = Dexie$1.dependencies;\n    this._options = options = {\n      addons: Dexie$1.addons,\n      autoOpen: true,\n      indexedDB: deps.indexedDB,\n      IDBKeyRange: deps.IDBKeyRange,\n      ...options\n    };\n    this._deps = {\n      indexedDB: options.indexedDB,\n      IDBKeyRange: options.IDBKeyRange\n    };\n    const {\n      addons\n    } = options;\n    this._dbSchema = {};\n    this._versions = [];\n    this._storeNames = [];\n    this._allTables = {};\n    this.idbdb = null;\n    this._novip = this;\n    const state = {\n      dbOpenError: null,\n      isBeingOpened: false,\n      onReadyBeingFired: null,\n      openComplete: false,\n      dbReadyResolve: nop,\n      dbReadyPromise: null,\n      cancelOpen: nop,\n      openCanceller: null,\n      autoSchema: true,\n      PR1398_maxLoop: 3\n    };\n    state.dbReadyPromise = new DexiePromise(resolve => {\n      state.dbReadyResolve = resolve;\n    });\n    state.openCanceller = new DexiePromise((_, reject) => {\n      state.cancelOpen = reject;\n    });\n    this._state = state;\n    this.name = name;\n    this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", {\n      ready: [promisableChain, nop]\n    });\n    this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n      return (subscriber, bSticky) => {\n        Dexie$1.vip(() => {\n          const state = this._state;\n\n          if (state.openComplete) {\n            if (!state.dbOpenError) DexiePromise.resolve().then(subscriber);\n            if (bSticky) subscribe(subscriber);\n          } else if (state.onReadyBeingFired) {\n            state.onReadyBeingFired.push(subscriber);\n            if (bSticky) subscribe(subscriber);\n          } else {\n            subscribe(subscriber);\n            const db = this;\n            if (!bSticky) subscribe(function unsubscribe() {\n              db.on.ready.unsubscribe(subscriber);\n              db.on.ready.unsubscribe(unsubscribe);\n            });\n          }\n        });\n      };\n    });\n    this.Collection = createCollectionConstructor(this);\n    this.Table = createTableConstructor(this);\n    this.Transaction = createTransactionConstructor(this);\n    this.Version = createVersionConstructor(this);\n    this.WhereClause = createWhereClauseConstructor(this);\n    this.on(\"versionchange\", ev => {\n      if (ev.newVersion > 0) console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);else console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n      this.close();\n    });\n    this.on(\"blocked\", ev => {\n      if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn(`Dexie.delete('${this.name}') was blocked`);else console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n    });\n    this._maxKey = getMaxKey(options.IDBKeyRange);\n\n    this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n\n    this._fireOnBlocked = ev => {\n      this.on(\"blocked\").fire(ev);\n      connections.filter(c => c.name === this.name && c !== this && !c._state.vcFired).map(c => c.on(\"versionchange\").fire(ev));\n    };\n\n    this.use(virtualIndexMiddleware);\n    this.use(hooksMiddleware);\n    this.use(observabilityMiddleware);\n    this.use(cacheExistingValuesMiddleware);\n    this.vip = Object.create(this, {\n      _vip: {\n        value: true\n      }\n    });\n    addons.forEach(addon => addon(this));\n  }\n\n  version(versionNumber) {\n    if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type(`Given version is not a positive number`);\n    versionNumber = Math.round(versionNumber * 10) / 10;\n    if (this.idbdb || this._state.isBeingOpened) throw new exceptions.Schema(\"Cannot add version when database is open\");\n    this.verno = Math.max(this.verno, versionNumber);\n    const versions = this._versions;\n    var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];\n    if (versionInstance) return versionInstance;\n    versionInstance = new this.Version(versionNumber);\n    versions.push(versionInstance);\n    versions.sort(lowerVersionFirst);\n    versionInstance.stores({});\n    this._state.autoSchema = false;\n    return versionInstance;\n  }\n\n  _whenReady(fn) {\n    return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise((resolve, reject) => {\n      if (this._state.openComplete) {\n        return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n      }\n\n      if (!this._state.isBeingOpened) {\n        if (!this._options.autoOpen) {\n          reject(new exceptions.DatabaseClosed());\n          return;\n        }\n\n        this.open().catch(nop);\n      }\n\n      this._state.dbReadyPromise.then(resolve, reject);\n    }).then(fn);\n  }\n\n  use({\n    stack,\n    create,\n    level,\n    name\n  }) {\n    if (name) this.unuse({\n      stack,\n      name\n    });\n    const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n    middlewares.push({\n      stack,\n      create,\n      level: level == null ? 10 : level,\n      name\n    });\n    middlewares.sort((a, b) => a.level - b.level);\n    return this;\n  }\n\n  unuse({\n    stack,\n    name,\n    create\n  }) {\n    if (stack && this._middlewares[stack]) {\n      this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create : name ? mw.name !== name : false);\n    }\n\n    return this;\n  }\n\n  open() {\n    return dexieOpen(this);\n  }\n\n  _close() {\n    const state = this._state;\n    const idx = connections.indexOf(this);\n    if (idx >= 0) connections.splice(idx, 1);\n\n    if (this.idbdb) {\n      try {\n        this.idbdb.close();\n      } catch (e) {}\n\n      this._novip.idbdb = null;\n    }\n\n    state.dbReadyPromise = new DexiePromise(resolve => {\n      state.dbReadyResolve = resolve;\n    });\n    state.openCanceller = new DexiePromise((_, reject) => {\n      state.cancelOpen = reject;\n    });\n  }\n\n  close() {\n    this._close();\n\n    const state = this._state;\n    this._options.autoOpen = false;\n    state.dbOpenError = new exceptions.DatabaseClosed();\n    if (state.isBeingOpened) state.cancelOpen(state.dbOpenError);\n  }\n\n  delete() {\n    const hasArguments = arguments.length > 0;\n    const state = this._state;\n    return new DexiePromise((resolve, reject) => {\n      const doDelete = () => {\n        this.close();\n\n        var req = this._deps.indexedDB.deleteDatabase(this.name);\n\n        req.onsuccess = wrap(() => {\n          _onDatabaseDeleted(this._deps, this.name);\n\n          resolve();\n        });\n        req.onerror = eventRejectHandler(reject);\n        req.onblocked = this._fireOnBlocked;\n      };\n\n      if (hasArguments) throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n\n      if (state.isBeingOpened) {\n        state.dbReadyPromise.then(doDelete);\n      } else {\n        doDelete();\n      }\n    });\n  }\n\n  backendDB() {\n    return this.idbdb;\n  }\n\n  isOpen() {\n    return this.idbdb !== null;\n  }\n\n  hasBeenClosed() {\n    const dbOpenError = this._state.dbOpenError;\n    return dbOpenError && dbOpenError.name === 'DatabaseClosed';\n  }\n\n  hasFailed() {\n    return this._state.dbOpenError !== null;\n  }\n\n  dynamicallyOpened() {\n    return this._state.autoSchema;\n  }\n\n  get tables() {\n    return keys(this._allTables).map(name => this._allTables[name]);\n  }\n\n  transaction() {\n    const args = extractTransactionArgs.apply(this, arguments);\n    return this._transaction.apply(this, args);\n  }\n\n  _transaction(mode, tables, scopeFunc) {\n    let parentTransaction = PSD.trans;\n    if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1) parentTransaction = null;\n    const onlyIfCompatible = mode.indexOf('?') !== -1;\n    mode = mode.replace('!', '').replace('?', '');\n    let idbMode, storeNames;\n\n    try {\n      storeNames = tables.map(table => {\n        var storeName = table instanceof this.Table ? table.name : table;\n        if (typeof storeName !== 'string') throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n        return storeName;\n      });\n      if (mode == \"r\" || mode === READONLY) idbMode = READONLY;else if (mode == \"rw\" || mode == READWRITE) idbMode = READWRITE;else throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n\n      if (parentTransaction) {\n        if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n          if (onlyIfCompatible) {\n            parentTransaction = null;\n          } else throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n        }\n\n        if (parentTransaction) {\n          storeNames.forEach(storeName => {\n            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n              if (onlyIfCompatible) {\n                parentTransaction = null;\n              } else throw new exceptions.SubTransaction(\"Table \" + storeName + \" not included in parent transaction.\");\n            }\n          });\n        }\n\n        if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n          parentTransaction = null;\n        }\n      }\n    } catch (e) {\n      return parentTransaction ? parentTransaction._promise(null, (_, reject) => {\n        reject(e);\n      }) : rejection(e);\n    }\n\n    const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n    return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, \"lock\") : PSD.trans ? usePSD(PSD.transless, () => this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);\n  }\n\n  table(tableName) {\n    if (!hasOwn(this._allTables, tableName)) {\n      throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n    }\n\n    return this._allTables[tableName];\n  }\n\n}\n\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol ? Symbol.observable : \"@@observable\";\n\nclass Observable {\n  constructor(subscribe) {\n    this._subscribe = subscribe;\n  }\n\n  subscribe(x, error, complete) {\n    return this._subscribe(!x || typeof x === \"function\" ? {\n      next: x,\n      error,\n      complete\n    } : x);\n  }\n\n  [symbolObservable]() {\n    return this;\n  }\n\n}\n\nfunction extendObservabilitySet(target, newSet) {\n  keys(newSet).forEach(part => {\n    const rangeSet = target[part] || (target[part] = new RangeSet());\n    mergeRanges(rangeSet, newSet[part]);\n  });\n  return target;\n}\n\nfunction liveQuery(querier) {\n  return new Observable(observer => {\n    const scopeFuncIsAsync = isAsyncFunction(querier);\n\n    function execute(subscr) {\n      if (scopeFuncIsAsync) {\n        incrementExpectedAwaits();\n      }\n\n      const exec = () => newScope(querier, {\n        subscr,\n        trans: null\n      });\n\n      const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();\n\n      if (scopeFuncIsAsync) {\n        rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n      }\n\n      return rv;\n    }\n\n    let closed = false;\n    let accumMuts = {};\n    let currentObs = {};\n    const subscription = {\n      get closed() {\n        return closed;\n      },\n\n      unsubscribe: () => {\n        closed = true;\n        globalEvents.storagemutated.unsubscribe(mutationListener);\n      }\n    };\n    observer.start && observer.start(subscription);\n    let querying = false,\n        startedListening = false;\n\n    function shouldNotify() {\n      return keys(currentObs).some(key => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n    }\n\n    const mutationListener = parts => {\n      extendObservabilitySet(accumMuts, parts);\n\n      if (shouldNotify()) {\n        doQuery();\n      }\n    };\n\n    const doQuery = () => {\n      if (querying || closed) return;\n      accumMuts = {};\n      const subscr = {};\n      const ret = execute(subscr);\n\n      if (!startedListening) {\n        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n        startedListening = true;\n      }\n\n      querying = true;\n      Promise.resolve(ret).then(result => {\n        querying = false;\n        if (closed) return;\n\n        if (shouldNotify()) {\n          doQuery();\n        } else {\n          accumMuts = {};\n          currentObs = subscr;\n          observer.next && observer.next(result);\n        }\n      }, err => {\n        querying = false;\n        observer.error && observer.error(err);\n        subscription.unsubscribe();\n      });\n    };\n\n    doQuery();\n    return subscription;\n  });\n}\n\nlet domDeps;\n\ntry {\n  domDeps = {\n    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n  };\n} catch (e) {\n  domDeps = {\n    indexedDB: null,\n    IDBKeyRange: null\n  };\n}\n\nconst Dexie = Dexie$1;\nprops(Dexie, { ...fullNameExceptions,\n\n  delete(databaseName) {\n    const db = new Dexie(databaseName, {\n      addons: []\n    });\n    return db.delete();\n  },\n\n  exists(name) {\n    return new Dexie(name, {\n      addons: []\n    }).open().then(db => {\n      db.close();\n      return true;\n    }).catch('NoSuchDatabaseError', () => false);\n  },\n\n  getDatabaseNames(cb) {\n    try {\n      return getDatabaseNames(Dexie.dependencies).then(cb);\n    } catch (_a) {\n      return rejection(new exceptions.MissingAPI());\n    }\n  },\n\n  defineClass() {\n    function Class(content) {\n      extend(this, content);\n    }\n\n    return Class;\n  },\n\n  ignoreTransaction(scopeFunc) {\n    return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();\n  },\n\n  vip,\n  async: function (generatorFn) {\n    return function () {\n      try {\n        var rv = awaitIterator(generatorFn.apply(this, arguments));\n        if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);\n        return rv;\n      } catch (e) {\n        return rejection(e);\n      }\n    };\n  },\n  spawn: function (generatorFn, args, thiz) {\n    try {\n      var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n      if (!rv || typeof rv.then !== 'function') return DexiePromise.resolve(rv);\n      return rv;\n    } catch (e) {\n      return rejection(e);\n    }\n  },\n  currentTransaction: {\n    get: () => PSD.trans || null\n  },\n  waitFor: function (promiseOrFunction, optionalTimeout) {\n    const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000);\n    return PSD.trans ? PSD.trans.waitFor(promise) : promise;\n  },\n  Promise: DexiePromise,\n  debug: {\n    get: () => debug,\n    set: value => {\n      setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);\n    }\n  },\n  derive: derive,\n  extend: extend,\n  props: props,\n  override: override,\n  Events: Events,\n  on: globalEvents,\n  liveQuery,\n  extendObservabilitySet,\n  getByKeyPath: getByKeyPath,\n  setByKeyPath: setByKeyPath,\n  delByKeyPath: delByKeyPath,\n  shallowClone: shallowClone,\n  deepClone: deepClone,\n  getObjectDiff: getObjectDiff,\n  cmp,\n  asap: asap$1,\n  minKey: minKey,\n  addons: [],\n  connections: connections,\n  errnames: errnames,\n  dependencies: domDeps,\n  semVer: DEXIE_VERSION,\n  version: DEXIE_VERSION.split('.').map(n => parseInt(n)).reduce((p, c, i) => p + c / Math.pow(10, i * 2))\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n    if (!propagatingLocally) {\n      let event;\n\n      if (isIEOrEdge) {\n        event = document.createEvent('CustomEvent');\n        event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n      } else {\n        event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n          detail: updatedParts\n        });\n      }\n\n      propagatingLocally = true;\n      dispatchEvent(event);\n      propagatingLocally = false;\n    }\n  });\n  addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({\n    detail\n  }) => {\n    if (!propagatingLocally) {\n      propagateLocally(detail);\n    }\n  });\n}\n\nfunction propagateLocally(updateParts) {\n  let wasMe = propagatingLocally;\n\n  try {\n    propagatingLocally = true;\n    globalEvents.storagemutated.fire(updateParts);\n  } finally {\n    propagatingLocally = wasMe;\n  }\n}\n\nlet propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n  const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, changedParts => {\n    if (!propagatingLocally) {\n      bc.postMessage(changedParts);\n    }\n  });\n\n  bc.onmessage = ev => {\n    if (ev.data) propagateLocally(ev.data);\n  };\n} else if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, changedParts => {\n    try {\n      if (!propagatingLocally) {\n        if (typeof localStorage !== 'undefined') {\n          localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n            trig: Math.random(),\n            changedParts\n          }));\n        }\n\n        if (typeof self['clients'] === 'object') {\n          [...self['clients'].matchAll({\n            includeUncontrolled: true\n          })].forEach(client => client.postMessage({\n            type: STORAGE_MUTATED_DOM_EVENT_NAME,\n            changedParts\n          }));\n        }\n      }\n    } catch (_a) {}\n  });\n\n  if (typeof addEventListener !== 'undefined') {\n    addEventListener('storage', ev => {\n      if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        const data = JSON.parse(ev.newValue);\n        if (data) propagateLocally(data.changedParts);\n      }\n    });\n  }\n\n  const swContainer = self.document && navigator.serviceWorker;\n\n  if (swContainer) {\n    swContainer.addEventListener('message', propagateMessageLocally);\n  }\n}\n\nfunction propagateMessageLocally({\n  data\n}) {\n  if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n    propagateLocally(data.changedParts);\n  }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\nexport { Dexie$1 as Dexie, RangeSet, Dexie$1 as default, liveQuery, mergeRanges, rangesOverlap };","map":{"version":3,"names":["_global","globalThis","self","window","global","keys","Object","isArray","Array","Promise","extend","obj","extension","forEach","key","getProto","getPrototypeOf","_hasOwn","hasOwnProperty","hasOwn","prop","call","props","proto","Reflect","ownKeys","setProp","defineProperty","functionOrGetSet","options","get","set","configurable","value","writable","derive","Child","from","Parent","prototype","create","bind","getOwnPropertyDescriptor","getPropertyDescriptor","pd","_slice","slice","args","start","end","override","origFunc","overridedFactory","assert","b","Error","asap$1","fn","setImmediate","setTimeout","arrayToObject","array","extractor","reduce","result","item","i","nameAndValue","tryCatch","onerror","apply","ex","getByKeyPath","keyPath","rv","l","length","val","push","period","indexOf","innerObj","substr","undefined","setByKeyPath","isFrozen","currentKeyPath","remainingKeyPath","isNaN","parseInt","splice","delByKeyPath","map","kp","shallowClone","m","concat","flatten","a","intrinsicTypeNames","split","num","t","filter","intrinsicTypes","x","circularRefs","deepClone","any","WeakMap","innerDeepClone","constructor","toString","toStringTag","o","iteratorSymbol","Symbol","iterator","getIteratorOf","NO_CHAR_ARRAY","getArrayOf","arrayLike","it","arguments","next","done","isAsyncFunction","debug","location","test","href","setDebug","libraryFilter","NEEDS_THROW_FOR_STACK","stack","getErrorWithStack","e","prettyStack","exception","numIgnoredFrames","name","message","frame","join","dexieErrorNames","idbDomErrorNames","errorList","defaultTexts","VersionChanged","DatabaseClosed","Abort","TransactionInactive","MissingAPI","DexieError","msg","_e","_stack","getMultiErrorMessage","failures","v","s","ModifyError","successCount","failedKeys","BulkError","pos","failuresByPos","errnames","BaseException","exceptions","fullName","msgOrInner","inner","Syntax","SyntaxError","Type","TypeError","Range","RangeError","exceptionMap","mapError","domError","fullNameExceptions","nop","mirror","pureFunctionChain","f1","f2","callBoth","on1","on2","hookCreatingChain","res","onsuccess","res2","hookDeletingChain","hookUpdatingChain","modifications","reverseStoppableEventChain","promisableChain","then","thiz","INTERNAL","LONG_STACKS_CLIP_LIMIT","MAX_LONG_STACKS","ZONE_ECHO_LIMIT","resolvedNativePromise","nativePromiseProto","resolvedGlobalPromise","globalP","resolve","crypto","subtle","nativeP","digest","Uint8Array","nativePromiseThen","NativePromise","patchGlobalPromise","stack_being_generated","schedulePhysicalTick","physicalTick","MutationObserver","hiddenDiv","document","createElement","observe","attributes","setAttribute","asap","callback","microtickQueue","needsNewPhysicalTick","isOutsideMicroTick","unhandledErrors","rejectingErrors","currentFulfiller","rejectionMapper","globalPSD","id","ref","unhandleds","onunhandled","globalError","pgp","env","finalize","uh","PSD","numScheduledCalls","tickFinalizers","DexiePromise","_listeners","onuncatched","_lib","psd","_PSD","_stackHolder","_prev","_numPrev","_state","_value","handleRejection","executePromiseTask","thenProp","microTaskId","totalEchoes","onFulfilled","onRejected","possibleAwait","cleanup","decrementExpectedAwaits","reject","propagateToListener","Listener","nativeAwaitCompatibleWrap","linkToPreviousPromise","_then","catch","type","handler","err","PromiseReject","finally","onFinally","stacks","getStack","timeout","ms","Infinity","handle","Timeout","clearTimeout","snapShot","zone","all","values","onPossibleParallellAsync","remaining","race","newPSD","newScope","usePSD","scheduler","follow","zoneProps","run_at_end_of_this_or_next_physical_tick","allSettled","possiblePromises","results","p","status","reason","AggregateError","failure","promise","shouldExecuteTick","beginMicroTickScope","propagateAllListeners","endMicroTickScope","_promise","origProp","addPossiblyUnhandledError","listeners","len","finalizePhysicalTick","listener","cb","callListener","ret","markErrorAsHandled","limit","errorName","prev","numPrev","wasRootExec","callbacks","unhandledErrs","finalizers","finalizer","some","wrap","errorCatcher","outerScope","switchToZone","task","awaits","echoes","taskCounter","zoneStack","zoneEchoes","zone_id_counter","a1","a2","parent","globalEnv","PromiseProp","nthen","getPatchedPromiseThen","gthen","incrementExpectedAwaits","possiblePromise","rejection","zoneEnterEcho","targetZone","zoneLeaveEcho","pop","bEnteringZone","currentZone","enqueueNativeMicroTask","GlobalPromise","targetEnv","a3","job","outerZone","origThen","onResolved","UNHANDLEDREJECTION","event","eventData","createEvent","initEvent","CustomEvent","detail","dispatchEvent","PromiseRejectionEvent","onunhandledrejection","_","defaultPrevented","console","warn","tempTransaction","db","mode","storeNames","idbdb","openComplete","letThrough","_vip","dbOpenError","isBeingOpened","_options","autoOpen","open","dbReadyPromise","trans","_createTransaction","_dbSchema","PR1398_maxLoop","InvalidState","isOpen","_close","_completion","DEXIE_VERSION","maxString","String","fromCharCode","minKey","INVALID_KEY_ARGUMENT","STRING_EXPECTED","connections","isIEOrEdge","navigator","userAgent","hasIEDeleteObjectStoreBug","hangsOnDeleteLargeKeyRange","dexieStackFrameFilter","DBNAMES_DB","READONLY","READWRITE","combine","filter1","filter2","AnyRange","lower","lowerOpen","upper","upperOpen","workaroundForUndefinedPrimKey","Table","_trans","writeLocked","_tx","tableName","checkTableInTransaction","schema","NotFound","idbtrans","transless","keyOrCrit","where","first","core","hook","reading","fire","indexOrCrit","WhereClause","keyPaths","equals","compoundIndex","indexes","primKey","ix","compound","every","_maxKey","JSON","stringify","idxByName","idb","_deps","indexedDB","cmp","idx","filterFunction","prevIndex","prevFilterFn","index","multi","toCollection","and","count","thenShortcut","offset","numRows","each","toArray","Collection","orderBy","reverse","mapToClass","mappedClass","readHook","unsubscribe","defineClass","Class","content","add","auto","objToAdd","mutate","numFailures","lastResult","update","keyOrObject","InvalidArgument","_a","modify","put","delete","clear","range","bulkGet","getMany","bulkAdd","objects","keysOrOptions","wantResults","allKeys","numObjects","objectsToAdd","bulkPut","objectsToPut","bulkDelete","numKeys","Events","ctx","evs","eventName","subscriber","subscribe","addEventType","chainFunction","defaultFunction","addConfiguredEvents","context","subscribers","cfg","fireEvent","makeClassConstructor","createTableConstructor","tableSchema","_allTables","isPlainKeyRange","ignoreLimitFilter","algorithm","or","justLimit","replayFilter","addFilter","addReplayFilter","factory","isLimitFilter","curr","addMatchFilter","isMatch","getIndexOrStore","coreSchema","isPrimKey","primaryKey","getIndexByKeyPath","Schema","openCursor","coreTable","keysOnly","dir","unique","query","iter","coreTrans","iterate","valueMapper","union","cursor","advance","stop","fail","_iterate","cursorPromise","mappedFn","c","wrappedFn","continue","advancer","ta","tb","NaN","compareUint8Arrays","getUint8Array","compareArrays","al","bl","ArrayBuffer","isView","tsTag","buffer","byteOffset","byteLength","_read","_ctx","error","table","_write","_addAlgorithm","clone","raw","Math","min","sortBy","parts","lastPart","lastIndex","getval","order","sorter","aVal","bVal","sort","offsetLeft","rowsLeft","until","bIncludeStopEntry","last","indexName","_ondirectionchange","desc","eachKey","eachUniqueKey","eachPrimaryKey","primaryKeys","uniqueKeys","firstKey","lastKey","distinct","strKey","found","changes","modifyer","anythingModified","outbound","extractKey","modifyChunkSize","totalFailures","applyMutateResult","expectedCount","nextChunk","cache","addValues","putValues","putKeys","deleteKeys","origValue","criteria","deleteCallback","changeSpec","coreRange","createCollectionConstructor","whereClause","keyRangeGenerator","keyRange","whereCtx","readingHook","simpleCompare","simpleCompareReverse","collectionOrWhereClause","T","collection","emptyCollection","rangeEqual","upperFactory","toUpperCase","toLowerCase","lowerFactory","nextCasing","lowerKey","upperNeedle","lowerNeedle","llp","lwrKeyChar","addIgnoreCaseAlgorithm","match","needles","suffix","compare","upperNeedles","lowerNeedles","direction","nextKeySuffix","needlesLen","initDirection","needleBounds","needle","nb","createRange","firstPossibleNeedle","lowestPossibleCasing","casing","between","includeLower","includeUpper","_cmp","above","aboveOrEqual","below","belowOrEqual","startsWith","str","startsWithIgnoreCase","equalsIgnoreCase","anyOfIgnoreCase","startsWithAnyOfIgnoreCase","n","anyOf","_ascending","_descending","notEqual","inAnyRange","includeLowers","includeUppers","noneOf","ranges","ascending","descending","_min","max","_max","addRange","newRange","sortDirection","rangeSorter","rangePos","keyIsBeyondCurrentEntry","keyIsBeforeCurrentEntry","keyWithinCurrentRange","checkKey","startsWithAnyOf","createWhereClauseConstructor","orCollection","_IDBKeyRange","IDBKeyRange","eventRejectHandler","preventDefault","target","stopPropagation","DEXIE_STORAGE_MUTATED_EVENT_NAME","STORAGE_MUTATED_DOM_EVENT_NAME","globalEvents","Transaction","_lock","_reculock","lockOwnerFor","_unlock","_blockedFuncs","_locked","fnAndPSD","shift","OpenFailed","active","transaction","durability","chromeTransactionDurability","ev","_reject","onabort","on","oncomplete","_resolve","storagemutated","bWriteLock","ReadOnly","_root","waitFor","promiseLike","root","_waitingFor","_waitingQueue","store","objectStore","spin","_spinCount","currentWaitPromise","abort","memoizedTables","_memoizedTables","transactionBoundTable","createTransactionConstructor","dbschema","complete","wasActive","createIndexSpec","src","nameFromKeyPath","createTableSchema","safariMultiStoreFix","getMaxKey","IdbKeyRange","only","getKeyExtractor","getSinglePathKeyExtractor","arrayify","_id_counter","getKeyPathAlias","createDBCore","tmpTrans","extractSchema","tables","objectStoreNames","autoIncrement","indexByKeyPath","isPrimaryKey","indexNames","multiEntry","hasGetAll","makeIDBKeyRange","idbRange","upperBound","lowerBound","bound","createDbCoreTable","isAddOrPut","req","reqs","errorHandler","args1","args2","source","openKeyCursor","___id","_cursorContinue","_cursorContinuePrimaryKey","continuePrimaryKey","_cursorAdvance","doThrowCursorIsNotStarted","doThrowCursorIsStopped","gotOne","iterationPromise","resolveIteration","rejectIteration","guardedCallback","request","nonInfinitLimit","idbKeyRange","getAll","getAllKeys","keyCount","callbackCount","successHandler","_pos","tableMap","MIN_KEY","MAX_KEY","createMiddlewareStack","stackImpl","middlewares","down","createMiddlewareStacks","dbcore","generateMiddlewareStacks","_novip","_middlewares","tbl","setApiOnPlace","objs","tableNames","propDesc","enumerable","removeTablesApi","lowerVersionFirst","_cfg","version","runUpgraders","oldVersion","idbUpgradeTrans","globalSchema","_storeNames","rejectTransaction","createTable","populate","updateTablesAndIndexes","queue","versions","_versions","buildGlobalSchema","anyContentUpgraderHasRun","versToRun","oldSchema","newSchema","adjustToExistingIndexNames","diff","getSchemaDiff","tuple","change","recreate","Upgrade","addIndex","deleteIndex","del","idxName","contentUpgrade","upgradeSchema","contentUpgradeIsAsync","returnValue","promiseFollowed","decrementor","deleteRemovedTables","runQueue","createMissingTables","oldDef","newDef","def","oldIndexes","newIndexes","oldIdx","newIdx","createObjectStore","contains","storeName","deleteObjectStore","createIndex","dbStoreNames","j","idbindex","readGlobalSchema","verno","verifyInstalledSchema","installedSchema","ch","_hasGetAll","dexieName","indexSpec","WorkerGlobalScope","parseIndexSyntax","primKeyAndIndexes","indexNum","trim","replace","Version","_parseStoresSpec","stores","outSchema","storesSource","storesSpec","upgrade","upgradeFunction","createVersionConstructor","versionNumber","getDbNamesTable","dbNamesDB","Dexie$1","addons","dbnames","hasDatabasesNative","databases","getDatabaseNames","infos","info","_onDatabaseCreated","_onDatabaseDeleted","vip","idbReady","isSafari","userAgentData","intervalId","tryIdb","setInterval","clearInterval","dexieOpen","state","openCanceller","throwIfCancelled","resolveDbReady","dbReadyResolve","upgradeTransaction","wasCreated","dbName","autoSchema","round","onblocked","_fireOnBlocked","onupgradeneeded","allowEmptyDB","close","delreq","deleteDatabase","NoSuchDatabase","oldVer","pow","onversionchange","vcFired","onclose","onReadyBeingFired","ready","fireRemainders","remainders","awaitIterator","callNext","doThrow","throw","onSuccess","step","onError","getNext","extractTransactionArgs","_tableArgs_","scopeFunc","enterTransactionScope","parentTransaction","scopeFuncIsAsync","PrematureCommit","pad","createVirtualIndexMiddleware","indexLookup","allVirtualIndexes","addVirtualIndexes","keyTail","lowLevelIndex","keyPathAlias","indexList","keyLength","isVirtual","virtualIndex","virtualKeyPath","findBestIndex","translateRange","translateRequest","createVirtualCursor","_continue","virtualCursor","virtualIndexMiddleware","level","getObjectDiff","prfx","ap","bp","apTypeName","bpTypeName","getEffectiveKeys","hooksMiddleware","downCore","downTable","tableMiddleware","dxTrans","deleting","creating","updating","addPutOrDelete","deleteRange","getExistingValues","existingValues","contexts","existingValue","generatedPrimaryKey","objectDiff","additionalChanges","requestedValue","deleteNextChunk","effectiveKeys","getFromTransactionCache","cacheExistingValuesMiddleware","cachedResult","isEmptyRange","node","RangeSet","fromOrTree","to","d","rangeSet","mergeRanges","addKey","addKeys","getRangeSetIterator","left","right","r","rebalance","rightWasCutOff","newSet","_addRangeSet","rangesOverlap","rangeSet1","rangeSet2","i1","nextResult1","i2","nextResult2","keyProvided","up","_b","rootClone","oldRootRight","computeDepth","observabilityMiddleware","FULL_RANGE","tableClone","mutatedParts","getRangeSet","part","pkRangeSet","delsRangeSet","newObjs","oldCache","oldObjs","trackAffectedIndexes","getRange","readSubscribers","method","subscr","queriedIndex","queriedRanges","keysPromise","resultingKeys","pKeys","wantValues","pkey","addAffectedIndex","addKeyOrKeys","oldKey","newKey","deps","dependencies","cancelOpen","bSticky","newVersion","use","addon","versionInstance","_whenReady","unuse","mw","hasArguments","doDelete","backendDB","hasBeenClosed","hasFailed","dynamicallyOpened","_transaction","onlyIfCompatible","idbMode","SubTransaction","enterTransaction","InvalidTable","symbolObservable","observable","Observable","_subscribe","extendObservabilitySet","liveQuery","querier","observer","execute","exec","closed","accumMuts","currentObs","subscription","mutationListener","querying","startedListening","shouldNotify","doQuery","domDeps","mozIndexedDB","webkitIndexedDB","msIndexedDB","webkitIDBKeyRange","Dexie","databaseName","exists","ignoreTransaction","async","generatorFn","spawn","currentTransaction","promiseOrFunction","optionalTimeout","semVer","maxKey","addEventListener","updatedParts","propagatingLocally","initCustomEvent","propagateLocally","updateParts","wasMe","BroadcastChannel","bc","changedParts","postMessage","onmessage","data","localStorage","setItem","trig","random","matchAll","includeUncontrolled","client","parse","newValue","swContainer","serviceWorker","propagateMessageLocally","default"],"sources":["C:/Users/nicos/Dev/poc/poc-pwa/node_modules/dexie/dist/modern/dexie.mjs"],"sourcesContent":["/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.2, Wed Apr 27 2022\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \nconst _global = typeof globalThis !== 'undefined' ? globalThis :\n    typeof self !== 'undefined' ? self :\n        typeof window !== 'undefined' ? window :\n            global;\n\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== 'object')\n        return obj;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === 'function')\n        extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n        { value: functionOrGetSet, configurable: true, writable: true }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b)\n        throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate)\n        setImmediate(fn);\n    else\n        setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i) => {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue)\n            result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    }\n    catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (hasOwn(obj, keyPath))\n        return obj[keyPath];\n    if (!keyPath)\n        return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined)\n        return;\n    if ('isFrozen' in Object && Object.isFrozen(obj))\n        return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    }\n    else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\")\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                        obj.splice(currentKeyPath, 1);\n                    else\n                        delete obj[currentKeyPath];\n                }\n                else\n                    obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj || !hasOwn(obj, currentKeyPath))\n                    innerObj = (obj[currentKeyPath] = {});\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        }\n        else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                    obj.splice(keyPath, 1);\n                else\n                    delete obj[keyPath];\n            }\n            else\n                obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string')\n        setByKeyPath(obj, keyPath, undefined);\n    else if ('length' in keyPath)\n        [].map.call(keyPath, function (kp) {\n            setByKeyPath(obj, kp, undefined);\n        });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m))\n            rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n    .split(',').concat(flatten([8, 16, 32, 64].map(num => [\"Int\", \"Uint\", \"Float\"].map(t => t + num + \"Array\")))).filter(t => _global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);\narrayToObject(intrinsicTypeNames, x => [x, true]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== 'object')\n        return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv)\n        return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(innerDeepClone(any[i]));\n        }\n    }\n    else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    }\n    else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== 'undefined' ?\n    Symbol.iterator :\n    '@@iterator';\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () { return null; };\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike))\n            return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n            return [arrayLike];\n        if ((it = getIteratorOf(arrayLike))) {\n            a = [];\n            while ((x = it.next()), !x.done)\n                a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null)\n            return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--)\n                a[i] = arrayLike[i];\n            return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--)\n        a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== 'undefined'\n    ? (fn) => fn[Symbol.toStringTag] === 'AsyncFunction'\n    : () => false;\n\nvar debug = typeof location !== 'undefined' &&\n    /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = () => true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK)\n        try {\n            getErrorWithStack.arguments;\n            throw new Error();\n        }\n        catch (e) {\n            return e;\n        }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack)\n        return \"\";\n    numIgnoredFrames = (numIgnoredFrames || 0);\n    if (stack.indexOf(exception.name) === 0)\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n')\n        .slice(numIgnoredFrames)\n        .filter(libraryFilter)\n        .map(frame => \"\\n\" + frame)\n        .join('');\n}\n\nvar dexieErrorNames = [\n    'Modify',\n    'Bulk',\n    'OpenFailed',\n    'VersionChange',\n    'Schema',\n    'Upgrade',\n    'InvalidTable',\n    'MissingAPI',\n    'NoSuchDatabase',\n    'InvalidArgument',\n    'SubTransaction',\n    'Unsupported',\n    'Internal',\n    'DatabaseClosed',\n    'PrematureCommit',\n    'ForeignAwait'\n];\nvar idbDomErrorNames = [\n    'Unknown',\n    'Constraint',\n    'Data',\n    'TransactionInactive',\n    'ReadOnly',\n    'Version',\n    'NotFound',\n    'InvalidState',\n    'InvalidAccess',\n    'Abort',\n    'Timeout',\n    'QuotaExceeded',\n    'Syntax',\n    'DataClone'\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function () {\n            return this._stack ||\n                (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function () { return this.name + \": \" + this.message; }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures)\n        .map(key => failures[key].toString())\n        .filter((v, i, s) => s.indexOf(v) === i)\n        .join('\\n');\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map(pos => failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name) => (obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name) => {\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        }\n        else if (typeof msgOrInner === 'string') {\n            this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\n            this.inner = inner || null;\n        }\n        else if (typeof msgOrInner === 'object') {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name) => {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n        return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", { get: function () {\n                return this.inner.stack;\n            } });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name) => {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n        obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() { }\nfunction mirror(val) { return val; }\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror)\n        return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined)\n            arguments[0] = res;\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ?\n            (res2 === undefined ? undefined : res2) :\n            (extend(res, res2));\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false)\n            return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while (i--)\n                args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100,\nMAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ?\n    [] :\n    (() => {\n        let globalP = Promise.resolve();\n        if (typeof crypto === 'undefined' || !crypto.subtle)\n            return [globalP, getProto(globalP), globalP];\n        const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n        return [\n            nativeP,\n            getProto(nativeP),\n            globalP\n        ];\n    })(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ?\n    () => { resolvedGlobalPromise.then(physicalTick); }\n    :\n        _global.setImmediate ?\n            setImmediate.bind(null, physicalTick) :\n            _global.MutationObserver ?\n                () => {\n                    var hiddenDiv = document.createElement(\"div\");\n                    (new MutationObserver(() => {\n                        physicalTick();\n                        hiddenDiv = null;\n                    })).observe(hiddenDiv, { attributes: true });\n                    hiddenDiv.setAttribute('i', '1');\n                } :\n                () => { setTimeout(physicalTick, 0); };\nvar asap = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true,\nneedsNewPhysicalTick = true,\nunhandledErrors = [],\nrejectingErrors = [],\ncurrentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n        this.unhandleds.forEach(uh => {\n            try {\n                globalError(uh[0], uh[1]);\n            }\n            catch (e) { }\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== 'object')\n        throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = (this._PSD = PSD);\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL)\n            throw new TypeError('Not a function');\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false)\n            handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nconst thenProp = {\n    get: function () {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject) => {\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function (value) {\n        setProp(this, 'then', value && value.prototype === INTERNAL ?\n            thenProp :\n            {\n                get: function () {\n                    return value;\n                },\n                set: thenProp.set\n            });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function (onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function (onRejected) {\n        if (arguments.length === 1)\n            return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, err =>\n        err instanceof type ? handler(err) : PromiseReject(err))\n            : this.then(null, err =>\n            err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function (onFinally) {\n        return this.then(value => {\n            onFinally();\n            return value;\n        }, err => {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function () {\n            if (this._stack)\n                return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null)\n                    this._stack = stack;\n                return stack;\n            }\n            finally {\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function (ms, msg) {\n        return ms < Infinity ?\n            new DexiePromise((resolve, reject) => {\n                var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n                this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n            }) : this;\n    }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments)\n            .map(onPossibleParallellAsync);\n        return new DexiePromise(function (resolve, reject) {\n            if (values.length === 0)\n                resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\n                values[i] = x;\n                if (!--remaining)\n                    resolve(values);\n            }, reject));\n        });\n    },\n    resolve: value => {\n        if (value instanceof DexiePromise)\n            return value;\n        if (value && typeof value.then === 'function')\n            return new DexiePromise((resolve, reject) => {\n                value.then(resolve, reject);\n            });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function () {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject) => {\n            values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: () => PSD,\n        set: value => PSD = value\n    },\n    totalEchoes: { get: () => totalEchoes },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: () => asap,\n        set: value => { asap = value; }\n    },\n    rejectionMapper: {\n        get: () => rejectionMapper,\n        set: value => { rejectionMapper = value; }\n    },\n    follow: (fn, zoneProps) => {\n        return new DexiePromise((resolve, reject) => {\n            return newScope((resolve, reject) => {\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function () {\n                    run_at_end_of_this_or_next_physical_tick(() => {\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled)\n        setProp(DexiePromise, \"allSettled\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(resolve => {\n                if (possiblePromises.length === 0)\n                    resolve([]);\n                let remaining = possiblePromises.length;\n                const results = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = { status: \"fulfilled\", value }, reason => results[i] = { status: \"rejected\", reason })\n                    .then(() => --remaining || resolve(results)));\n            });\n        });\n    if (NativePromise.any && typeof AggregateError !== 'undefined')\n        setProp(DexiePromise, \"any\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise((resolve, reject) => {\n                if (possiblePromises.length === 0)\n                    reject(new AggregateError([]));\n                let remaining = possiblePromises.length;\n                const failures = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {\n                    failures[i] = failure;\n                    if (!--remaining)\n                        reject(new AggregateError(failures));\n                }));\n            });\n        });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn(value => {\n            if (promise._state !== null)\n                return;\n            if (value === promise)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, (resolve, reject) => {\n                    value instanceof DexiePromise ?\n                        value._then(resolve, reject) :\n                        value.then(resolve, reject);\n                });\n            }\n            else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick)\n                endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    }\n    catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null)\n        return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: () => stack_being_generated ?\n                origProp && (origProp.get ?\n                    origProp.get.apply(reason) :\n                    origProp.value) :\n                promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick)\n        endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(() => {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [cb, promise, listener]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        }\n        else {\n            if (rejectingErrors.length)\n                rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1)\n                markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    }\n    catch (e) {\n        listener.reject(e);\n    }\n    finally {\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit)\n        return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        }\n        else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1)\n            stacks.push(stack);\n        if (promise._prev)\n            getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(p => {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while (i)\n        finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(() => {\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some(p => p._value === promise._value))\n        unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while (i)\n        if (unhandledErrors[--i]._value === promise._value) {\n            unhandledErrors.splice(i, 1);\n            return;\n        }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        }\n        catch (e) {\n            errorCatcher && errorCatcher(e);\n        }\n        finally {\n            switchToZone(outerScope, false);\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    };\n}\nconst task = { awaits: 0, echoes: 0, id: 0 };\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props)\n        extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0)\n        psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id)\n        task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits)\n        return false;\n    if (--task.awaits === 0)\n        task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then(x => {\n            decrementExpectedAwaits();\n            return x;\n        }, e => {\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD)\n        return;\n    PSD = targetZone;\n    if (currentZone === globalPSD)\n        globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled)\n                GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any)\n                GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    }\n    finally {\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== 'function' ? fn : function () {\n        var outerZone = PSD;\n        if (possibleAwait)\n            incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        }\n        finally {\n            switchToZone(outerZone, false);\n            if (cleanup)\n                enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function (onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    }\n    catch (e) { }\n    if (rv !== false)\n        try {\n            var event, eventData = { promise: promise, reason: err };\n            if (_global.document && document.createEvent) {\n                event = document.createEvent('Event');\n                event.initEvent(UNHANDLEDREJECTION, true, true);\n                extend(event, eventData);\n            }\n            else if (_global.CustomEvent) {\n                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\n                extend(event, eventData);\n            }\n            if (event && _global.dispatchEvent) {\n                dispatchEvent(event);\n                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                    try {\n                        _global.onunhandledrejection(event);\n                    }\n                    catch (_) { }\n            }\n            if (debug && event && !event.defaultPrevented) {\n                console.warn(`Unhandled rejection: ${err.stack || err}`);\n            }\n        }\n        catch (e) { }\n}\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen)\n                return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n    }\n    else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n            db._state.PR1398_maxLoop = 3;\n        }\n        catch (ex) {\n            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                console.warn('Dexie: Need to reopen db');\n                db._close();\n                return db.open().then(() => tempTransaction(db, mode, storeNames, fn));\n            }\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject) => {\n            return newScope(() => {\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then(result => {\n            return trans._completion.then(() => result);\n        });\n    }\n}\n\nconst DEXIE_VERSION = '3.2.2';\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = '__dbnames';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n    return filter1 ?\n        filter2 ?\n            function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n            filter1 :\n        filter2;\n}\n\nconst AnyRange = {\n    type: 3 ,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [[]],\n    upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n        ? (obj) => {\n            if (obj[keyPath] === undefined && (keyPath in obj)) {\n                obj = deepClone(obj);\n                delete obj[keyPath];\n            }\n            return obj;\n        }\n        : (obj) => obj;\n}\n\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName])\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ?\n                trans === PSD.trans ?\n                    trans._promise(mode, checkTableInTransaction, writeLocked) :\n                    newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans: trans, transless: PSD.transless || PSD }) :\n                tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n        }\n        finally {\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object)\n            return this.where(keyOrCrit).first(cb);\n        return this._trans('readonly', (trans) => {\n            return this.core.get({ trans, key: keyOrCrit })\n                .then(res => this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === 'string')\n            return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit))\n            return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1)\n            return this\n                .where(keyPaths[0])\n                .equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound &&\n            keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) &&\n            ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];\n        if (compoundIndex && this.db._maxKey !== maxString)\n            return this\n                .where(compoundIndex.name)\n                .equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));\n        if (!compoundIndex && debug)\n            console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` +\n                `compound index [${keyPaths.join('+')}]`);\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ?\n                    combine(prevFilterFn, index && index.multi ?\n                        x => {\n                            const prop = getByKeyPath(x, keyPath);\n                            return isArray(prop) && prop.some(item => equals(value, item));\n                        } : x => equals(value, getByKeyPath(x, keyPath)))\n                    : prevFilterFn\n            ];\n        }, [null, null]);\n        return idx ?\n            this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                .filter(filterFunction) :\n            compoundIndex ?\n                this.filter(filterFunction) :\n                this.where(keyPaths).equals('');\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n            `[${index.join('+')}]` :\n            index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        this.schema.mappedClass = constructor;\n        const readHook = obj => {\n            if (!obj)\n                return obj;\n            const res = Object.create(constructor.prototype);\n            for (var m in obj)\n                if (hasOwn(obj, m))\n                    try {\n                        res[m] = obj[m];\n                    }\n                    catch (_) { }\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n        }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined)\n                return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach(keyPath => {\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                }\n                else {\n                    modifications(keyOrObject, { value: keyOrObject, primKey: key });\n                }\n            }\n            catch (_a) {\n            }\n            return this.where(\":id\").equals(key).modify(modifications);\n        }\n        else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'delete', keys: [key] }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'deleteRange', range: AnyRange }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans('readonly', trans => {\n            return this.core.getMany({\n                keys,\n                trans\n            }).then(result => result.map(res => this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'add', keys: keys, values: objectsToAdd, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'put', keys: keys, values: objectsToPut, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'delete', keys: keys });\n        }).then(({ numFailures, lastResult, failures }) => {\n            if (numFailures === 0)\n                return lastResult;\n            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n        });\n    }\n}\n\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while (--i)\n                args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        }\n        else if (typeof (eventName) === 'string') {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object')\n            return addConfiguredEvents(eventName);\n        if (!chainFunction)\n            chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction)\n            defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            }\n            else if (args === 'asap') {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while (i--)\n                        args[i] = arguments[i];\n                    context.subscribers.forEach(function (fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            }\n            else\n                throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({ prototype });\n    return constructor;\n}\n\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [hookCreatingChain, nop],\n            \"reading\": [pureFunctionChain, mirror],\n            \"updating\": [hookUpdatingChain, nop],\n            \"deleting\": [hookDeletingChain, nop]\n        });\n    });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) &&\n        (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey)\n        return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index)\n        throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === 'prev',\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    }\n    else {\n        const set = {};\n        const union = (item, cursor, advance) => {\n            if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = '' + primaryKey;\n                if (key === '[object ArrayBuffer]')\n                    key = '' + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then(cursor => {\n        if (cursor) {\n            return cursor.start(() => {\n                var c = () => cursor.continue();\n                if (!filter || filter(cursor, advancer => c = advancer, val => { cursor.stop(val); c = nop; }, e => { cursor.fail(e); c = nop; }))\n                    wrappedFn(cursor.value, cursor, advancer => c = advancer);\n                c();\n            });\n        }\n    });\n}\n\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === 'Array')\n                return 1;\n            if (tb === 'Array')\n                return -1;\n            if (ta === 'binary')\n                return 1;\n            if (tb === 'binary')\n                return -1;\n            if (ta === 'string')\n                return 1;\n            if (tb === 'string')\n                return -1;\n            if (ta === 'Date')\n                return 1;\n            if (tb !== 'Date')\n                return NaN;\n            return -1;\n        }\n        switch (ta) {\n            case 'number':\n            case 'Date':\n            case 'string':\n                return a > b ? 1 : a < b ? -1 : 0;\n            case 'binary': {\n                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n            }\n            case 'Array':\n                return compareArrays(a, b);\n        }\n    }\n    catch (_a) { }\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        const res = cmp(a[i], b[i]);\n        if (res !== 0)\n            return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        if (a[i] !== b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== 'object')\n        return t;\n    if (ArrayBuffer.isView(x))\n        return 'binary';\n    const tsTag = toStringTag(x);\n    return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array)\n        return a;\n    if (ArrayBuffer.isView(a))\n        return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\n\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readonly', fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readwrite', fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props)\n            extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read(trans => {\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then(count => Math.min(count, ctx.limit));\n            }\n            else {\n                var count = 0;\n                return iter(ctx, () => { ++count; return false; }, trans, coreTable)\n                    .then(() => count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i)\n                return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function (a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read(trans => {\n            var ctx = this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);\n            }\n            else {\n                const a = [];\n                return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0)\n            return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return (cursor, advance) => {\n                    if (offsetLeft === 0)\n                        return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(() => {\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        }\n        else {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return () => (--offsetLeft < 0);\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, () => {\n            var rowsLeft = numRows;\n            return function (cursor, advance, resolve) {\n                if (--rowsLeft <= 0)\n                    advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function (cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            }\n            else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function (cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n        if (this._ondirectionchange)\n            this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.key);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read(trans => {\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then(({ result }) => result).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi)\n            return this;\n        var set = {};\n        addFilter(this._ctx, function (cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write(trans => {\n            var modifyer;\n            if (typeof changes === 'function') {\n                modifyer = changes;\n            }\n            else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function (item) {\n                    var anythingModified = false;\n                    for (var i = 0; i < numKeys; ++i) {\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res) => {\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)) {\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then(keys => {\n                const nextChunk = (offset) => {\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then(values => {\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for (let i = 0; i < count; ++i) {\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                }\n                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                }\n                                else {\n                                    putValues.push(ctx.value);\n                                    if (outbound)\n                                        putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) &&\n                            ctx.limit === Infinity &&\n                            (typeof changes !== 'function' || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 &&\n                            coreTable.mutate({ trans, type: 'add', values: addValues })\n                                .then(res => {\n                                for (let pos in res.failures) {\n                                    deleteKeys.splice(parseInt(pos), 1);\n                                }\n                                applyMutateResult(addValues.length, res);\n                            })).then(() => (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'put',\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== 'function'\n                                    && changes\n                            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'delete',\n                                keys: deleteKeys,\n                                criteria\n                            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(() => {\n                    if (totalFailures.length > 0)\n                        throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) &&\n            ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))\n         {\n            return this._write(trans => {\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(count => {\n                    return ctx.table.core.mutate({ trans, type: 'deleteRange', range: coreRange })\n                        .then(({ failures, lastResult, results, numFailures }) => {\n                        if (numFailures)\n                            throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(pos => failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx) => ctx.value = null;\n\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator)\n            try {\n                keyRange = keyRangeGenerator();\n            }\n            catch (ex) {\n                error = ex;\n            }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\n\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ?\n        new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n        collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, () => rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toUpperCase() :\n        (s) => s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toLowerCase() :\n        (s) => s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for (var i = 0; i < length; ++i) {\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0)\n                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0)\n                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0)\n                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0)\n            llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\")\n        return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\")\n        return key.substr(0, upperNeedle.length);\n    return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every(s => typeof s === 'string')) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n        var needleBounds = needles.map(function (needle) {\n            return { lower: lower(needle), upper: upper(needle) };\n        }).sort(function (a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n        lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n        direction = dir;\n        nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function (direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== 'string')\n            return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        }\n        else {\n            var lowestPossibleCasing = null;\n            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null)\n                    firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n            }\n            else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2 ,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1 ,\n        lower: value,\n        upper: value\n    };\n}\n\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if ((this._cmp(lower, upper) > 0) ||\n                (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                return emptyCollection(this);\n            return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => rangeEqual(value));\n    }\n    above(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== 'string')\n            return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\")\n            return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = direction => {\n            compare = (direction === \"next\" ?\n                this._ascending :\n                this._descending);\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve) => {\n            const key = cursor.key;\n            while (compare(key, set[i]) > 0) {\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            }\n            else {\n                advance(() => { cursor.continue(set[i]); });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val) => res ?\n            res.concat([[res[res.length - 1][1], val]]) :\n            [[minKey, val]], null);\n        ranges.push([set[set.length - 1], this.db._maxKey]);\n        return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0)\n            return emptyCollection(this);\n        if (!ranges.every(range => range[0] !== undefined &&\n            range[1] !== undefined &&\n            ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for (; i < l; ++i) {\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l)\n                ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        }\n        catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ?\n            key => ascending(key, set[rangePos][1]) > 0 :\n            key => ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ?\n            key => descending(key, set[rangePos][0]) > 0 :\n            key => descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = direction => {\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            }\n            else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve) => {\n            var key = cursor.key;\n            while (checkKey(key)) {\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            }\n            else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            }\n            else {\n                advance(() => {\n                    if (sortDirection === ascending)\n                        cursor.continue(set[rangePos][0]);\n                    else\n                        cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every(s => typeof s === 'string')) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        return this.inAnyRange(set.map((str) => [str, str + maxString]));\n    }\n}\n\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB = db._deps.indexedDB;\n        if (!indexedDB)\n            throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n        this._descending = (a, b) => indexedDB.cmp(b, a);\n        this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\n\nfunction eventRejectHandler(reject) {\n    return wrap(function (event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation)\n        event.stopPropagation();\n    if (event.preventDefault)\n        event.preventDefault();\n}\n\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nconst STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global)\n            PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global)\n                PSD.lockOwnerFor = null;\n            while (this._blockedFuncs.length > 0 && !this._locked()) {\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                }\n                catch (e) { }\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode)\n            return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch (dbOpenError && dbOpenError.name) {\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active)\n            throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans ||\n            (this.db.core\n                ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n        idbtrans.onerror = wrap(ev => {\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap(ev => {\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(() => {\n            this.active = false;\n            this._resolve();\n            if ('mutatedParts' in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === 'readwrite' && this.mode !== 'readwrite')\n            return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active)\n            return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject) => {\n                this._blockedFuncs.push([() => {\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    }, PSD]);\n            });\n        }\n        else if (bWriteLock) {\n            return newScope(() => {\n                var p = new DexiePromise((resolve, reject) => {\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p.finally(() => this._unlock());\n                p._lib = true;\n                return p;\n            });\n        }\n        else {\n            var p = new DexiePromise((resolve, reject) => {\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then)\n                    rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(() => promise);\n        }\n        else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while (root._waitingQueue.length)\n                    (root._waitingQueue.shift())();\n                if (root._waitingFor)\n                    store.get(-Infinity).onsuccess = spin;\n            }());\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject) => {\n            promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans)\n                this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n        if (hasOwn(memoizedTables, tableName))\n            return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\n\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(() => {\n            this.active = false;\n            this.on.complete.fire();\n        }, e => {\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ?\n                this.parent._reject(e) :\n                wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === 'string' ?\n        keyPath :\n        keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, index => [index.name, index])\n    };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange) => {\n    try {\n        IdbKeyRange.only([[]]);\n        getMaxKey = () => [[]];\n        return [[]];\n    }\n    catch (e) {\n        getMaxKey = () => maxString;\n        return maxString;\n    }\n};\n\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return () => undefined;\n    }\n    else if (typeof keyPath === 'string') {\n        return getSinglePathKeyExtractor(keyPath);\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split('.');\n    if (split.length === 1) {\n        return obj => obj[keyPath];\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\n\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ?\n        \":id\" :\n        typeof keyPath === 'string' ?\n            keyPath :\n            `[${keyPath.join('+')}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map(table => trans.objectStore(table)).map(store => {\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map(indexName => store.index(indexName))\n                            .map(index => {\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath) => indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                    !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                    [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3 )\n            return null;\n        if (range.type === 4 )\n            throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ?\n            upper === undefined ?\n                null :\n                IdbKeyRange.upperBound(upper, !!upperOpen) :\n            upper === undefined ?\n                IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate({ trans, type, keys, values, range }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                    throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || { length: 1 };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0)\n                    return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = event => {\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === 'deleteRange') {\n                    if (range.type === 4 )\n                        return resolve({ numFailures, failures, results: [], lastResult: undefined });\n                    if (range.type === 3 )\n                        reqs.push(req = store.clear());\n                    else\n                        reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                }\n                else {\n                    const [args1, args2] = isAddOrPut ?\n                        outbound ?\n                            [values, keys] :\n                            [values, null] :\n                        [keys, null];\n                    if (isAddOrPut) {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = (args2 && args2[i] !== undefined ?\n                                store[type](args1[i], args2[i]) :\n                                store[type](args1[i])));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                    else {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = event => {\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map(req => req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = event => {\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor({ trans, values, query, reverse, unique }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ?\n                    store :\n                    store.index(index.name);\n                const direction = reverse ?\n                    unique ?\n                        \"prevunique\" :\n                        \"prev\" :\n                    unique ?\n                        \"nextunique\" :\n                        \"next\";\n                const req = values || !('openKeyCursor' in source) ?\n                    source.openCursor(makeIDBKeyRange(range), direction) :\n                    source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap(ev => {\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey)\n                        _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = () => { throw new Error(\"Cursor not started\"); };\n                    const doThrowCursorIsStopped = () => { throw new Error(\"Cursor not stopped\"); };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function () {\n                        let gotOne = 1;\n                        return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n                    };\n                    cursor.start = (callback) => {\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration) => {\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = value => {\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = () => {\n                            if (req.result) {\n                                try {\n                                    callback();\n                                }\n                                catch (err) {\n                                    cursor.fail(err);\n                                }\n                            }\n                            else {\n                                cursor.done = true;\n                                cursor.start = () => { throw new Error(\"Cursor behind last entry\"); };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap(ev => {\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request) => {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0)\n                        return resolve({ result: [] });\n                    if (hasGetAll) {\n                        const req = values ?\n                            source.getAll(idbKeyRange, nonInfinitLimit) :\n                            source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = event => resolve({ result: event.target.result });\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                    else {\n                        let count = 0;\n                        const req = values || !('openKeyCursor' in source) ?\n                            source.openCursor(idbKeyRange) :\n                            source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = event => {\n                            const cursor = req.result;\n                            if (!cursor)\n                                return resolve({ result });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit)\n                                return resolve({ result });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany({ trans, keys }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = event => {\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null)\n                            ;\n                        if (++callbackCount === keyCount)\n                            resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for (let i = 0; i < length; ++i) {\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0)\n                        resolve(result);\n                });\n            },\n            get({ trans, key }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = event => resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count({ query, trans }) {\n                const { index, range } = query;\n                return new Promise((resolve, reject) => {\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap(ev => resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach(table => tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table(name) {\n            const result = tableMap[name];\n            if (!result)\n                throw new Error(`Table '${name}' not found`);\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB }, tmpTrans) {\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks({ _novip: db }, tmpTrans) {\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach(table => {\n        const tableName = table.name;\n        if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\n\nfunction setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {\n    tableNames.forEach(tableName => {\n        const schema = dbschema[tableName];\n        objs.forEach(obj => {\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get() { return this.table(tableName); },\n                        set(value) {\n                            defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });\n                        }\n                    });\n                }\n                else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi({ _novip: db }, objs) {\n    objs.forEach(obj => {\n        for (let key in obj) {\n            if (obj[key] instanceof db.Table)\n                delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(() => {\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach(tableName => {\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n        }\n        else\n            updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n    versToRun.forEach(version => {\n        queue.push(() => {\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach(tuple => {\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach(change => {\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                }\n                else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach(idx => addIndex(store, idx));\n                    change.change.forEach(idx => {\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach(idxName => store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach(table => {\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(() => {\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return (returnValue && typeof returnValue.then === 'function' ?\n                    DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue));\n            }\n        });\n        queue.push(idbtrans => {\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [db.Transaction.prototype]);\n            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n            DexiePromise.resolve();\n    }\n    return runQueue().then(() => {\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for (table in oldSchema) {\n        if (!newSchema[table])\n            diff.del.push(table);\n    }\n    for (table in newSchema) {\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([table, newDef]);\n        }\n        else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if ((\n            '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))\n             {\n                change.recreate = true;\n                diff.change.push(change);\n            }\n            else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for (idxName in oldIndexes) {\n                    if (!newIndexes[idxName])\n                        change.del.push(idxName);\n                }\n                for (idxName in newIndexes) {\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx)\n                        change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src)\n                        change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n        { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n        { autoIncrement: primKey.auto });\n    indexes.forEach(idx => addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach(tableName => {\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach(storeName => {\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {\n    const storeNames = idbtrans.db.objectStoreNames;\n    for (let i = 0; i < storeNames.length; ++i) {\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = 'getAll' in store;\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n        _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(',').map((index, indexNum) => {\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\n\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach(tableName => {\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi)\n                    throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach(idx => {\n                    if (idx.auto)\n                        throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath)\n                        throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ?\n            extend(this._cfg.storesSource, stores) :\n            stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach(version => {\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = (version._cfg.dbschema = {});\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n        setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\n\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n    let dbNamesDB = indexedDB[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB,\n            IDBKeyRange,\n        });\n        dbNamesDB.version(1).stores({ dbnames: \"name\" });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB) {\n    return indexedDB && typeof indexedDB.databases === \"function\";\n}\nfunction getDatabaseNames({ indexedDB, IDBKeyRange, }) {\n    return hasDatabasesNative(indexedDB)\n        ? Promise.resolve(indexedDB.databases()).then((infos) => infos\n            .map((info) => info.name)\n            .filter((name) => name !== DBNAMES_DB))\n        : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).put({ name }).catch(nop);\n}\nfunction _onDatabaseDeleted({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n    return newScope(function () {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\n\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB } = db._deps;\n    if (state.isBeingOpened || db.idbdb)\n        return state.dbReadyPromise.then(() => state.dbOpenError ?\n            rejection(state.dbOpenError) :\n            db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller)\n            throw new exceptions.DatabaseClosed('db.open() was cancelled');\n    }\n    let resolveDbReady = state.dbReadyResolve,\n    upgradeTransaction = null, wasCreated = false;\n    return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {\n            throwIfCancelled();\n            if (!indexedDB)\n                throw new exceptions.MissingAPI();\n            const dbName = db.name;\n            const req = state.autoSchema ?\n                indexedDB.open(dbName) :\n                indexedDB.open(dbName, Math.round(db.verno * 10));\n            if (!req)\n                throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap(e => {\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    const delreq = indexedDB.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(() => {\n                        reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n                    });\n                }\n                else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db._novip.idbdb = req.result;\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(() => {\n                upgradeTransaction = null;\n                const idbdb = db._novip.idbdb = req.result;\n                const objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0)\n                    try {\n                        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                        if (state.autoSchema)\n                            readGlobalSchema(db, idbdb, tmpTrans);\n                        else {\n                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                            if (!verifyInstalledSchema(db, tmpTrans)) {\n                                console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                            }\n                        }\n                        generateMiddlewareStacks(db, tmpTrans);\n                    }\n                    catch (e) {\n                    }\n                connections.push(db);\n                idbdb.onversionchange = wrap(ev => {\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap(ev => {\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated)\n                    _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }))]).then(() => {\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(() => {\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(() => {\n        return db;\n    }).catch(err => {\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        }\n        catch (_a) { }\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(() => {\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\n\nfunction awaitIterator(iterator) {\n    var callNext = result => iterator.next(result), doThrow = error => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val) => {\n            var next = getNext(val), value = next.value;\n            return next.done ? value :\n                (!value || typeof value.then !== 'function' ?\n                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                    value.then(onSuccess, onError));\n        };\n    }\n    return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2)\n        throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while (--i)\n        args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [mode, tables, scopeFunc];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(() => {\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        }\n        else {\n            try {\n                trans.create();\n                db._state.PR1398_maxLoop = 3;\n            }\n            catch (ex) {\n                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                    console.warn('Dexie: Need to reopen db');\n                    db._close();\n                    return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));\n                }\n                return rejection(ex);\n            }\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(() => {\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                }\n                else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === 'function' ?\n            DexiePromise.resolve(returnValue).then(x => trans.active ?\n                x\n                : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")))\n            : promiseFollowed.then(() => returnValue)).then(x => {\n            if (parentTransaction)\n                trans._resolve();\n            return trans._completion.then(() => x);\n        }).catch(e => {\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\n\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [a];\n    for (let i = 0; i < count; ++i)\n        result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table(tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ?\n                        keyPath[0] :\n                        keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b) => a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [primaryKey];\n            for (const index of schema.indexes) {\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1  ?\n                        2  :\n                        range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count(req) {\n                    return table.count(translateRequest(req));\n                },\n                query(req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor(req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual)\n                        return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ?\n                                cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                req.unique ?\n                                    cursor.continue(cursor.key.slice(0, keyLength)\n                                        .concat(req.reverse\n                                        ? down.MIN_KEY\n                                        : down.MAX_KEY, keyTail)) :\n                                    cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: { value: _continue },\n                            continuePrimaryKey: {\n                                value(key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get() {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get() {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ?\n                                        key[0] :\n                                        key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get() {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req))\n                        .then(cursor => cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach((prop) => {\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        }\n        else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                }\n                else if (apTypeName === 'Object') {\n                    getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                }\n                else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            }\n            else if (ap !== bp)\n                rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop) => {\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === 'delete')\n        return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore) => ({\n        ...downCore,\n        table(tableName) {\n            const downTable = downCore.table(tableName);\n            const { primaryKey } = downTable.schema;\n            const tableMiddleware = {\n                ...downTable,\n                mutate(req) {\n                    const dxTrans = PSD.trans;\n                    const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                    switch (req.type) {\n                        case 'add':\n                            if (creating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'put':\n                            if (creating.fire === nop && updating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'delete':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'deleteRange':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => deleteRange(req), true);\n                    }\n                    return downTable.mutate(req);\n                    function addPutOrDelete(req) {\n                        const dxTrans = PSD.trans;\n                        const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                        if (!keys)\n                            throw new Error(\"Keys missing\");\n                        req = req.type === 'add' || req.type === 'put' ?\n                            { ...req, keys } :\n                            { ...req };\n                        if (req.type !== 'delete')\n                            req.values = [...req.values];\n                        if (req.keys)\n                            req.keys = [...req.keys];\n                        return getExistingValues(downTable, req, keys).then(existingValues => {\n                            const contexts = keys.map((key, i) => {\n                                const existingValue = existingValues[i];\n                                const ctx = { onerror: null, onsuccess: null };\n                                if (req.type === 'delete') {\n                                    deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                }\n                                else if (req.type === 'add' || existingValue === undefined) {\n                                    const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                    if (key == null && generatedPrimaryKey != null) {\n                                        key = generatedPrimaryKey;\n                                        req.keys[i] = key;\n                                        if (!primaryKey.outbound) {\n                                            setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                        }\n                                    }\n                                }\n                                else {\n                                    const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                    const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                    if (additionalChanges) {\n                                        const requestedValue = req.values[i];\n                                        Object.keys(additionalChanges).forEach(keyPath => {\n                                            if (hasOwn(requestedValue, keyPath)) {\n                                                requestedValue[keyPath] = additionalChanges[keyPath];\n                                            }\n                                            else {\n                                                setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                            }\n                                        });\n                                    }\n                                }\n                                return ctx;\n                            });\n                            return downTable.mutate(req).then(({ failures, results, numFailures, lastResult }) => {\n                                for (let i = 0; i < keys.length; ++i) {\n                                    const primKey = results ? results[i] : keys[i];\n                                    const ctx = contexts[i];\n                                    if (primKey == null) {\n                                        ctx.onerror && ctx.onerror(failures[i]);\n                                    }\n                                    else {\n                                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                            req.values[i] :\n                                            primKey\n                                        );\n                                    }\n                                }\n                                return { failures, results, numFailures, lastResult };\n                            }).catch(error => {\n                                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                                return Promise.reject(error);\n                            });\n                        });\n                    }\n                    function deleteRange(req) {\n                        return deleteNextChunk(req.trans, req.range, 10000);\n                    }\n                    function deleteNextChunk(trans, range, limit) {\n                        return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit })\n                            .then(({ result }) => {\n                            return addPutOrDelete({ type: 'delete', keys: result, trans }).then(res => {\n                                if (res.numFailures > 0)\n                                    return Promise.reject(res.failures[0]);\n                                if (result.length < limit) {\n                                    return { failures: [], numFailures: 0, lastResult: undefined };\n                                }\n                                else {\n                                    return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);\n                                }\n                            });\n                        });\n                    }\n                }\n            };\n            return tableMiddleware;\n        },\n    })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\"\n        ? Promise.resolve([])\n        : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache)\n            return null;\n        if (cache.keys.length < keys.length)\n            return null;\n        const result = [];\n        for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n            if (cmp(cache.keys[i], keys[j]) !== 0)\n                continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    }\n    catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core) => {\n        return {\n            table: (tableName) => {\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req) => {\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res) => {\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res,\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req) => {\n                        if (req.type !== \"add\")\n                            req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    },\n                };\n            },\n        };\n    },\n};\n\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function (fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n    }\n    else {\n        const rv = new RangeSet();\n        if (fromOrTree && (\"d\" in fromOrTree)) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, {\n    add(rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey(key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys(keys) {\n        keys.forEach(key => addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol]() {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff))\n        return;\n    if (diff > 0)\n        throw RangeError();\n    if (isEmptyRange(target))\n        return extend(target, { from, to, d: 1 });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left\n            ? addRange(left, from, to)\n            : (target.l = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right\n            ? addRange(right, from, to)\n            : (target.r = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, { from, to, l, r }) {\n        addRange(target, from, to);\n        if (l)\n            _addRangeSet(target, l);\n        if (r)\n            _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet))\n        _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done)\n        return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while (!nextResult1.done && !nextResult2.done) {\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n            return true;\n        cmp(a.from, b.from) < 0\n            ? (a = (nextResult1 = i1.next(b.from)).value)\n            : (b = (nextResult2 = i2.next(a.from)).value);\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : { s: 0, n: node };\n    return {\n        next(key) {\n            const keyProvided = arguments.length > 0;\n            while (state) {\n                switch (state.s) {\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while (state.n.l && cmp(key, state.n.from) < 0)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                        else {\n                            while (state.n.l)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0)\n                            return { value: state.n, done: false };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = { up: state, n: state.n.r, s: 0 };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return { done: true };\n        },\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = { ...target };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth({ r, l }) {\n    return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n}\n\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core) => {\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName) => {\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req) => {\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName) => {\n                            const part = `idb://${dbName}/${tableName}/${indexName}`;\n                            return (mutatedParts[part] ||\n                                (mutatedParts[part] = new RangeSet()));\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\"\n                            ? [req.range]\n                            : req.type === \"delete\"\n                                ? [req.keys]\n                                : req.values.length < 50\n                                    ? [[], req.values]\n                                    : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res) => {\n                            if (isArray(keys)) {\n                                if (type !== \"delete\")\n                                    keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                const range = { from: keys.lower, to: keys.upper };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    },\n                };\n                const getRange = ({ query: { index, range }, }) => {\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY),\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req) => [primaryKey, new RangeSet(req.key)],\n                    getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange,\n                };\n                keys(readSubscribers).forEach(method => {\n                    tableClone[method] = function (req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName) => {\n                                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                                return (subscr[part] ||\n                                    (subscr[part] = new RangeSet()));\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                }\n                                else {\n                                    const keysPromise = method === \"query\" &&\n                                        outbound &&\n                                        req.values &&\n                                        table.query({\n                                            ...req,\n                                            values: false,\n                                        });\n                                    return table[method].apply(this, arguments).then((res) => {\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then(({ result: resultingKeys }) => {\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values\n                                                ? res.result.map(extractKey)\n                                                : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            }\n                                            else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        }\n                                        else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return (cursor &&\n                                                Object.create(cursor, {\n                                                    key: {\n                                                        get() {\n                                                            delsRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.key;\n                                                        },\n                                                    },\n                                                    primaryKey: {\n                                                        get() {\n                                                            const pkey = cursor.primaryKey;\n                                                            delsRangeSet.addKey(pkey);\n                                                            return pkey;\n                                                        },\n                                                    },\n                                                    value: {\n                                                        get() {\n                                                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.value;\n                                                        },\n                                                    },\n                                                }));\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            },\n        };\n    },\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key) => ix.multiEntry && isArray(key)\n            ? key.forEach(key => rangeSet.addKey(key))\n            : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i) => {\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null)\n                    addKeyOrKeys(oldKey);\n                if (newKey != null)\n                    addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\n\nclass Dexie$1 {\n    constructor(name, options) {\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons, } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true,\n            PR1398_maxLoop: 3\n        };\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n            return (subscriber, bSticky) => {\n                Dexie$1.vip(() => {\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError)\n                            DexiePromise.resolve().then(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky)\n                            subscribe(function unsubscribe() {\n                                db.on.ready.unsubscribe(subscriber);\n                                db.on.ready.unsubscribe(unsubscribe);\n                            });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", ev => {\n            if (ev.newVersion > 0)\n                console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n            else\n                console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n            this.close();\n        });\n        this.on(\"blocked\", ev => {\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                console.warn(`Dexie.delete('${this.name}') was blocked`);\n            else\n                console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = ev => {\n            this.on(\"blocked\").fire(ev);\n            connections\n                .filter(c => c.name === this.name && c !== this && !c._state.vcFired)\n                .map(c => c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, { _vip: { value: true } });\n        addons.forEach(addon => addon(this));\n    }\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1)\n            throw new exceptions.Type(`Given version is not a positive number`);\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened)\n            throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];\n        if (versionInstance)\n            return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise((resolve, reject) => {\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use({ stack, create, level, name }) {\n        if (name)\n            this.unuse({ stack, name });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({ stack, create, level: level == null ? 10 : level, name });\n        middlewares.sort((a, b) => a.level - b.level);\n        return this;\n    }\n    unuse({ stack, name, create }) {\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create :\n                name ? mw.name !== name :\n                    false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0)\n            connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            }\n            catch (e) { }\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened)\n            state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject) => {\n            const doDelete = () => {\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(() => {\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments)\n                throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            }\n            else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map(name => this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n            parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf('?') !== -1;\n        mode = mode.replace('!', '').replace('?', '');\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map(table => {\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== 'string')\n                    throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY)\n                idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE)\n                idbMode = READWRITE;\n            else\n                throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    }\n                    else\n                        throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach(storeName => {\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            }\n                            else\n                                throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                    \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        }\n        catch (e) {\n            return parentTransaction ?\n                parentTransaction._promise(null, (_, reject) => { reject(e); }) :\n                rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return (parentTransaction ?\n            parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n            PSD.trans ?\n                usePSD(PSD.transless, () => this._whenReady(enterTransaction)) :\n                this._whenReady(enterTransaction));\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n        }\n        return this._allTables[tableName];\n    }\n}\n\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n    ? Symbol.observable\n    : \"@@observable\";\nclass Observable {\n    constructor(subscribe) {\n        this._subscribe = subscribe;\n    }\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? { next: x, error, complete } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n}\n\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach(part => {\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\n\nfunction liveQuery(querier) {\n    return new Observable((observer) => {\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = () => newScope(querier, { subscr, trans: null });\n            const rv = PSD.trans\n                ?\n                    usePSD(PSD.transless, exec)\n                : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed() {\n                return closed;\n            },\n            unsubscribe: () => {\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            },\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts) => {\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = () => {\n            if (querying || closed)\n                return;\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result) => {\n                querying = false;\n                if (closed)\n                    return;\n                if (shouldNotify()) {\n                    doQuery();\n                }\n                else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err) => {\n                querying = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n}\n\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n}\ncatch (e) {\n    domDeps = { indexedDB: null, IDBKeyRange: null };\n}\n\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete(databaseName) {\n        const db = new Dexie(databaseName, { addons: [] });\n        return db.delete();\n    },\n    exists(name) {\n        return new Dexie(name, { addons: [] }).open().then(db => {\n            db.close();\n            return true;\n        }).catch('NoSuchDatabaseError', () => false);\n    },\n    getDatabaseNames(cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        }\n        catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction(scopeFunc) {\n        return PSD.trans ?\n            usePSD(PSD.transless, scopeFunc) :\n            scopeFunc();\n    },\n    vip,\n    async: function (generatorFn) {\n        return function () {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function (generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== 'function')\n                return DexiePromise.resolve(rv);\n            return rv;\n        }\n        catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: () => PSD.trans || null\n    },\n    waitFor: function (promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n            Dexie.ignoreTransaction(promiseOrFunction) :\n            promiseOrFunction)\n            .timeout(optionalTimeout || 60000);\n        return PSD.trans ?\n            PSD.trans.waitFor(promise) :\n            promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: () => debug,\n        set: value => {\n            setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split('.')\n        .map(n => parseInt(n))\n        .reduce((p, c, i) => p + (c / Math.pow(10, i * 2))),\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent('CustomEvent');\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            }\n            else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    }\n    finally {\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev) => {\n        if (ev.data)\n            propagateLocally(ev.data);\n    };\n}\nelse if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== 'undefined') {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts,\n                    }));\n                }\n                if (typeof self['clients'] === 'object') {\n                    [...self['clients'].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({\n                        type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                        changedParts,\n                    }));\n                }\n            }\n        }\n        catch (_a) { }\n    });\n    if (typeof addEventListener !== 'undefined') {\n        addEventListener('storage', (ev) => {\n            if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n                const data = JSON.parse(ev.newValue);\n                if (data)\n                    propagateLocally(data.changedParts);\n            }\n        });\n    }\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener('message', propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally({ data }) {\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n\nexport { Dexie$1 as Dexie, RangeSet, Dexie$1 as default, liveQuery, mergeRanges, rangesOverlap };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}