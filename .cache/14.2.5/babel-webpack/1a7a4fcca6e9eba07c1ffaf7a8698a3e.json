{"ast":null,"code":"import * as i1 from '@angular/common/http';\nimport { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject } from '@angular/core';\nimport { map, filter, finalize } from 'rxjs/operators';\nimport { Subject, BehaviorSubject, of } from 'rxjs';\nimport * as i1$1 from '@angular/router';\nimport { Router } from '@angular/router';\nvar SkipHeaders = /*#__PURE__*/(() => {\n  (function (SkipHeaders) {\n    SkipHeaders[\"TRUE\"] = \"true\";\n    SkipHeaders[\"FALSE\"] = \"false\";\n  })(SkipHeaders || (SkipHeaders = {}));\n\n  return SkipHeaders;\n})();\nlet HttpService = /*#__PURE__*/(() => {\n  class HttpService {\n    constructor(http, httpBackend) {\n      this.http = http;\n      this.httpBackend = httpBackend;\n      this.withCredentialsOption = false;\n      this.skip = SkipHeaders.FALSE;\n      this.httpWithoutInterceptor = new HttpClient(httpBackend);\n    }\n\n    set withCredentials(value) {\n      this.withCredentialsOption = value;\n    }\n\n    get withCredentials() {\n      return this.withCredentialsOption;\n    }\n    /** TODO: √† tester car pas s√ªr que cela fonctionne... */\n\n\n    delete(path, params, skip = SkipHeaders.FALSE) {\n      let options = {\n        params: this.buildUrlParams(params),\n        withCredentials: this.withCredentialsOption\n      };\n\n      if (skip === SkipHeaders.FALSE) {\n        options['headers'] = {\n          skip: skip\n        };\n        return this.http.delete(`${path}`, options).pipe(map(this.extractData.bind(this)));\n      } else {\n        return this.httpWithoutInterceptor.delete(`${path}`, options).pipe(map(this.extractData.bind(this)));\n      }\n    }\n\n    get(path, params, skip = SkipHeaders.FALSE) {\n      let options = {\n        params: this.buildUrlParams(params),\n        withCredentials: this.withCredentialsOption\n      };\n\n      if (skip === SkipHeaders.FALSE) {\n        options['headers'] = {\n          skip: skip\n        };\n        return this.http.get(`${path}`, options).pipe(map(this.extractData.bind(this)));\n      } else {\n        return this.httpWithoutInterceptor.get(`${path}`, options).pipe(map(this.extractData.bind(this)));\n      }\n    }\n\n    file(path, params) {\n      return this.http.get(`${path}`, {\n        params: this.buildUrlParams(params),\n        withCredentials: this.withCredentialsOption,\n        responseType: 'blob'\n      }).pipe(map(this.extractData.bind(this)));\n    }\n\n    put(path, body = {}, skip = SkipHeaders.FALSE) {\n      let options = {\n        headers: new HttpHeaders().set('skip', skip),\n        withCredentials: this.withCredentialsOption\n      };\n      return this.http.put(`${path}`, JSON.stringify(body), options).pipe(map(this.extractData.bind(this)));\n    }\n\n    _put(path, body = {\n      withCredentials: this.withCredentialsOption\n    }) {\n      return this.httpWithoutInterceptor.put(`${path}`, JSON.stringify(body)).pipe(map(this.extractData.bind(this)));\n    } // post2<T>(path: string, body: Object = {}, skip: string = SkipHeaders.FALSE): Observable<T> {\n    //     let options = {\n    //         headers: new HttpHeaders().set('skip', skip),\n    //         withCredentials: this.withCredentialsOption,\n    //     }\n    //     return this.http.post(\n    //         `${path}`,\n    //         JSON.stringify(body),\n    //         options\n    //     ).pipe(\n    //         map(this.extractData.bind(this))\n    //     ) as Observable<T>;\n    // }\n\n\n    post(path, body = {}, skip = SkipHeaders.FALSE) {\n      let options = {\n        withCredentials: this.withCredentialsOption\n      };\n\n      if (skip === SkipHeaders.FALSE) {\n        options['headers'] = new HttpHeaders().set('skip', skip);\n        return this.http.post(`${path}`, JSON.stringify(body), options).pipe(map(this.extractData.bind(this)));\n      } else {\n        options['headers'] = new HttpHeaders().set('Content-Type', 'application/json; charset=utf-8').set('ngsw-bypass', '');\n        console.log(\"ü§ë\", options['headers']);\n        return this.httpWithoutInterceptor.post(`${path}`, JSON.stringify(body), options).pipe(map(this.extractData.bind(this)));\n      }\n    }\n\n    _post(path, body = {}, options = {\n      withCredentials: this.withCredentialsOption\n    }, skip = SkipHeaders.FALSE) {\n      options['headers'] = new HttpHeaders().set('Content-Type', 'application/json; charset=utf-8');\n      return this.httpWithoutInterceptor.post(`${path}`, JSON.stringify(body), options).pipe(map(this.extractData.bind(this)));\n    }\n\n    patch(path, body = {}, skip = SkipHeaders.FALSE) {\n      let options = {\n        headers: new HttpHeaders().set('skip', skip),\n        withCredentials: this.withCredentialsOption\n      };\n      return this.http.patch(`${path}`, JSON.stringify(body), options).pipe(map(this.extractData.bind(this)));\n    }\n\n    upload(path, body = {}, options = {\n      withCredentials: this.withCredentialsOption\n    }) {\n      options['headers'] = new HttpHeaders().set('Content-Type', 'application/json; charset=utf-8');\n      options['reportProgress'] = true;\n      options['observe'] = \"events\";\n      return this.http.post(`${path}`, JSON.stringify(body), options);\n    }\n\n    extractData(res) {\n      if (!res) return res;\n      const body = res.body;\n      if (res.status === 204) return res.body;\n\n      if (body) {\n        return typeof res.body === 'string' ? JSON.parse(res.body) : res.body;\n      }\n\n      return res;\n    }\n\n    buildUrlParams(parameters) {\n      let params = new HttpParams();\n\n      for (const property in parameters) {\n        if (parameters.hasOwnProperty(property)) {\n          params = params.append(property, parameters[property]);\n        }\n      }\n\n      return params;\n    }\n\n  }\n\n  HttpService.…µfac = function HttpService_Factory(t) {\n    return new (t || HttpService)(i0.…µ…µinject(i1.HttpClient), i0.…µ…µinject(i1.HttpBackend));\n  };\n\n  HttpService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: HttpService,\n    factory: HttpService.…µfac,\n    providedIn: 'root'\n  });\n  return HttpService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet StorageService = /*#__PURE__*/(() => {\n  class StorageService {\n    constructor() {}\n\n    setSessionStorageItem(key, item) {\n      sessionStorage.setItem(key, JSON.stringify(item));\n    }\n\n    getSessionStorageItem(key) {\n      let a = null;\n\n      try {\n        a = JSON.parse(sessionStorage.getItem(key));\n      } catch (e) {\n        console.error(`Session storage, erreur in parsing JSON : `, e);\n      } finally {\n        return a;\n      }\n    }\n\n    deleteSessionStorageItem(key) {\n      sessionStorage.removeItem(key);\n    }\n\n    setLocalStorageItem(key, item) {\n      localStorage.setItem(key, JSON.stringify(item));\n    }\n\n    getLocalStorageItem(key) {\n      let a = null;\n\n      try {\n        a = JSON.parse(localStorage.getItem(key));\n      } catch (e) {\n        console.error(`Local storage, erreur in parsing JSON : `, e);\n      } finally {\n        return a;\n      }\n    }\n\n    deleteLocalStorageItem(key) {\n      localStorage.removeItem(key);\n    }\n\n  }\n\n  StorageService.…µfac = function StorageService_Factory(t) {\n    return new (t || StorageService)();\n  };\n\n  StorageService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: StorageService,\n    factory: StorageService.…µfac,\n    providedIn: 'root'\n  });\n  return StorageService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TokenService = /*#__PURE__*/(() => {\n  class TokenService {\n    constructor(storageService) {\n      this.storageService = storageService;\n    }\n\n    get accessToken() {\n      const token = this.storageService.getLocalStorageItem('accessToken');\n      return token || null;\n    }\n\n    set accessToken(token) {\n      this.storageService.setLocalStorageItem('accessToken', token);\n    }\n\n    get refreshToken() {\n      const token = this.storageService.getLocalStorageItem('refreshToken');\n      return token || null;\n    }\n\n    set refreshToken(token) {\n      this.storageService.setLocalStorageItem('refreshToken', token);\n    }\n\n    deleteTokens() {\n      this.storageService.deleteLocalStorageItem('refreshToken');\n      this.storageService.deleteLocalStorageItem('accessToken');\n    }\n\n    decryptAccessToken() {\n      if (this.accessToken) {\n        const base64Array = this.accessToken.split('.');\n        const decodedToken = JSON.parse(window.atob(base64Array[1]));\n        return decodedToken;\n      }\n\n      return null;\n    }\n\n  }\n\n  TokenService.…µfac = function TokenService_Factory(t) {\n    return new (t || TokenService)(i0.…µ…µinject(StorageService));\n  };\n\n  TokenService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: TokenService,\n    factory: TokenService.…µfac,\n    providedIn: 'root'\n  });\n  return TokenService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet BroadcastEventService = /*#__PURE__*/(() => {\n  class BroadcastEventService {\n    constructor() {\n      this._broadcastedEvents = [];\n      this._eventBus = new Subject();\n    }\n\n    broadcast(event) {\n      this._eventBus.next(event);\n    }\n\n    listen(keys) {\n      const eventKey = keys.join(\"-\");\n\n      if (!this.isEventKnown(eventKey)) {\n        const newEvent = this._eventBus.asObservable().pipe(filter(event => event.eventKeys.join(\"-\") === eventKey), map(event => event.eventData));\n\n        this._broadcastedEvents.push({\n          eventKey: eventKey,\n          event: newEvent\n        });\n\n        return newEvent;\n      } else {\n        return this.returnEvent(eventKey);\n      }\n    }\n\n    isEventKnown(eventKey) {\n      const index = this._broadcastedEvents.findIndex(entr√©e => entr√©e.eventKey === eventKey);\n\n      return index >= 0;\n    }\n\n    returnEvent(eventKey) {\n      const event = this._broadcastedEvents.find(event => event.eventKey === eventKey);\n\n      return event.event;\n    }\n\n  }\n\n  BroadcastEventService.…µfac = function BroadcastEventService_Factory(t) {\n    return new (t || BroadcastEventService)();\n  };\n\n  BroadcastEventService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: BroadcastEventService,\n    factory: BroadcastEventService.…µfac,\n    providedIn: 'root'\n  });\n  return BroadcastEventService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst LIMIT_MAX_RELOAD = 2;\nconst TIME_MAX_RELOAD = 30; // secondes\n\nlet GlobalErrorInterceptorService = /*#__PURE__*/(() => {\n  class GlobalErrorInterceptorService {\n    // public globalErrorsHandlerSubject: Subject<boolean> = new Subject<boolean>();\n    constructor(injector, storageService) {\n      this.injector = injector;\n      this.storageService = storageService;\n    }\n\n    handleError(error) {\n      const chunkFailedMessage = /Loading chunk [\\d]+ failed/;\n      const router = this.injector.get(Router);\n\n      if (error.stack) {\n        console.error(\"details errors üò± :\");\n        console.error(error.stack.toString());\n      } else {\n        console.error(\"error undefined üò°\");\n      }\n\n      if (chunkFailedMessage.test(error.message)) {\n        // this.globalErrorsHandlerSubject.next(true)\n        this.handleReloadPage(error.message.toString());\n      }\n    }\n\n    handleReloadPage(message) {\n      console.log('%cPage reloaded : errors chunk versions', 'color: blue;');\n      const reloadPage = this.storageService.getSessionStorageItem('reloadPage');\n\n      if (!reloadPage) {\n        this.storageService.setSessionStorageItem('reloadPage', {\n          date: new Date(),\n          count: 1\n        });\n      } else if (reloadPage.count < LIMIT_MAX_RELOAD && (new Date().getTime() - new Date(reloadPage.date).getTime()) / 1000 < TIME_MAX_RELOAD) {\n        this.storageService.setSessionStorageItem('reloadPage', {\n          date: reloadPage.date,\n          count: reloadPage.count + 1\n        });\n      } else {\n        message = `Veuillez communiquer cette erreur √† l'administrateur du site : \\n\\n ${message}`;\n        alert(message);\n        this.storageService.deleteSessionStorageItem('reloadPage');\n        return;\n      }\n\n      window.location.reload();\n    }\n\n  }\n\n  GlobalErrorInterceptorService.…µfac = function GlobalErrorInterceptorService_Factory(t) {\n    return new (t || GlobalErrorInterceptorService)(i0.…µ…µinject(i0.Injector), i0.…µ…µinject(StorageService));\n  };\n\n  GlobalErrorInterceptorService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: GlobalErrorInterceptorService,\n    factory: GlobalErrorInterceptorService.…µfac,\n    providedIn: 'root'\n  });\n  return GlobalErrorInterceptorService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LoadingService = /*#__PURE__*/(() => {\n  class LoadingService {\n    constructor() {\n      this.subject = new BehaviorSubject(false);\n    }\n\n    startLoading() {\n      this.subject.next(true);\n    }\n\n    stopLoading() {\n      this.subject.next(false);\n    }\n\n  }\n\n  LoadingService.…µfac = function LoadingService_Factory(t) {\n    return new (t || LoadingService)();\n  };\n\n  LoadingService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: LoadingService,\n    factory: LoadingService.…µfac,\n    providedIn: 'root'\n  });\n  return LoadingService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LoadingInterceptorService = /*#__PURE__*/(() => {\n  class LoadingInterceptorService {\n    constructor(loadingScreenService) {\n      this.loadingScreenService = loadingScreenService;\n      this.activeRequests = 0;\n    }\n\n    intercept(request, next) {\n      if (this.activeRequests === 0) {\n        this.loadingScreenService.startLoading();\n      }\n\n      this.activeRequests++;\n      clearTimeout(this.timer);\n      this.timer = setTimeout(() => {\n        this.forceFinalize();\n      }, 5000);\n      return next.handle(request).pipe(finalize(() => {\n        this.activeRequests--;\n\n        if (this.activeRequests === 0) {\n          this.loadingScreenService.stopLoading();\n          clearTimeout(this.timer);\n        }\n      }));\n    }\n\n    forceFinalize() {\n      this.activeRequests = 0;\n      this.loadingScreenService.stopLoading();\n    }\n\n  }\n\n  LoadingInterceptorService.…µfac = function LoadingInterceptorService_Factory(t) {\n    return new (t || LoadingInterceptorService)(i0.…µ…µinject(LoadingService));\n  };\n\n  LoadingInterceptorService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: LoadingInterceptorService,\n    factory: LoadingInterceptorService.…µfac,\n    providedIn: \"root\"\n  });\n  return LoadingInterceptorService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet RequestInterceptorService = /*#__PURE__*/(() => {\n  class RequestInterceptorService {\n    constructor(tokenService, httpService) {\n      this.tokenService = tokenService;\n      this.httpService = httpService;\n    }\n\n    intercept(request, next) {\n      request = this.addAccessTokenRequest(request);\n      return next.handle(request);\n    }\n\n    addAccessTokenRequest(request, token) {\n      const accessToken = token || this.tokenService.accessToken;\n\n      if (request.headers.get(\"skip\") === SkipHeaders.TRUE) {\n        return request = request.clone({\n          headers: request.headers.delete('skip')\n        });\n      }\n\n      if (!accessToken) {\n        return request;\n      }\n\n      return request.clone({\n        headers: new HttpHeaders({\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${accessToken}`\n        })\n      });\n    }\n\n  }\n\n  RequestInterceptorService.…µfac = function RequestInterceptorService_Factory(t) {\n    return new (t || RequestInterceptorService)(i0.…µ…µinject(TokenService), i0.…µ…µinject(HttpService));\n  };\n\n  RequestInterceptorService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: RequestInterceptorService,\n    factory: RequestInterceptorService.…µfac,\n    providedIn: 'root'\n  });\n  return RequestInterceptorService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet SortService = /*#__PURE__*/(() => {\n  class SortService {\n    sortObjectByKeys(objectData) {\n      return Object.keys(objectData).sort().reduce((obj, key) => {\n        obj[key] = objectData[key];\n        return obj;\n      }, {});\n    }\n\n  }\n\n  SortService.…µfac = function SortService_Factory(t) {\n    return new (t || SortService)();\n  };\n\n  SortService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: SortService,\n    factory: SortService.…µfac,\n    providedIn: 'root'\n  });\n  return SortService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ScrollService = /*#__PURE__*/(() => {\n  class ScrollService {\n    constructor() {\n      this.onScroll = new Subject();\n    }\n\n    currentScrollPosition() {\n      // Firefox, Chrome, Opera, Safari\n      if (self.pageYOffset) return self.pageYOffset; // Internet Explorer 6 - standards mode\n\n      if (document.documentElement && document.documentElement.scrollTop) {\n        return document.documentElement.scrollTop;\n      } // Internet Explorer 6, 7 and 8\n\n\n      if (document.body.scrollTop) return document.body.scrollTop;\n      return 0;\n    }\n\n    getElementDomPosition(elm) {\n      let y = elm.offsetTop - 100;\n      let node = elm;\n\n      while (node.offsetParent && node.offsetParent !== document.body) {\n        node = node.offsetParent;\n        y += node.offsetTop;\n      }\n\n      return y;\n    }\n\n    scrollToTop() {\n      const that = this;\n      let timeOut;\n\n      if (document.body.scrollTop !== 0 || document.documentElement.scrollTop !== 0) {\n        window.scrollBy(0, -50);\n        timeOut = setTimeout(function () {\n          that.scrollToTop();\n        }, 10);\n      } else {\n        clearTimeout(timeOut);\n      }\n    }\n\n    scrollToIdSmooth(eID) {\n      const startY = this.currentScrollPosition();\n      const elm = document.getElementById(eID);\n      const stopY = this.getElementDomPosition(elm);\n      const distance = stopY > startY ? stopY - startY : startY - stopY;\n\n      if (distance < 100) {\n        scrollTo(0, stopY);\n        return;\n      }\n\n      let speed = Math.round(distance / 100);\n\n      if (speed >= 20) {\n        speed = 20;\n      }\n\n      const step = Math.round(distance / 25);\n      let leapY = stopY > startY ? startY + step : startY - step;\n      let timer = 0;\n\n      if (stopY > startY) {\n        for (let i = startY; i < stopY; i += step) {\n          setTimeout(\"window.scrollTo(0, \" + leapY + \")\", timer * speed);\n          leapY += step;\n          if (leapY > stopY) leapY = stopY;\n          timer++;\n        }\n\n        return;\n      }\n\n      for (let i = startY; i > stopY; i -= step) {\n        setTimeout(\"window.scrollTo(0, \" + leapY + \")\", timer * speed);\n        leapY -= step;\n        if (leapY < stopY) leapY = stopY;\n        timer++;\n      }\n\n      return false;\n    }\n\n    getScrollDistanceTo(eID) {\n      const elm = document.getElementById(eID);\n      if (!elm) return -1; // element not found\n\n      const stopY = this.getElementDomPosition(elm);\n      return stopY;\n    }\n\n  }\n\n  ScrollService.…µfac = function ScrollService_Factory(t) {\n    return new (t || ScrollService)();\n  };\n\n  ScrollService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: ScrollService,\n    factory: ScrollService.…µfac,\n    providedIn: 'root'\n  });\n  return ScrollService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet InjectComponentService = /*#__PURE__*/(() => {\n  class InjectComponentService {\n    constructor() {\n      this.componentsRefs = [];\n    }\n    /**\r\n     * Exemple d'utilisation:\r\n     \r\n     * this.injectComponentService.loadAndAddComponentToContainer(MyClasseComponent, #DomReference,\r\n            { @InputName_1: Value, @InputName_2: Value }, { @OutputName_1: (valueEmited: any) => this.callback(valueEmited)})\r\n     * Ou si le composant n'a pas de @Output\r\n     * this.injectComponentService.loadAndAddComponentToContainer(MyClasseComponent, #DomReference,\r\n            { @InputName_1: Value, @InputName_2: Value }, null)\r\n     */\n\n\n    loadAndAddComponentToContainer(componentClass, viewContainerRef, inputs, outputs, index) {\n      // const factory = this.componentFactoryResolver.resolveComponentFactory(componentClass);\n      const componentRef = viewContainerRef.createComponent(componentClass, {\n        index: index ? index : null\n      });\n      /** inputs */\n\n      for (const [key, value] of Object.entries(inputs)) {\n        componentRef.instance[key] = value;\n      }\n      /** outputs */\n\n\n      if (outputs) {\n        for (const [key, value] of Object.entries(outputs)) {\n          if (key && value && componentRef.instance[key]) componentRef.instance[key].subscribe(data => value(data));\n        }\n      }\n\n      componentRef.changeDetectorRef.detectChanges();\n      this.componentsRefs.push(componentRef);\n    }\n\n    removeComponentFromViewContainer(index, viewContainerRef) {\n      viewContainerRef.remove(index);\n      this.componentsRefs.splice(index, 1);\n    }\n\n    moveComponentFromViewContainer(currentIndex, previousIndex, viewContainerRef) {\n      viewContainerRef.move(viewContainerRef.get(previousIndex), currentIndex);\n      this.componentsRefs.splice(previousIndex, 0, this.componentsRefs.splice(currentIndex, 1)[0]);\n    }\n\n  }\n\n  InjectComponentService.…µfac = function InjectComponentService_Factory(t) {\n    return new (t || InjectComponentService)();\n  };\n\n  InjectComponentService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: InjectComponentService,\n    factory: InjectComponentService.…µfac,\n    providedIn: 'root'\n  });\n  return InjectComponentService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet HelperService = /*#__PURE__*/(() => {\n  class HelperService {\n    generateGuid() {\n      return this.s4() + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + this.s4() + this.s4();\n    }\n\n    s4() {\n      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    }\n\n    removeValueFromArrayByIndex(arrayValues, index) {\n      if (index === -1) return arrayValues;\n      return [...arrayValues.slice(0, index), ...arrayValues.slice(index + 1)];\n    }\n    /** arrondir un nombre */\n\n\n    roundUp(num, precision) {\n      precision = Math.pow(10, precision);\n      return Math.ceil(num * precision) / precision;\n    }\n    /**  */\n\n\n    static retourneNomDeDomaine() {\n      return location.protocol + '//' + location.hostname + (location.port ? ':' + location.port : '');\n    }\n\n    static enleverNomDomaineUrl(url) {\n      if (!url) return null;\n      if (!/^http[s]?:\\/\\//.test(url)) return url;\n      const urlSansHttp = url.split(/^http[s]?:\\/\\//);\n      const indexSlash = urlSansHttp[1].indexOf(\"/\");\n      const urlValide = urlSansHttp[1].substring(indexSlash);\n      return urlValide;\n    }\n\n    static retourneSegmentsURL() {\n      const pathName = window.location.pathname; // on supprime du pathname le dernier caract√®res s'il s'agit d'un /\n\n      return pathName.replace(/\\/$/, '').split('/');\n    }\n\n    static ouvrirUrlExterne(lien, estceNouvelOnglet = false) {\n      if (!this.retourneNullSiNonD√©fini(lien)) return;\n      let url = '';\n\n      if (!/^http[s]?:\\/\\//.test(lien)) {\n        url += 'http://';\n      }\n\n      url += lien;\n\n      if (estceNouvelOnglet) {\n        window.open(url);\n      } else {\n        window.location.href = url;\n      }\n    }\n\n    static nettoyerParametresUrl(ancienneUrl) {\n      let index = 0;\n      let nouvelleUrl = ancienneUrl;\n      index = ancienneUrl.indexOf('?');\n\n      if (index === -1) {\n        index = ancienneUrl.indexOf('#');\n      }\n\n      if (index !== -1) {\n        nouvelleUrl = ancienneUrl.substring(0, index);\n      }\n\n      return nouvelleUrl;\n    }\n\n    static construireUrl(url) {\n      return this.retourneNomDeDomaine() + '/' + url;\n    }\n\n    static segmentsURL(url) {\n      if (!url) return []; // on supprime de l'url le 1er / et le de dernier /\n\n      return url.replace(/\\/*/, '').replace(/\\/$/, '').split('/');\n    }\n\n    static estceUrlValide(string) {\n      const res = string.match(/(http(s)?:\\/\\/.)?(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)/g);\n\n      if (!res) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n\n    static encoderParam√®tresUrl(data) {\n      const ret = [];\n\n      for (const key in data) {\n        if (data.hasOwnProperty(key)) {\n          const element = data[key];\n          ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(element));\n        }\n      }\n\n      return ret.join('&');\n    }\n\n    static concat√©nerParam√®tresUrl(url, param√®tres) {\n      return url + '?' + param√®tres;\n    }\n\n    static ajouterParam√®treUrl(url, param, value) {\n      const a = document.createElement('a'),\n            regex = /(?:\\?|&amp;|&)+([^=]+)(?:=([^&]*))*/g;\n      let match = null;\n      const str = [];\n      a.href = url;\n      param = encodeURIComponent(param);\n\n      while (match = regex.exec(a.search)) {\n        if (param !== match[1]) str.push(match[1] + (match[2] ? \"=\" + match[2] : \"\"));\n      }\n\n      str.push(param + (value ? \"=\" + encodeURIComponent(value) : \"\"));\n      a.search = str.join(\"&\");\n      return a.href;\n    }\n    /**\r\n     * Retourne l'url courante sans les param√®tres\r\n     */\n\n\n    static donneUrlCouranteSansParam√®tre() {\n      return window.location.href.split(/[?#]/)[0];\n    }\n    /**\r\n     * JavaScript Get URL Parameter\r\n     * @param String prop The specific URL parameter you want to retreive the value for\r\n     * @return String|Object If prop is provided a string value is returned, otherwise an object of all properties is returned\r\n     */\n\n\n    static donneParam√®tresUrl(prop, urlStatique) {\n      const params = {};\n      const urlCourante = urlStatique ? urlStatique : window.location.href;\n      const search = decodeURIComponent(urlCourante.slice(urlCourante.indexOf('?') + 1));\n      if (search === urlCourante) return null;\n      const definitions = search.split('&');\n      definitions.forEach(function (val, key) {\n        const parts = val.split('=', 2);\n        params[parts[0]] = parts[1];\n      });\n\n      if (prop && !(prop in params)) {\n        return null;\n      }\n\n      return prop && prop in params ? params[prop] : params;\n    }\n\n    static retourneParam√®tresAccolades(url) {\n      if (!this.retourneNullSiNonD√©fini(url)) {\n        return [];\n      }\n\n      const r√©sultat = url.match(/\\{(.*?)\\}/g); // entre {}\n\n      return !r√©sultat ? [] : r√©sultat;\n    }\n    /** efface les param√®tres entre accolades d'une cha√Æne */\n\n\n    static effacerParam√®tresAccolades(chaine) {\n      return this.√©viterDoubleSlash(this.replaceAll(chaine, /\\{(.*?)\\}/g, \"\"));\n    }\n\n    static remplacerParam√®tresAccolades(chercherDans, motif, valeur) {\n      return HelperService.replaceAll(chercherDans, `{${motif}}`, valeur);\n    }\n\n    static estceObjetVide(objet) {\n      return Object.keys(objet).length === 0 && objet.constructor === Object;\n    }\n    /**\r\n     * D√©tection de savoir s'il l'on vient d'une nouvelle page ou d'une page du site\r\n     */\n\n\n    static pageOuverteDepuisScript() {\n      return window.opener !== null;\n    }\n\n    static √©viterDoubleSlash(chaine) {\n      return HelperService.replaceAll(chaine, /(https?:\\/\\/)|(\\/){2,}/g, \"$1$2\");\n    }\n    /**\r\n     * V√©rifie s'il existe une concordance entre les `param√®tres de l'url courante` et les `param√®tres de la source de donn√©es`\r\n     * @param urlSourceDonn√©es : exemple : la source de donn√©es d'une page de type formulaire, http://api.sonate-dev.fr:85/tiers/individus/{id}\r\n     * @param urlCouranteStatique : l'url du navigateur, http://localhost:1200/page/lab-formulaire?id=016247a2-2c1c-4e08-bd78-9b05659ec5ee\r\n     */\n\n\n    static siConcordanceParam√®tresURLetSourceDonn√©es(urlSourceDonn√©es, urlCouranteStatique) {\n      if (!urlSourceDonn√©es) return null;\n      const urlCourante = urlCouranteStatique ? urlCouranteStatique : window.location.search;\n      const param√®tresAccolades = this.retourneParam√®tresAccolades(urlSourceDonn√©es);\n\n      if (!param√®tresAccolades.length) {\n        return false;\n      }\n\n      for (let index = 0; index < param√®tresAccolades.length; index++) {\n        const param√®treAvecAccolades = param√®tresAccolades[index];\n        const param√®treSansAccolade = param√®treAvecAccolades.substring(param√®treAvecAccolades.lastIndexOf(\"{\") + 1, param√®treAvecAccolades.lastIndexOf(\"}\"));\n        const valeurParam√®tre = this.donneParam√®tresUrl(param√®treSansAccolade, urlCourante);\n\n        if (!valeurParam√®tre) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    static retourneNullSiNonD√©fini(valeur) {\n      if (Array.isArray(valeur)) {\n        valeur = valeur.length === 0 ? null : valeur;\n      } else if (typeof valeur === 'number') {\n        return valeur;\n      } else {\n        valeur = typeof valeur === \"string\" ? valeur.trim() : valeur;\n      }\n\n      return !valeur ? null : valeur;\n    }\n\n    static replaceAll(text, pattern, newText) {\n      return text.replace(new RegExp(pattern, 'g'), newText);\n    }\n\n    static valeurTexteBool√©en(valeur) {\n      if (typeof valeur === \"boolean\") {\n        return valeur ? \"Oui\" : \"Non\";\n      }\n\n      return null;\n    }\n\n    static estNumerique(n) {\n      return !isNaN(parseFloat(n)) && isFinite(n);\n    } // 01 02 03 04 05 -> 0102030405\n\n\n    static adapteurEcritureTelephone(valeurAvecEspace) {\n      let valeurSansEspace;\n\n      if (!this.retourneNullSiNonD√©fini(valeurAvecEspace)) {\n        return null;\n      }\n\n      const tmp = valeurAvecEspace.split(' ');\n      valeurSansEspace = tmp[0] + tmp[1] + tmp[2] + tmp[3] + tmp[4];\n      return valeurSansEspace;\n    }\n\n    static retourneValeurObjet(objet, propri√©t√©) {\n      if (typeof objet !== 'undefined' && objet.hasOwnProperty(propri√©t√©)) {\n        return objet[propri√©t√©];\n      }\n\n      return null;\n    }\n\n    static dupliquerTableau(tableau) {\n      return [...tableau];\n    }\n\n    static ajouterValeurTableau(tableau, valeur) {\n      return [...tableau, valeur];\n    }\n\n    static ajouterValeurUniqueTableau(tableau, valeur) {\n      if (tableau.indexOf(valeur) === -1) {\n        return [...tableau, valeur];\n      }\n\n      return tableau;\n    }\n\n    static arrondirZeroCinqPr√®s(nombre) {\n      return Math.round(nombre * 2) * 0.5;\n    }\n    /**\r\n     * Un GUID envoy√© depuis le back au front est de la forme : (inheritor) {_value: \"0163d59a-bcd8-44fe-852f-100af77dfb9b\"}\r\n     * @param objetInheritor objet GUID envoy√© depuis le backoffice\r\n     */\n\n\n    static d√©s√©rialiserInheritorGuid(objetInheritor) {\n      return objetInheritor._value ? objetInheritor._value : null;\n    }\n\n    static s√©rialiserInheritorGuid(valeur) {\n      return null; // return valeur._value ? valeur : new Guid(valeur);\n    }\n\n    static estdetypeInheritorGuid(valeur) {\n      return valeur.hasOwnProperty(\"_value\");\n    }\n\n    static estdetypeGuid(valeur) {\n      if (!valeur) return false;\n      return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(valeur);\n    }\n    /** fin bloc GUID */\n\n\n    static valeurD√©fautBool√©en(valeur) {\n      return typeof valeur !== \"undefined\" && !valeur ? false : true;\n    }\n\n  }\n\n  HelperService.…µfac = function HelperService_Factory(t) {\n    return new (t || HelperService)();\n  };\n\n  HelperService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: HelperService,\n    factory: HelperService.…µfac,\n    providedIn: 'root'\n  });\n  return HelperService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ValidatorsService = /*#__PURE__*/(() => {\n  class ValidatorsService {\n    getValidationErrorMessage(error) {\n      const configCl√©sErreurs = {\n        'required': !error.message ? 'Veuillez saisir ce champ' : error.message,\n        'invalidEmailAddress': 'L\\'e-mail n\\'est pas valide.',\n        'invalidCodePostal': 'Le code postal n\\'est pas valide.',\n        'invalidDate': \"Veuillez saisir une date valide.\",\n        'invalidHeure': \"L'heure n'est pas au bon format.\",\n        'invalideDateHeure': \"La date/heure n'est pas valide.\",\n        'regexInvalide': !error.value.formatRegexEnClair ? 'Le format attendu est incorrect.' : `Fomat attendu : ${error.value.formatRegexEnClair}.`,\n        'invalidTypeMime': \"Le type du document n'est pas accept√©.\",\n        'invalidTailleTotaleUpload': `La taille totale des pi√®ces jointes est atteinte.`,\n        'invalidTailleUpload': `La taille limite de la pi√®ce jointe est atteinte.`,\n        'datePasseeInvalide': \"La date doit √™tre dans le pass√©.\",\n        'dateFutureInvalide': \"La date doit √™tre dans le future.\",\n        'datePasseeOuPresenteInvalide': \"La date doit √™tre pass√©e ou pr√©sente.\",\n        'dateFutureOuPresenteInvalide': \"La date doit √™tre pr√©sente ou future.\",\n        'invalidIMEI': \"Le num√©ro IMEI est invalide.\",\n        'invalidDateAnterieure': \"La date doit √™tre ant√©rieure.\",\n        'dateAvantUneAutre': \"La date B doit √™tre ant√©rieure √† la date A.\",\n        'invalidNumeroTelephone': 'Le num√©ro de t√©l√©phone n\\'est pas valide.',\n        'adresseMailDejaUtilisee': 'L\\'adresse e-mail est d√©j√† utilis√©e.',\n        'identiqueValidator': 'Le champ n\\'est pas identique.',\n        'pseudoDejaUtilisee': 'Le pseudo est d√©j√† utilis√©.',\n        'utilisateurMajeurInvalide': 'Vous devez √™tre majeur.',\n        'entierInvalide': 'Saisissez un entier.',\n        'auMoinsUnChampRequis': 'Veuillez saisir au moins un crit√®re de recherche.'\n      };\n      return configCl√©sErreurs[error.key];\n    }\n\n    static require(control) {\n      const value = HelperService.retourneNullSiNonD√©fini(control.value);\n\n      if (control.hasValidator(ValidatorsService.dateValidator)) {\n        return value === null ? {\n          invalidDate: true\n        } : null;\n      } else {\n        return value === null ? {\n          \"required\": true\n        } : null;\n      }\n    }\n\n    static emailValidator(control) {\n      if (!control.value) return null; // RFC 2822 compliant regex\n\n      if (control.value.match(/[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?/)) {\n        return null;\n      } else {\n        return {\n          'invalidEmailAddress': true\n        };\n      }\n    }\n\n    static dateValidator(control) {\n      return null;\n    }\n\n    static telephoneValidator(control) {\n      if (!control.value) return null;\n\n      if (control.value.match(/^0[1-9](\\s[0-9][0-9]){4}$/)) {\n        return null;\n      } else {\n        return {\n          'invalidNumeroTelephone': true\n        };\n      }\n    }\n\n    static codepostalValidator(control) {\n      if (!control.value) return null;\n\n      if (control.value.match(/^(([0-8][0-9])|(9[0-5]))[0-9]{3}$/)) {\n        return null;\n      } else {\n        return {\n          'invalidCodePostal': true\n        };\n      }\n    }\n    /** VALIDATEURS DATES */\n\n    /**\r\n     * La date √† valider est au format UTC : 1982-11-06T00:00:00Z\r\n     */\n    // public static dateValidateurUTC(control: FormControl): any {\n    //     if (!control.value) return null;\n    //     const str = control.value;\n    //     const dateValide: boolean = DateFunctions.validerDateUTC(str);\n    //     return dateValide ? null : { 'invalidDate': true };\n    // }\n    // l'heure est au format 11h12\n    // public static heureValidateur(control: FormControl): any {\n    //     if (!control.value) return null;\n    //     const str = control.value;\n    //     if (DateFunctions.validerUneHeure(str)) {\n    //         return null;\n    //     } else {\n    //         return { 'invalidHeure': true };\n    //     }\n    // }\n    // la date heure est au format 01/01/2018 √† 12h14\n    // public static dateHeureValidateur(control: FormControl): any {\n    //     if (!control.value) return null;\n    //     const str: string = control.value;\n    //     const valeurSplit: string[] = str.split(configdefault.date.dateTimeSeparator);\n    //     const dateValide: boolean = DateFunctions.validerDateJJMMAAAA(valeurSplit[0]);\n    //     const heureValide: boolean = DateFunctions.validerUneHeure(valeurSplit[1]);\n    //     if (!dateValide) {\n    //         return { 'invalidDate': true };\n    //     } else if (!heureValide) {\n    //         return { 'invalidHeure': true };\n    //     } else {\n    //         return null;\n    //     }\n    // }\n\n    /**\r\n     * La date √† valider est au format UTC : 1982-11-06T15:15:15Z\r\n     * invalideDateHeure\r\n     */\n    // public static dateHeureValidateurUTC(control: FormControl): any {\n    //     if (!control.value) return null;\n    //     const str = control.value;\n    //     const dateValide: boolean = DateFunctions.validerDateUTC(str);\n    //     return dateValide ? null : { 'invalideDateHeure': true };\n    // }\n    // public static datePass√©eValidateur(control: FormControl): any {\n    //     if (!control.value) return null;\n    //     const dates: Date[] = DateFunctions.validateurDatesAides(control.value);\n    //     if (dates[0] >= dates[1]) {\n    //         return {\n    //             'datePasseeInvalide': true\n    //         };\n    //     }\n    //     return null;\n    // }\n    // public static dateFutureValidateur(control: FormControl): any {\n    //     if (!control.value) return null;\n    //     const dates: Date[] = DateFunctions.validateurDatesAides(control.value);\n    //     if (dates[0] <= dates[1]) {\n    //         return {\n    //             'dateFutureInvalide': true\n    //         };\n    //     }\n    //     return null;\n    // }\n    // public static datePass√©eOuPr√©senteValidateur(control: FormControl): any {\n    //     if (!control.value) return null;\n    //     const dates: Date[] = DateFunctions.validateurDatesAides(control.value);\n    //     if (dates[0] > dates[1]) {\n    //         return {\n    //             'datePasseeOuPresenteInvalide': true\n    //         };\n    //     }\n    //     return null;\n    // }\n    // public static dateFutureOuPr√©senteValidateur(control: FormControl): any {\n    //     if (!control.value) return null;\n    //     const dates: Date[] = DateFunctions.validateurDatesAides(control.value);\n    //     if (dates[0] < dates[1]) {\n    //         return {\n    //             'dateFutureOuPresenteInvalide': true\n    //         };\n    //     }\n    //     return null;\n    // }\n\n    /** / VALIDATEURS DATES */\n    // https://medium.com/front-end-hacking/reactive-forms-and-form-validation-with-angular-fdcbcf98e1e8\n\n\n    static regexValidator(regle, formatRegexEnClair) {\n      return control => {\n        if (!control.value) return null;\n        const regexp = new RegExp(regle);\n        return !regexp.test(control.value) ? {\n          'regexInvalide': {\n            formatRegexEnClair\n          }\n        } : null;\n      };\n    }\n\n    static numeroSinistreValidator(control) {\n      if (!control.value) return null;\n\n      if (control.value.match(/^([A-z0-9]{2})?(L|l)[A-z0-9](T|t)[A-z0-9]{5}$/)) {\n        return null;\n      } else {\n        return {\n          'invalidNumeroSinistre': true\n        };\n      }\n    }\n\n    static caseACocherRequireValidator(control) {\n      if (control.value === true) {\n        return null;\n      } else {\n        return {\n          'required': true\n        };\n      }\n    }\n\n    static dateAvantUneAutre(champDateAvant, champDateApr√®s) {\n      return group => {\n        if (!group.get(champDateAvant) || !group.get(champDateApr√®s)) return null;\n        const dateD√©but = group.get(champDateAvant).value;\n        const dateFin = group.get(champDateApr√®s).value;\n\n        if (dateD√©but > dateFin) {\n          return {\n            'erreurDateFinAvantD√©but': true\n          };\n        }\n\n        return null;\n      };\n    } // https://gist.github.com/DiegoSalazar/4075533\n\n\n    static luhnValidator(control) {\n      let valeur = control.value; // accept only digits, dashes or spaces\n\n      if (/[^0-9-\\s]+/.test(valeur)) return {\n        'invalidIMEI': true\n      }; // The Luhn Algorithm. It's so pretty.\n\n      let nCheck = 0;\n      let nDigit = 0;\n      let bEven = false;\n      valeur = valeur.replace(/\\D/g, \"\");\n\n      for (let n = valeur.length - 1; n >= 0; n--) {\n        const cDigit = valeur.charAt(n);\n        nDigit = parseInt(cDigit, 10);\n\n        if (bEven) {\n          if ((nDigit *= 2) > 9) nDigit -= 9;\n        }\n\n        nCheck += nDigit;\n        bEven = !bEven;\n      }\n\n      if (nCheck % 10 === 0) {\n        return null;\n      } else {\n        return {\n          'invalidIMEI': true\n        };\n      }\n    }\n\n    static identiqueValidator(controle, controleConfirme) {\n      return group => {\n        const password = group.controls[controle];\n        const confirmPassword = group.controls[controleConfirme];\n\n        if (password.value !== confirmPassword.value) {\n          return {\n            'identiqueValidator': true\n          };\n        }\n      };\n    }\n\n    static √™treMajeurValidateur(control) {\n      if (parseInt(control.value) >= 18) {\n        return null;\n      } else {\n        return {\n          'utilisateurMajeurInvalide': true\n        };\n      }\n    }\n\n    static entierValidateur(control) {\n      if (control.value.match(/^\\d+$/)) {\n        return null;\n      } else {\n        return {\n          'entierInvalide': true\n        };\n      }\n    }\n\n    static auMoinsUnChampDoitEtreRequisValidateur() {\n      return group => {\n        let isAtLeastOne = false;\n\n        if (group && group.controls) {\n          for (const control in group.controls) {\n            if (group.controls.hasOwnProperty(control) && group.controls[control].valid && HelperService.retourneNullSiNonD√©fini(group.controls[control].value)) {\n              isAtLeastOne = true;\n              break;\n            }\n          }\n        }\n\n        return isAtLeastOne ? null : {\n          'auMoinsUnChampRequis': true\n        };\n      };\n    }\n\n  }\n\n  ValidatorsService.…µfac = function ValidatorsService_Factory(t) {\n    return new (t || ValidatorsService)();\n  };\n\n  ValidatorsService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: ValidatorsService,\n    factory: ValidatorsService.…µfac,\n    providedIn: 'root'\n  });\n  return ValidatorsService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet CurrentUrlRoutingService = /*#__PURE__*/(() => {\n  class CurrentUrlRoutingService {\n    constructor() {\n      this.currentUrl = new BehaviorSubject(undefined);\n    }\n\n  }\n\n  CurrentUrlRoutingService.…µfac = function CurrentUrlRoutingService_Factory(t) {\n    return new (t || CurrentUrlRoutingService)();\n  };\n\n  CurrentUrlRoutingService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: CurrentUrlRoutingService,\n    factory: CurrentUrlRoutingService.…µfac\n  });\n  return CurrentUrlRoutingService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar FragmentType = /*#__PURE__*/(() => {\n  (function (FragmentType) {\n    FragmentType[FragmentType[\"OrderBy\"] = 1] = \"OrderBy\";\n    FragmentType[FragmentType[\"Top\"] = 2] = \"Top\";\n    FragmentType[FragmentType[\"Skip\"] = 3] = \"Skip\";\n    FragmentType[FragmentType[\"Count\"] = 4] = \"Count\";\n    FragmentType[FragmentType[\"Expand\"] = 5] = \"Expand\";\n    FragmentType[FragmentType[\"Filter\"] = 6] = \"Filter\";\n    FragmentType[FragmentType[\"Select\"] = 7] = \"Select\";\n  })(FragmentType || (FragmentType = {}));\n\n  return FragmentType;\n})();\n\nclass QueryFragment {\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n\n}\n\nclass FilterBuilder {\n  constructor() {\n    this.fragments = [];\n\n    this.filterExpression = (field, operator, value) => {\n      this.fragments.push(new QueryFragment(FragmentType.Filter, `${field} ${operator} ${this.getValue(value)}`));\n      return this;\n    };\n\n    this.filterPhrase = phrase => {\n      this.fragments.push(new QueryFragment(FragmentType.Filter, phrase));\n      return this;\n    };\n\n    this.and = predicate => {\n      this.fragments.push(new QueryFragment(FragmentType.Filter, `(${predicate(new FilterBuilder()).toQuery('and')})`));\n      return this;\n    };\n\n    this.or = predicate => {\n      this.fragments.push(new QueryFragment(FragmentType.Filter, `(${predicate(new FilterBuilder()).toQuery('or')})`));\n      return this;\n    };\n\n    this.toQuery = operator => {\n      if (!this.fragments || this.fragments.length < 1) return '';\n      return this.fragments.map(f => f.value).join(` ${operator} `);\n    };\n  }\n\n  getValue(value) {\n    let type = typeof value;\n    if (value instanceof Date) type = 'date';\n\n    switch (type) {\n      case 'string':\n        return `'${value}'`;\n\n      case 'date':\n        return `${value.toISOString()}`;\n\n      default:\n        return `${value}`;\n    }\n  }\n\n}\n\nclass QueryBuilder {\n  constructor() {\n    this.fragments = [];\n\n    this.orderBy = fields => {\n      this.clear(FragmentType.OrderBy);\n      this.fragments.push(new QueryFragment(FragmentType.OrderBy, `$orderby=${fields}`));\n      return this;\n    };\n\n    this.top = top => {\n      this.clear(FragmentType.Top);\n      this.fragments.push(new QueryFragment(FragmentType.Top, `$top=${top}`));\n      return this;\n    };\n\n    this.skip = skip => {\n      this.clear(FragmentType.Skip);\n      this.fragments.push(new QueryFragment(FragmentType.Skip, `$skip=${skip}`));\n      return this;\n    };\n\n    this.count = () => {\n      this.clear(FragmentType.Count);\n      this.fragments.push(new QueryFragment(FragmentType.Count, `$count=true`));\n      return this;\n    };\n\n    this.expand = fields => {\n      this.clear(FragmentType.Expand);\n      this.fragments.push(new QueryFragment(FragmentType.Expand, `$expand=${fields}`));\n      return this;\n    };\n\n    this.select = fields => {\n      this.clear(FragmentType.Select);\n      this.fragments.push(new QueryFragment(FragmentType.Select, `$select=${fields}`));\n      return this;\n    };\n\n    this.filter = (predicate, operator = 'and') => {\n      this.clear(FragmentType.Filter);\n      this.fragments.push(new QueryFragment(FragmentType.Filter, predicate(new FilterBuilder()).toQuery(operator)));\n      return this;\n    };\n\n    this.clear = fragmentType => {\n      this.fragments = this.fragments.filter(f => f.type !== fragmentType);\n      return this;\n    };\n\n    this.toQuery = () => {\n      if (this.fragments.length < 1) return ''; // const sortedFragments = orderBy(this.fragments, (sf: QueryFragment) => sf.type);\n\n      const sortedFragments = this.fragments.concat().sort(this.sortBy(\"type\"));\n      const nonFilterFragments = sortedFragments.filter(sf => sf.type !== FragmentType.Filter);\n      const filterFragments = sortedFragments.filter(sf => sf.type === FragmentType.Filter);\n      let query = // '?' +\n      '' + sortedFragments.filter(sf => sf.type !== FragmentType.Filter).map(sf => sf.value).join('&');\n      if (filterFragments.length < 1) return query;else if (nonFilterFragments.length > 0) query += '&';\n      query += this.parseFilters(filterFragments, 'and').trim();\n      return query;\n    };\n\n    this.sortBy = key => {\n      return (a, b) => a[key] > b[key] ? 1 : b[key] > a[key] ? -1 : 0;\n    };\n  }\n\n  parseFilters(fragments, operator) {\n    if (!fragments === null || fragments.length < 1) return '';\n    return '$filter=' + fragments.map(f => f.value).join(` ${operator} `);\n  }\n\n}\n\nlet FileService = /*#__PURE__*/(() => {\n  class FileService {\n    constructor() {}\n\n    downloadFile(response, fileName) {\n      const a = document.createElement('a');\n      a.href = URL.createObjectURL(response);\n      a.download = fileName;\n      document.body.appendChild(a);\n      a.click();\n    }\n\n  }\n\n  FileService.…µfac = function FileService_Factory(t) {\n    return new (t || FileService)();\n  };\n\n  FileService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: FileService,\n    factory: FileService.…µfac,\n    providedIn: 'root'\n  });\n  return FileService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MappingBuilderService = /*#__PURE__*/(() => {\n  class MappingBuilderService {\n    constructor() {\n      this.commandMapped = {};\n    }\n\n    init() {\n      this.commandMapped = {};\n      return this;\n    }\n\n    set setNameForm(name) {\n      this.nameForm = name;\n    }\n\n    set valuesForm(values) {\n      this.values = values;\n    }\n\n    map(mapping) {\n      const sourceMap = this.extractMappingParams(mapping.source);\n      const sourceValue = this.getValueFromMapping(sourceMap);\n      const destinationMap = this.extractMappingParams(mapping.destination);\n      /** sourceValue est undefined si la cl√© du formulaire est inconnu */\n\n      if (typeof sourceValue !== 'undefined') {\n        this.assign(this.commandMapped, destinationMap.mappingKeys, sourceValue);\n      }\n\n      return this;\n    }\n\n    getMapping() {\n      return Object.entries(this.commandMapped).length === 0 ? null : this.commandMapped;\n    }\n\n    extractMappingParams(mapping) {\n      const m = mapping.split('.');\n      const [firstElement, ...rest] = m;\n      return {\n        mappingName: firstElement,\n        mappingKeys: rest\n      };\n    }\n\n    getValueFromMapping(source) {\n      let value = null;\n\n      if (this.nameForm === source.mappingName) {\n        source.mappingKeys.forEach(key => {\n          value = value ? value[key] : key in this.values ? this.values[key] : null;\n        });\n        return value;\n      }\n\n      return undefined;\n    }\n\n    assign(obj, keyPath, value) {\n      let key;\n      let lastKeyIndex = keyPath.length - 1;\n\n      for (var i = 0; i < lastKeyIndex; ++i) {\n        key = keyPath[i];\n\n        if (!(key in obj)) {\n          obj[key] = {};\n        }\n\n        obj = obj[key];\n      }\n\n      obj[keyPath[lastKeyIndex]] = value;\n    }\n\n  }\n\n  MappingBuilderService.…µfac = function MappingBuilderService_Factory(t) {\n    return new (t || MappingBuilderService)();\n  };\n\n  MappingBuilderService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: MappingBuilderService,\n    factory: MappingBuilderService.…µfac\n  });\n  return MappingBuilderService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet FormHelperService = /*#__PURE__*/(() => {\n  class FormHelperService {\n    countControlsForm(form) {\n      return Object.keys(form.controls).length;\n    }\n\n    keysControlsForm(form) {\n      return Object.keys(form.controls);\n    }\n\n  }\n\n  FormHelperService.…µfac = function FormHelperService_Factory(t) {\n    return new (t || FormHelperService)();\n  };\n\n  FormHelperService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: FormHelperService,\n    factory: FormHelperService.…µfac,\n    providedIn: 'root'\n  });\n  return FormHelperService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet UrlHelperService = /*#__PURE__*/(() => {\n  class UrlHelperService {\n    constructor(router, activatedRoute) {\n      this.router = router;\n      this.activatedRoute = activatedRoute;\n    }\n\n    updateParamsUrlWithoutRefresh(queryParams) {\n      this.router.navigate([], {\n        relativeTo: this.activatedRoute,\n        queryParams: queryParams,\n        queryParamsHandling: 'merge' // remove to replace all query params by provided\n\n      });\n    }\n\n  }\n\n  UrlHelperService.…µfac = function UrlHelperService_Factory(t) {\n    return new (t || UrlHelperService)(i0.…µ…µinject(i1$1.Router), i0.…µ…µinject(i1$1.ActivatedRoute));\n  };\n\n  UrlHelperService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: UrlHelperService,\n    factory: UrlHelperService.…µfac,\n    providedIn: 'root'\n  });\n  return UrlHelperService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst typeImageReg = /[\\/.](gif|jpg|jpeg|tiff|png)$/i;\nlet HelperUploaderService = /*#__PURE__*/(() => {\n  class HelperUploaderService {\n    static checkTypeImage(fileType) {\n      return typeImageReg.test(fileType);\n    }\n\n    static estceTypeMimeAccept√©(typeMime, configTypeMime) {\n      const ext = typeMime.split('/').pop().toLowerCase();\n      return configTypeMime.indexOf(ext) !== -1;\n    }\n\n    static estceImageTypeImage(typeMime) {\n      const extension = typeMime.toLowerCase();\n      return extension.indexOf(\"image\") !== -1;\n    }\n\n    static estceImageTypeMimeGif(typeMime) {\n      const extension = typeMime.toLowerCase();\n      return this.estceImageTypeImage(typeMime) && extension.indexOf(\"gif\") !== -1;\n    }\n\n    static estceTailleUploadAccept√©(tailleFichier, configTailleUpload) {\n      const tailleMO = (tailleFichier / 1024 / 1024).toFixed(2);\n      return parseFloat(tailleMO) <= configTailleUpload;\n    }\n\n    static estceTailleUploadTotalAccept√©(tailleTotalFichiers, configTotalTailleUpload) {\n      const tailleTotalMO = (tailleTotalFichiers / 1024 / 1024).toFixed(2);\n      return parseFloat(tailleTotalMO) <= configTotalTailleUpload;\n    }\n\n  }\n\n  HelperUploaderService.…µfac = function HelperUploaderService_Factory(t) {\n    return new (t || HelperUploaderService)();\n  };\n\n  HelperUploaderService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: HelperUploaderService,\n    factory: HelperUploaderService.…µfac,\n    providedIn: 'root'\n  });\n  return HelperUploaderService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet WysiwygService = /*#__PURE__*/(() => {\n  class WysiwygService {\n    constructor() {}\n\n    toolbarOptionsToString(options) {\n      return options.map(option => option.join(' ')).join('|');\n    }\n\n  }\n\n  WysiwygService.…µfac = function WysiwygService_Factory(t) {\n    return new (t || WysiwygService)();\n  };\n\n  WysiwygService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: WysiwygService,\n    factory: WysiwygService.…µfac\n  });\n  return WysiwygService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar DataSourceType = /*#__PURE__*/(() => {\n  (function (DataSourceType) {\n    DataSourceType[\"API\"] = \"api\";\n    DataSourceType[\"BRUTE\"] = \"brute\";\n  })(DataSourceType || (DataSourceType = {}));\n\n  return DataSourceType;\n})();\nlet DatasourceService = /*#__PURE__*/(() => {\n  class DatasourceService {\n    constructor(httpService) {\n      this.httpService = httpService;\n    }\n\n    loadDataSource(config, queryString = '') {\n      if (!config) return;\n\n      switch (config.type) {\n        case DataSourceType.BRUTE:\n          // return <Observable<T>>of(config.value).pipe(delay(1000))\n          return of(config.value);\n          break;\n\n        case DataSourceType.API:\n          return this.httpService.get(`${config.value}?${queryString}`);\n          break;\n\n        default:\n          return of(null);\n          break;\n      }\n    }\n\n  }\n\n  DatasourceService.…µfac = function DatasourceService_Factory(t) {\n    return new (t || DatasourceService)(i0.…µ…µinject(HttpService));\n  };\n\n  DatasourceService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: DatasourceService,\n    factory: DatasourceService.…µfac,\n    providedIn: 'root'\n  });\n  return DatasourceService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet StringService = /*#__PURE__*/(() => {\n  class StringService {\n    constructor(stringData) {\n      this.stringData = stringData;\n      this.stringData = stringData;\n    }\n\n    toString() {\n      return this.stringData;\n    }\n\n    removeAllSpecialsCharacters() {\n      this.stringData = this.stringData.replace(/[^a-zA-Z ]/g, \"\");\n      return this;\n    }\n\n    removeAllSpaces() {\n      this.stringData = this.stringData.replace(/\\s/g, '');\n      return this;\n    }\n\n    replaceAllAccentByNonAccentCharacters() {\n      this.stringData = this.stringData.normalize(\"NFD\").replace(/\\p{Diacritic}/gu, \"\");\n      return this;\n    }\n\n  }\n\n  StringService.…µfac = function StringService_Factory(t) {\n    return new (t || StringService)(i0.…µ…µinject(String));\n  };\n\n  StringService.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n    token: StringService,\n    factory: StringService.…µfac\n  });\n  return StringService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass OdataClass {\n  setDatasource(datasource) {\n    this.datasource = datasource;\n  }\n\n  getCount() {\n    return this.datasource.d.__count;\n  }\n\n  getResults() {\n    return this.datasource.d.results;\n  }\n\n}\n\nvar FormInputComponents = /*#__PURE__*/(() => {\n  (function (FormInputComponents) {\n    FormInputComponents[\"INPUT_UPLOADER\"] = \"input-uploader\";\n    FormInputComponents[\"INPUT_TEXT\"] = \"input-text\";\n    FormInputComponents[\"INPUT_EMAIL\"] = \"input-email\";\n    FormInputComponents[\"INPUT_CHECKBOX\"] = \"input-checkbox\";\n    FormInputComponents[\"INPUT_CHECKBOX_INDETERMINATE\"] = \"input-checkbox-indeterminate\";\n    FormInputComponents[\"INPUT_NUMBER\"] = \"input-number\";\n    FormInputComponents[\"INPUT_DATE\"] = \"input-date\";\n    FormInputComponents[\"INPUT_SLIDE_TOGGLE\"] = \"input-slide-toggle\";\n    FormInputComponents[\"INPUT_PASSWORD\"] = \"input-password\";\n    FormInputComponents[\"INPUT_TEXTAREA\"] = \"input-textarea\";\n    FormInputComponents[\"INPUT_VIEWER\"] = \"input-viewer\";\n    FormInputComponents[\"INPUT_SELECT\"] = \"input-select\";\n    FormInputComponents[\"BUTTON\"] = \"button\";\n    FormInputComponents[\"LINK\"] = \"link\";\n  })(FormInputComponents || (FormInputComponents = {}));\n\n  return FormInputComponents;\n})();\n\n/** / Buttons */\nvar TypeButtonEnum = /*#__PURE__*/(() => {\n  (function (TypeButtonEnum) {\n    TypeButtonEnum[\"SUBMIT\"] = \"submit\";\n    TypeButtonEnum[\"BUTTON\"] = \"button\";\n    TypeButtonEnum[\"LINK\"] = \"link\";\n  })(TypeButtonEnum || (TypeButtonEnum = {}));\n\n  return TypeButtonEnum;\n})();\nvar ButtonIconPositon = /*#__PURE__*/(() => {\n  (function (ButtonIconPositon) {\n    ButtonIconPositon[\"START\"] = \"start\";\n    ButtonIconPositon[\"END\"] = \"end\";\n  })(ButtonIconPositon || (ButtonIconPositon = {}));\n\n  return ButtonIconPositon;\n})();\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\nexport { BroadcastEventService, ButtonIconPositon, CurrentUrlRoutingService, DataSourceType, DatasourceService, FileService, FormHelperService, FormInputComponents, GlobalErrorInterceptorService, HelperService, HelperUploaderService, HttpService, InjectComponentService, LoadingInterceptorService, LoadingService, MappingBuilderService, OdataClass, QueryBuilder, RequestInterceptorService, ScrollService, SkipHeaders, SortService, StorageService, StringService, TokenService, TypeButtonEnum, UrlHelperService, ValidatorsService, WysiwygService, typeImageReg }; //# sourceMappingURL=cocori-ng-src-feature-core.mjs.map","map":null,"metadata":{},"sourceType":"module"}